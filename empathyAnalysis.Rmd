---
  title: "EmpathyAnalysis"
author: "Benedict Greenwood"
date: "2025-01-17"
output: html_document
---

This project analyses a data from a study on ADHD traits and emotional reactivity in a social context.
Fifty pairs of friends (one 'participant' and one 'companion') completed the study.
On each trial, one of them received an electric shock of high, low, or safe (no shock) intensity.
Each trial consisted of an anticipation phase before shock delivery, then shock delivery, then a 'response' phase following shock delivery. Both subjects then rated their emotional response. Participants also completed a battery of self-report psychometric questionnaires measuring ADHD traits and various emotional traits.

This script executes the pre-registered analyses listed here https://osf.io/r8f7j
Primary research questions are listed as PRQ1, PRQ2, etc.
Secondary reserach questions are listed as SRQ1, SRQ2, etc.

Broadly, the analyses aim to quantify the relationships between ADHD traits and 
- pscyhophysiological and subjective responses to personally receiving electric shocks [a measure of emotional reactivity].
- pscyhophysiological and subjective responses to observing the friend receiving electric shocks [a measure of empathic emotional reactivity.

Psychophysiology is analysed separately during the anticipation phase and response phase. Analyses compare high (painful) vs low (non-painful) intensity shocks since the low shock condition controls for physical stimulution.

# -------------------------------------------

# Libraries

# -------------------------------------------
  
```{r}
library(ggplot2)
library(tidyr)
library(easystats)
library(hrbrthemes)
library(lmtest)
library(lmerTest)
library(lme4)
library(MASS)
library(glmmTMB)
library(robustlmm)
library(performance)
library(car)
library(betareg)
library(emmeans)
library(writexl)
library(broom)
library(RColorBrewer)
library(gridExtra)
library(grid)
library(geomtextpath)
library(ggrepel)
#library(tidyverse)
library(patchwork)
library(cowplot)
library(sandwich)
library(DHARMa)
library(dplyr)
library(ggeffects)
library(MANOVA.RM)
library(flextable)
library(officer)
library(ggh4x)  # for facet_nested()
```



# Functions

# -------------------------------------------

```{r}

#defined empty list to store functions
funcs = list()

```

## run_regression

Function to run linear regression and store results

```{r}
funcs$run_regression <- function(outcome_var, pred_var, control_vars = NULL) {
  # Subset data to include only relevant columns and remove rows with NaN values
  if (is.null(control_vars)) {
    data_subset <- na.omit(df_demographs[, c(pred_var, outcome_var)])
    formula <- as.formula(paste(outcome_var, "~", pred_var))
  } else {
    data_subset <- na.omit(df_demographs[, c(pred_var, outcome_var, control_vars)])
    
    # Mean-centre age and BMI if present in the control variables
    if ("age" %in% control_vars) {
      data_subset$age <- scale(data_subset$age, scale = FALSE)  # mean-centred only
    }
    if ("BMI" %in% control_vars) {
      data_subset$BMI <- scale(data_subset$BMI, scale = FALSE)  # mean-centred only
    }
    
    formula <- as.formula(paste(outcome_var, "~", pred_var, "+", paste(control_vars, collapse = "+")))
  }
  
  # Fit linear model
  lm_model <- lm(formula, data = data_subset)
  
  # Extract standardized parameter estimate (beta coefficient)
  std_beta <- coef(lm_model)[pred_var] * sd(data_subset[[pred_var]]) / sd(data_subset[[outcome_var]])
  
  # Extract p-value for the predictor variable
  p_value <- summary(lm_model)$coefficients[pred_var, "Pr(>|t|)"]
  
  return(list(std_beta = std_beta, p_value = p_value))
}
```


## createCorrHeatmap

Function for creating heatmap of Pearson correlations

```{r}

funcs$createCorrHeatmap <- function(dataTable, 
                              vars_for_corrs, 
                              var_labels, 
                              rows_to_keep,
                              corr_type,
                              p_adj_type,
                              fig_width,
                              fig_height,
                              fig_font_size,
                              figures_folder,
                              save_name){
  
  # Calculate correlations
  data_for_corrs <- dataTable[, vars_for_corrs]
  correlations_demographs <- Hmisc::rcorr(as.matrix(data_for_corrs), type = corr_type)
  correlations_demographs.r <- as.data.frame(correlations_demographs$r)
  correlations_demographs.p <- as.data.frame(correlations_demographs$P)
  
  # Delete repetitions from r and p-value tables
  for (i_col in 1:ncol(correlations_demographs.r)){ 
    correlations_demographs.r[i_col, i_col:ncol(correlations_demographs.r)] <- NaN
    correlations_demographs.p[i_col, i_col:ncol(correlations_demographs.p)] <- NaN
  }
  
  # Keep only the specified rows
  correlations_demographs.r <- correlations_demographs.r[rows_to_keep, ]
  correlations_demographs.p <- correlations_demographs.p[rows_to_keep, ]
  
  # Perform Holm-Bonferroni correction
  p_vals_vector <- as.vector(as.matrix(correlations_demographs.p))
  p_vals_adj <- stats::p.adjust(p_vals_vector[!is.na(p_vals_vector)], method = p_adj_type)
  
  # Reconstruct the matrix with adjusted p-values
  correlations_demographs.p_adj <- correlations_demographs.p
  correlations_demographs.p_adj[!is.na(correlations_demographs.p)] <- p_vals_adj
  
  # Add stars for Holm-adjusted p-values
  stars <- function(p) {
    if (is.na(p)) return("")
    if (p < 0.001) return("***")
    if (p < 0.01) return("**")
    if (p < 0.05) return("*")
    return("")
  }
  
  # Create a table of r-values with stars appended
  correlations_demographs.r_star <- correlations_demographs.r
  for (i in 1:nrow(correlations_demographs.r)) {
    for (j in 1:ncol(correlations_demographs.r)) {
      if (!is.na(correlations_demographs.r[i, j])) {
        correlations_demographs.r_star[i, j] <- paste0(
          round(correlations_demographs.r[i, j], 2), 
          stars(correlations_demographs.p_adj[i, j])
        )
      }
    }
  }
  
  # Convert data to long format
  corrs_data_long <- expand.grid(X = var_labels, Y = var_labels[rows_to_keep])
  
  # Format r-values without leading zero
  corrs_data_long$r_vals <- as.vector(t(correlations_demographs.r))
  corrs_data_long$r_vals_formatted <- ifelse(!is.na(corrs_data_long$r_vals),
                                             sprintf("%.2f", corrs_data_long$r_vals),
                                             "")
  corrs_data_long$r_vals_formatted <- sub("^-0", "-", corrs_data_long$r_vals_formatted)
  corrs_data_long$r_vals_formatted <- sub("^0", "", corrs_data_long$r_vals_formatted)
  
  corrs_data_long$p_vals <- as.vector(t(correlations_demographs.p_adj))
  
  # Add stars to long format data
  corrs_data_long$p_as_star <- sapply(corrs_data_long$p_vals, stars)
  corrs_data_long$r_vals_star <- ifelse(!is.na(corrs_data_long$r_vals), 
                                        paste0(corrs_data_long$r_vals_formatted, corrs_data_long$p_as_star), 
                                        "")
  
  # Reverse the order of the X-axis
  corrs_data_long$X <- factor(corrs_data_long$X, levels = rev(var_labels))
  
  # Plot heatmap based on r-values
  corr_type_label = paste0(corr_type, "'s r") #create label
  corr_type_label <- paste0(toupper(substr(corr_type_label, 1, 1)), #capitalise first letter
                            substr(corr_type_label, 2, nchar(corr_type_label)))
  
 fig1 <- ggplot(corrs_data_long, aes(X, Y, fill = r_vals)) + 
    geom_tile() +
    scale_fill_gradient2(name = corr_type_label, 
                         low = "blue", 
                         mid = "white", 
                         high = "red", 
                         midpoint = 0, 
                         limits = c(-1, 1),
                         na.value = "white") +
    theme_ipsum() +
    geom_text(aes(label = r_vals_star), color = "black", size = fig_font_size/3) +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1, color = "black", size = fig_font_size),
          axis.text.y = element_text(color = "black", size = fig_font_size),
          axis.title.x = element_blank(),
          axis.title.y = element_blank())
  
  # Save r vals, p vals and heatmap
  write.csv(correlations_demographs.r_star, 
            file= paste0(figures_folder, "/", save_name, "_rvals.csv")) # r vals
  ggsave(paste0(figures_folder, "/", save_name, "_heatmap.png"), fig1, dpi = 300, width = fig_width, height = fig_height, units = "in") # image
  
  # Return outputs
  return(list(rvals = correlations_demographs.r,
    rvals_stars = correlations_demographs.r_star,
              pvalsHolm = correlations_demographs.p_adj,
              corr_heatmap = fig1))
}


```

## neaten_SEM_minitable

Function for rounding values, scaling parameter estimates by x10-2 and annotating p values

```{r}
funcs$neaten_SEM_minitable <- function(minitable, power_min2){
  
  # Round z value to 2dp
  minitable$statistic <- round(minitable$statistic, 2)
  
  # Apply x10^-2 scaling if needed
  if (power_min2){ 
    minitable[, c('std.all', 'estimate', 'std.error')] <- 100 * minitable[, c('std.all', 'estimate', 'std.error')] # Multiply by 100
    
    # Rename columns 2:4 with x10-2
    colnames(minitable)[2:6] <- c("Beta x10-2", "Est. x10^2", "SE x10^2", "z", "p")

  } else {
    # Otherwise rename columns 2:4 without
    colnames(minitable)[2:6] <- c("Beta", "Est.", "SE", "z", "p")
  }
  
  # Round values in cols 2:4 to 2dp
  minitable[, 2:4] <- round(minitable[, 2:4], 2)
  
  # Remove leading zeros from numeric columns (cols 2:4)
  minitable[, 2:4] <- lapply(minitable[, 2:4], function(x) {
    x <- as.character(x)  # Convert to character
    x <- sub("^0+", "", x) # Remove leading zeros
    #as.numeric(x)          # Convert back to numeric
  })
  
  # Process p-values safely
  minitable$p <- as.character(minitable$p)  # Ensure it's character
  numeric_p_vals <- suppressWarnings(as.numeric(minitable$p))  # Convert safely
  
  v_sig_p_vals <- !is.na(numeric_p_vals) & numeric_p_vals < 0.01
  vv_sig_p_vals <- !is.na(numeric_p_vals) & numeric_p_vals < 0.001
  
  # Remove leading zeros from p-values
  minitable$p <- sub("^0+", "", minitable$p)
  
  # Replace significant p-values
  minitable$p[v_sig_p_vals] <- "<.01"
  minitable$p[vv_sig_p_vals] <- "<.001"
  
  # Round p-values not in v_sig_p_vals or vv_sig_p_vals to 3 decimal places
  minitable$p[!v_sig_p_vals & !vv_sig_p_vals] <- round(numeric_p_vals[!v_sig_p_vals & !vv_sig_p_vals], 3)
  
  #Remove leading zeros from p values again if needed
minitable$p <- sub("^0+", "", minitable$p)

  
  return(minitable)
}
```

## calculate_condition_stats

```{r}
funcs$calculate_condition_stats <- function(data, stat_vars, condition_vars) {
  #condition_vars define the variables which should be used to specify conditions (each 
  #unique combination of the variables)
  
  #stat_vars defines the variables for which you want to calculate the mean and SD
  data %>%
    group_by(across(all_of(c("subjectID", condition_vars)))) %>%
    summarise(across(all_of(stat_vars), 
                     list(mean = ~mean(., na.rm = TRUE),
                          sd = ~sd(., na.rm = TRUE),
                          n = ~sum(!is.na(.)))),
              .groups = 'drop') %>%
    ungroup() %>%
    as_tibble()
}
```

## z score

```{r}
# Z-score function that ignores NA values
funcs$z_score <- function(x) {
  (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)
}
```

## lm_and_assumptions

Run linear model and test its assumptions

```{r}
funcs$lm_and_assumptions <- function(model_formula, data, test_multicollinearity) {
  
  # Fit model
  model <- lm(model_formula, data)
  
  #fit robust model
  robust_model <- rlm(model_formula, data)
  
  # 1) Linear relationship
  model_checks <- check_model(model)
  linearity_fitted <- model_checks$NCV$x
  linearity_resids <- model_checks$NCV$y

  # 2) Normally-distributed residuals
  normality_plot <- plot(check_normality(model), type = "qq")
  shapiro_test <- shapiro.test(residuals(model))
  
  # 3) Multicollinearity (only if 2 or more predictors)
  if (test_multicollinearity == TRUE) {
    vif_results <- car::vif(model)
    multicollinearity_result <- ifelse(any(vif_results > 5), "Violated", "Not violated")
    multicollinearity_statistic <- paste(names(vif_results), round(vif_results, 2), collapse = ", ")
    multicollinearity_p_value <- NA
  } else {
    vif_results <- NA
    multicollinearity_result <- "Not applicable"
    multicollinearity_statistic <- "Fewer than 2 predictors"
    multicollinearity_p_value <- NA
  }
  
  # 4) Homoscedasticity
  bp_test <- bptest(model)
  
  # 5) Influential outliers
  outliers <- check_outliers(model, method = 'cook')
  outliers_exist <- any(outliers == TRUE)
  
  # 6) Posterior predictive checks
  pred_check <- check_predictions(model)
  
  # Create summary table
  assumptions_summary <- data.frame(
    Assumption = c("Normality", "Multicollinearity", "Homoscedasticity", "Influential Outliers"),
    Test = c("Shapiro-Wilk", "VIF", "Breusch-Pagan", "Cook's Distance"),
    Result = c(
      ifelse(shapiro_test$p.value < 0.05, "Violated", "Not violated"),
      multicollinearity_result,
      ifelse(bp_test$p.value < 0.05, "Violated", "Not violated"),
      ifelse(outliers_exist, "Violated", "Not violated")
    ),
    Statistic = c(
      paste("W =", round(shapiro_test$statistic, 3)),
      multicollinearity_statistic,
      paste("X^2 =", round(bp_test$statistic, 2)),
      paste("Max Cook's D =", round(max(cooks.distance(model)), 3))
    ),
    p_value = c(
      shapiro_test$p.value,
      multicollinearity_p_value,
      bp_test$p.value,
      NA
    )
  )
  
  # Determine if robust methods are needed
  use_robust_se <- bp_test$p.value < 0.05
  use_robust_regression <- outliers_exist
  
  # Apply robust methods if needed
  final_model <- model
  if (use_robust_regression && use_robust_se) {
    
    robust_se_model <- coeftest(robust_model, vcov = sandwich::vcovHC(robust_model, type = "HC3"))
    final_model <- robust_se_model
  } else if (use_robust_regression) {
    
    final_model <- robust_model
  } else if (use_robust_se) {
    robust_se_model <- coeftest(model, vcov = sandwich::vcovHC(model, type = "HC3"))
    final_model <- robust_se_model
  }
  
  # Prepare return list
  results <- list(
    original_model = model,
    robust_model = robust_model,
    final_model = final_model,
    assumptions_summary = assumptions_summary,
    linearity_fitted = linearity_fitted,
    linearity_resids = linearity_resids,
    normality_plot = normality_plot,
    normality_test = shapiro_test,
    predictions_check = pred_check,
    use_robust_se = use_robust_se,
    use_robust_regression = use_robust_regression
  )
  
  return(results)
}
```

## print_lm_results_assumptions

Print linear model results and assumpations

```{r}
funcs$print_lm_results_assumptions <- function(lm_results){
  
  # --- Show plots:
  print(plot(lm_results$linearity_resids, lm_results$linearity_fitted))
  print(lm_results$normality_plot)
  print(plot(lm_results$predictions_check))
  
  #--- Print which assumptions violated
  
  #normality
  if (lm_results$normality_test$p.value < 0.05){
    cat(paste("\nNon-normal redisuals detected by Shapiro-Wilk test (p=)", round(lm_results$normality_test$p.value, 4), "\n Check fitted vs residuals plot and posterior predictive check. If non-normality is severe, consider transforming data or using alternative model (e.g. betareg, poisson). If that fails consider robust regression.\n"))
  }
  
  #homoscedasticity and outliers
  if (lm_results$use_robust_se && lm_results$use_robust_regression) {
    cat("\nBoth homoscedasticity violated and influential outliers detected. Robust regression with robust standard errors applied.\n")
  } else if (lm_results$use_robust_se) {
    cat("\nHomoscedasticity violated. Robust standard errors applied.\n")
  } else if (lm_results$use_robust_regression) {
    cat("\nInfluential outliers detected. Robust regression applied.\n")
  }
  
  #--- Print summary of the final model
  cat("\nSummary of the Final Model:\n")
  if (lm_results$use_robust_regression && lm_results$use_robust_se) {
    print(lm_results$final_model)
  } else if (lm_results$use_robust_regression) {
    print(summary(lm_results$final_model))
  } else if (lm_results$use_robust_se) {
    print(lm_results$final_model)
  } else {
    print(summary(lm_results$final_model))
  }
  
  #--- Print assumptions table
  print(lm_results$assumptions_summary)
  
}
```

## lmer_and_assumptions

Run linear mixed effects model and test its assumptions

```{r}
funcs$lmer_and_assumptions <- function(model_formula, data) {
  
  # Fit model
  model <- lmer(model_formula, data)
  
  # Fit robust model
  robust_model <- rlmer(model_formula, data)
  
  # Get number of predictors
  n_predictors <- length(coef(model))
  
  # 1) Linear relationship
  model_checks <- check_model(model)
  linearity_fitted <- model_checks$NCV$x
  linearity_resids <- model_checks$NCV$y

  # 2) Normally-distributed residuals
  normality_plot <- check_normality(model)
  shapiro_test <- check_normality(model)
  
  # 3) Multicollinearity (only if 2 or more predictors)
  if (n_predictors >= 2) {
    vif_results <- car::vif(model)
    multicollinearity_result <- ifelse(any(vif_results > 5), "Violated", "Not violated")
    multicollinearity_statistic <- paste(names(vif_results), round(vif_results, 2), collapse = ", ")
    multicollinearity_p_value <- NA
  } else {
    vif_results <- NA
    multicollinearity_result <- "Not applicable"
    multicollinearity_statistic <- "Fewer than 2 predictors"
    multicollinearity_p_value <- NA
  }
  
  # 4) Homoscedasticity
  bp_test <- check_heteroskedasticity(model)
  
  # 5) Influential outliers
  outliers <- check_outliers(model, method = 'cook')
  outliers_exist <- any(outliers == TRUE)
  
  # 6) Posterior predictive checks
  pred_check <- check_predictions(model)
  
  # 7) Normally-distributed random effects
  normality_ranef_plot <- plot(check_normality(model, effects = c("random")), type = "qq")

  # Create summary table
  assumptions_summary <- data.frame(
    Assumption = c("Normality", "Multicollinearity", "Homoscedasticity", "Influential Outliers"),
    Test = c("Shapiro-Wilk", "VIF", "Breusch-Pagan", "Cook's Distance"),
    Result = c(
      ifelse(shapiro_test < 0.05, "Violated", "Not violated"),
      multicollinearity_result,
      ifelse(bp_test < 0.05, "Violated", "Not violated"),
      ifelse(outliers_exist, "Violated", "Not violated")
    ),
    Statistic = c(
      NA,
      multicollinearity_statistic,
      NA,
      paste("Max Cook's D =", round(max(cooks.distance(model)), 3))
    ),
    p_value = c(
      shapiro_test,
      multicollinearity_p_value,
      bp_test,
      NA
    )
  )
  
  # Determine if robust methods are needed
  use_robust_se <- bp_test < 0.05
  use_robust_regression <- outliers_exist
  
  # Apply robust methods if needed
  final_model <- model
  model_without_outliers <- NULL
  
  if (use_robust_regression) {
    final_model <- robust_model
    
    # Refit model without outliers
    non_outlier_data <- data[!outliers, ]
    model_without_outliers <- lmer(model_formula, data = non_outlier_data)
    
  } else if (use_robust_se) {
    robust_se_model <- clubSandwich::coef_test(model, vcov = "CR2")
    final_model <- robust_se_model
  }
  
  # Prepare return list
  results <- list(
    original_model = model,
    robust_model = robust_model,
    final_model = final_model,
    model_without_outliers = model_without_outliers,
    assumptions_summary = assumptions_summary,
    linearity_fitted = linearity_fitted,
    linearity_resids = linearity_resids,
    normality_plot = normality_plot,
    normality_test = shapiro_test,
    predictions_check = pred_check,
    normality_ranef_plot = normality_ranef_plot,
    use_robust_se = use_robust_se,
    use_robust_regression = use_robust_regression,
    outliers = outliers
  )
  
  return(results)
}


```

## print_lmer_results_assumptions

Print results and assumptions tests from lmer

```{r}
funcs$print_lmer_results_assumptions <- function(lmer_results){
  
  # --- Show plots:
  print(plot(lmer_results$linearity_resids, lmer_results$linearity_fitted))
  print(plot(lmer_results$normality_plot))
  print(plot(lmer_results$predictions_check))
  print(lmer_results$normality_ranef_plot)
  
  #--- Print which assumptions violated
  
  #normality
  if (lmer_results$normality_test < 0.05){
    cat(paste("\nNon-normal redisuals detected by Shapiro-Wilk test (p=", round(lmer_results$normality_test, 3), ")\n Check fitted vs residuals plot and posterior predictive check. If non-normality is severe, consider transforming data or using alternative model (e.g. betareg, poisson). If that fails consider robust regression.\n"))
  }
  
  #homoscedasticity and outliers
  
  if (lmer_results$use_robust_se & lmer_results$use_robust_regression) {
    cat("\nHomoscedasticity violated and influential outliers detected. Robust lmer applied.\n") 
  } else if (lmer_results$use_robust_se) {
    cat("\nHomoscedasticity violated. Robust standard errors applied.\n")
  } else if (lmer_results$use_robust_regression) {
    cat("\nInfluential outliers detected. Robust lmer applied.\n")
  }
  
  #--- Print summary of the final model
  cat("\nSummary of the Final Model:\n")
  if (lmer_results$use_robust_regression) {
    print(summary(lmer_results$final_model))
    #> N.B. rlmer package does not produce p values. One alternative is bootstrapped 95% CIs
    
  } else if (lmer_results$use_robust_se) {
    print(lmer_results$final_model)
    
  } else {
    print(summary(lmer_results$final_model))
  }
  
  #--- Print assumptions table
  print(lmer_results$assumptions_summary)
}

```

## Save lmm table

```{r}
funcs$savelmmTable <- function(lmm_model, file_path){
  
  # Export model table with 95% CI to word doc
  sjPlot::tab_model(lmm_model, 
                    show.se = TRUE, show.stat = TRUE, show.df = TRUE, transform = NULL, #show SE, test statistic, degrees of freedom, don't transform to odds ratio
                  col.order = c("est", "se", "ci", "df.error", "stat", "p" ), #column order
                  string.stat = "t", #next few lines change column header text
                  string.ci = "95% CI",
                  string.se = "SE",
                  string.pred = "Effect",
                  string.est = "Estimate",
                  string.df = "df",
                  df.method = "satterthwaite",
                    file = file_path)

}
```

##save glmmTMB beta table

```{r}
funcs$saveglmmTMBbetaTable <- function(glmmTMB_model, file_path){
  
  # Export model table with 95% CI to word doc
  sjPlot::tab_model(glmmTMB_model, 
                    show.se = TRUE, show.stat = TRUE, transform = NULL, #show SE, test statistic, degrees of freedom, don't transform to odds ratio
                  col.order = c("est", "se", "ci", "stat", "p" ), #column order
                  string.stat = "z", #next few lines change column header text
                  string.ci = "95% CI",
                  string.se = "SE",
                  string.pred = "Effect",
                  string.est = "Estimate",
                    file = file_path)
}


funcs$saveglmmTMBbetaTable_scientific <- function(glmmTMB_model, file_path) {
  #library(broom.mixed)
  #library(flextable)
  
  # Get tidy model output with confidence intervals
  tbl <- broom.mixed::tidy(glmmTMB_model, conf.int = TRUE)
  
  # Format desired columns in scientific notation
  tbl$estimate <- formatC(tbl$estimate, format = "E", digits = 2)
  tbl$std.error <- formatC(tbl$std.error, format = "E", digits = 2)
  tbl$conf.low <- formatC(tbl$conf.low, format = "E", digits = 2)
  tbl$conf.high <- formatC(tbl$conf.high, format = "E", digits = 2)
  
  # Combine CI into a single column
  tbl$`95% CI` <- paste0("[", tbl$conf.low, ", ", tbl$conf.high, "]")
  
  # Select and rename columns
  tbl_out <- tbl[, c("term", "estimate", "std.error", "95% CI", "statistic", "p.value")]
  colnames(tbl_out) <- c("Effect", "Estimate", "SE", "95% CI", "z", "p")
  
  # Create flextable
  ft <- flextable::flextable(tbl_out)
  
  # Save as Word document
  flextable::save_as_docx(ft, path = file_path)
}
```


## lm_and_assumptions

Run linear model and test its assumptions

```{r}
funcs$lm_and_assumptions <- function(model_formula, data, test_multicollinearity) {
  
  # Fit model
  model <- lm(model_formula, data)
  
  #fit robust model
  robust_model <- rlm(model_formula, data)
  
  # 1) Linear relationship
  model_checks <- check_model(model)
  linearity_fitted <- model_checks$NCV$x
  linearity_resids <- model_checks$NCV$y

  # 2) Normally-distributed residuals
  normality_plot <- plot(check_normality(model), type = "qq")
  shapiro_test <- shapiro.test(get_residuals(model))
  
  # 3) Multicollinearity (only if 2 or more predictors)
  if (test_multicollinearity == TRUE) {
    vif_results <- car::vif(model)
    multicollinearity_result <- ifelse(any(vif_results > 5), "Violated", "Not violated")
    multicollinearity_statistic <- paste(names(vif_results), round(vif_results, 2), collapse = ", ")
    multicollinearity_p_value <- NA
  } else {
    vif_results <- NA
    multicollinearity_result <- "Not applicable"
    multicollinearity_statistic <- "Fewer than 2 predictors"
    multicollinearity_p_value <- NA
  }
  
  # 4) Homoscedasticity
  bp_test <- bptest(model)
  
  # 5) Influential outliers
  outliers <- check_outliers(model, method = 'cook')
  outliers_exist <- any(outliers == TRUE)
  
  # 6) Posterior predictive checks
  pred_check <- check_predictions(model)
  
  # Create summary table
  assumptions_summary <- data.frame(
    Assumption = c("Normality", "Multicollinearity", "Homoscedasticity", "Influential Outliers"),
    Test = c("Shapiro-Wilk", "VIF", "Breusch-Pagan", "Cook's Distance"),
    Result = c(
      ifelse(shapiro_test$p.value < 0.05, "Violated", "Not violated"),
      multicollinearity_result,
      ifelse(bp_test$p.value < 0.05, "Violated", "Not violated"),
      ifelse(outliers_exist, "Violated", "Not violated")
    ),
    Statistic = c(
      paste("W =", round(shapiro_test$statistic, 3)),
      multicollinearity_statistic,
      paste("X^2 =", round(bp_test$statistic, 2)),
      paste("Max Cook's D =", round(max(cooks.distance(model)), 3))
    ),
    p_value = c(
      shapiro_test$p.value,
      multicollinearity_p_value,
      bp_test$p.value,
      NA
    )
  )
  
  # Determine if robust methods are needed
  use_robust_se <- bp_test$p.value < 0.05
  use_robust_regression <- outliers_exist
  
  # Apply robust methods if needed
  final_model <- model
  if (use_robust_regression && use_robust_se) {
    
    robust_se_model <- coeftest(robust_model, vcov = sandwich::vcovHC(robust_model, type = "HC3"))
    final_model <- robust_se_model
  } else if (use_robust_regression) {
    
    final_model <- robust_model
  } else if (use_robust_se) {
    robust_se_model <- coeftest(model, vcov = sandwich::vcovHC(model, type = "HC3"))
    final_model <- robust_se_model
  }
  
  # Prepare return list
  results <- list(
    original_model = model,
    robust_model = robust_model,
    final_model = final_model,
    assumptions_summary = assumptions_summary,
    linearity_fitted = linearity_fitted,
    linearity_resids = linearity_resids,
    normality_plot = normality_plot,
    normality_test = shapiro_test,
    predictions_check = pred_check,
    use_robust_se = use_robust_se,
    use_robust_regression = use_robust_regression
  )
  
  return(results)
}
```

## print_lm_results_assumptions

Print linear model results and assumpations

```{r}
funcs$print_lm_results_assumptions <- function(lm_results){
  
  # --- Show plots:
  print(plot(lm_results$linearity_resids, lm_results$linearity_fitted))
  print(lm_results$normality_plot)
  print(plot(lm_results$predictions_check))
  
  #--- Print which assumptions violated
  
  #normality
  if (lm_results$normality_test$p.value < 0.05){
    cat(paste("\nNon-normal redisuals detected by Shapiro-Wilk test (p=)", round(lm_results$normality_test$p.value, 4), "\n Check fitted vs residuals plot and posterior predictive check. If non-normality is severe, consider transforming data or using alternative model (e.g. betareg, poisson). If that fails consider robust regression.\n"))
  }
  
  #homoscedasticity and outliers
  if (lm_results$use_robust_se && lm_results$use_robust_regression) {
    cat("\nBoth homoscedasticity violated and influential outliers detected. Robust regression with robust standard errors applied.\n")
  } else if (lm_results$use_robust_se) {
    cat("\nHomoscedasticity violated. Robust standard errors applied.\n")
  } else if (lm_results$use_robust_regression) {
    cat("\nInfluential outliers detected. Robust regression applied.\n")
  }
  
  #--- Print summary of the final model
  cat("\nSummary of the Final Model:\n")
  if (lm_results$use_robust_regression && lm_results$use_robust_se) {
    print(lm_results$final_model)
  } else if (lm_results$use_robust_regression) {
    print(summary(lm_results$final_model))
  } else if (lm_results$use_robust_se) {
    print(lm_results$final_model)
  } else {
    print(summary(lm_results$final_model))
  }
  
  #--- Print assumptions table
  print(lm_results$assumptions_summary)
  
}
```

## export_regression_table_to_word

```{r}
funcs$export_regression_table_to_word <- function(model, file, sci_format = FALSE) {
  # Helper: format for 2dp or scientific notation
  format_num <- function(x) {
    if(sci_format) {
      sprintf("%.2e", x)
    } else {
      sprintf("%.2f", x)
    }
  }

  # Extract formula and data for refitting
  mod_formula <- formula(model)
  mod_data <- model.frame(model)
  num_cols <- sapply(mod_data, is.numeric) # Identify numeric columns
  mod_data_z <- mod_data # Create a copy of your data
  mod_data_z[num_cols] <- scale(mod_data[num_cols]) # Standardise only numeric columns

  # Refit on standardised data
  lm_standardised <- lm(mod_formula, data = mod_data_z)

  # Extract coefficients, SEs, t, p, and CIs from BOTH the original and the standardised fit
  # Original (for raw SE, t, p, df, and raw estimate CI)
  coefs <- summary(model)$coefficients
  cis <- confint(model)
  coefs_df <- as.data.frame(coefs)
  coefs_df$lower_ci <- cis[, 1]
  coefs_df$upper_ci <- cis[, 2]
  coefs_df$df <- summary(model)$df[2]

  # Standardised fit (for fully standardised parameters)
  std_coefs <- summary(lm_standardised)$coefficients
  coefs_df$Std_Estimate <- std_coefs[, "Estimate"] # Betas directly from the fit on z-data

  # Ready for table output
  coefs_df$Parameter <- rownames(coefs_df)
  coefs_df$Estimate <- format_num(coefs_df$Estimate)
  coefs_df$SE <- format_num(coefs_df$`Std. Error`)
  coefs_df$`std. Beta` <- format_num(coefs_df$Std_Estimate)
  coefs_df$lower_ci <- format_num(coefs_df$lower_ci)
  coefs_df$upper_ci <- format_num(coefs_df$upper_ci)

  # Prepare the table
  coefs_df$`95% CI` <- paste0("[", coefs_df$lower_ci, ", ", coefs_df$upper_ci, "]")
 
   tab <- coefs_df %>%
    dplyr::select(Parameter,
           Estimate,
           SE,
           `std. Beta`,
           `95% CI`,
           df,
           t = `t value`,
            p = `Pr(>|t|)`)

  tab$p <- ifelse( as.numeric(tab$p) < 0.001, "<0.001",
  sprintf("%.3f", round(as.numeric(tab$p), 3))) #round to 3dp
  tab$t <- round(as.numeric(tab$t), 2)

  # Make the flextable
  ft <- flextable(tab)
  ft <- set_table_properties(ft, layout = "autofit")
  ft <- font(ft, fontname = "Calibri", part = "all")
  ft <- fontsize(ft, size = 11, part = "all")

  # Model statistics (as text)
  s <- summary(model)
  f_stat <- s$fstatistic
  f_text <- sprintf("F(%d, %d) = %.3f, p = %.3f",
                    f_stat["numdf"], f_stat["dendf"], f_stat["value"],
                    pf(f_stat["value"], f_stat["numdf"], f_stat["dendf"], lower.tail = FALSE))
  stats_text <- paste0(
    "Residual SE: ", sprintf("%.3f", sigma(model)), "; ",
    "Multiple R-squared: ", sprintf("%.3f", s$r.squared), "; ",
    "Adjusted R-squared: ", sprintf("%.3f", s$adj.r.squared), "; ",
    f_text
  )

  # Write to Word
  doc <- read_docx() %>%
    body_add_flextable(ft) %>%
    body_add_par(stats_text, style = "Normal")
  print(doc, target = file)
  message(sprintf("Table saved to: %s", file))
}

```

## adjust_lmm_p_vals

```{r}
funcs$adjust_lmm_p_vals <- function(model, anova_or_summary, test_type, p_adj_method, anova_errors_type){
  #stop if test type is invalid
  test_type_options = c("t", "z", "Chi", "F")
  if (!test_type %in% test_type_options) {
  stop(paste("ERROR: test_type must be one of:", paste(test_type_options, collapse = ", ")))
  }  
  
  if (anova_or_summary == "summary"){
    coefs <- summary(model)$coefficients # Get summary coefficients
    if (test_type == "t"){
      raw_pvals <- coefs[, 'Pr(>|t|)'] # Extract the raw p-values
    } else if (test_type == "z"){
      raw_pvals <- coefs[, 'Pr(>|z|)'] # Extract the raw p-values
    }
    adj_pvals <- p.adjust(raw_pvals, method = p_adj_method) # Apply p value adjustment
    coefs_with_adj <- cbind(coefs, p_adj = adj_pvals) # Add as a new column
    adj_pvals <- p.adjust(raw_pvals, method = p_adj_method) # Apply p value adjustment
    coefs_with_adj <- cbind(coefs, p_adj = adj_pvals) # Add as a new column
    
    #print results
    print(coefs_with_adj)
    
    #return results as table
    return(coefs_with_adj)
    
  } else if (anova_or_summary == "anova"){
    anova_res <- Anova(model, type = anova_errors_type )
    
    if (test_type == "Chi"){
      raw_pvals <- anova_res$`Pr(>Chisq)` 
    } else if (test_type == "F"){
      raw_pvals <- anova_res$`Pr(>F)` 
    }
    adj_pvals <- p.adjust(raw_pvals, method = p_adj_method) # e.g., Holm, Tukey
    
    anova_res$p_adj <- adj_pvals
    
    #print results
    print(anova_res)
    
    #return results as table
    return(anova_res)
  }
}
```

## parse_hr_data

```{r}
# Function to parse string data into numeric vector
funcs$parse_hr_data <- function(x) {
  if (x == "[nan]") return(NULL)
  as.numeric(strsplit(gsub("\\[|\\]", "", x), ",")[[1]])
}

# Function to calculate mean timeseries
funcs$calc_mean_timeseries <- function(data_list) {
  data_list <- data_list[!sapply(data_list, is.null)]
  if (length(data_list) == 0) return(NULL)
  
  max_length <- max(sapply(data_list, length))
  result <- numeric(max_length)
  count <- numeric(max_length)
  
  for (data in data_list) {
    result[1:length(data)] <- result[1:length(data)] + data
    count[1:length(data)] <- count[1:length(data)] + 1
  }
  
  result / count
}
```

## expand_timeseries

```{r}
# Function to expand a list of timeseries into a tibble with one column per timepoint
funcs$expand_timeseries <- function(timeseries_list, max_length) {
  expanded_series <- tibble(
    subjectID = seq_along(timeseries_list),
    timeseries = timeseries_list
  ) %>%
    mutate(
      expanded = map(timeseries, ~ c(.x, rep(NA, max_length - length(.x))))
    ) %>%
    unnest_wider(expanded, names_sep = "_") %>%
    dplyr::select(-subjectID, -timeseries)
  
  colnames(expanded_series) <- paste0("t", seq_len(ncol(expanded_series)))
  return(expanded_series)
}
```

## adjust_glmmTMB_p_vals

```{r}
#Function for adjusting p values from glmmTBB
funcs$adjust_glmmTMB_p_vals <- function(model, anova_or_summary, test_type, p_adj_method, anova_errors_type){
  #stop if test type is invalid
  test_type_options = c("t", "z", "Chi", "F")
  if (!test_type %in% test_type_options) {
  stop(paste("ERROR: test_type must be one of:", paste(test_type_options, collapse = ", ")))
  }  
  
  if (anova_or_summary == "summary"){
    coefs <- summary(model)$coefficients$cond # Get summary coefficients
    if (test_type == "t"){
      raw_pvals <- coefs[, 'Pr(>|t|)'] # Extract the raw p-values
    } else if (test_type == "z"){
      raw_pvals <- coefs[, 'Pr(>|z|)'] # Extract the raw p-values
    }
    adj_pvals <- p.adjust(raw_pvals, method = p_adj_method) # Apply p value adjustment
    coefs_with_adj <- cbind(coefs, p_adj = adj_pvals) # Add as a new column
    adj_pvals <- p.adjust(raw_pvals, method = p_adj_method) # Apply p value adjustment
    coefs_with_adj <- cbind(coefs, p_adj = adj_pvals) # Add as a new column
    
    return(coefs_with_adj)
    
  } else if (anova_or_summary == "anova"){
    anova_res <- Anova(model, type = anova_errors_type )
    
    if (test_type == "Chi"){
      raw_pvals <- anova_res$`Pr(>Chisq)` 
    } else if (test_type == "F"){
      raw_pvals <- anova_res$`Pr(>F)` 
    }
    adj_pvals <- p.adjust(raw_pvals, method = p_adj_method) # e.g., Holm, Tukey
    anova_res$p_adj <- adj_pvals
    return(anova_res)
  }
}
```

## refit_model_replace_term

```{r}
#------Function to refit model after replacing specific term

funcs$refit_model_replace_term <- function(original_model, var_to_remove, new_var) {
  # Extract original formula components
  original_formula <- formula(original_model)
  formula_text <- deparse(original_formula)
  
  # Replace all occurrences of CAARS_T_index_centred (including interactions)
  new_formula <- gsub(
    var_to_remove, 
    new_var, 
    formula_text,
    fixed = TRUE
  )
  
  # Convert back to formula and update environment
  new_formula <- as.formula(new_formula)
  environment(new_formula) <- environment(original_formula)
  
  # Refit model with new formula
  update(original_model, formula. = new_formula)
}
```

## process_timeseries

```{r}
# Convert to long format and calculate scaled HR
funcs$process_timeseries <- function(data, scaled = FALSE) {
  if (scaled){ 
    #data <- data - data$t1
    row_means <- rowMeans(data[, paste0("t", 1:10)])
    data <- data - row_means
    }
  
  data %>%
    rowid_to_column("subject") %>%
    pivot_longer(
      cols = starts_with("t"),
      names_to = "timepoint",
      values_to = "value"
    ) %>%
    mutate(timepoint = as.numeric(gsub("t", "", timepoint)) - 1)  #change timepoints to start at 0 not 1
}
```

## calc_grandmean

Calculate grand mean timeseries

```{r}
funcs$calc_grandmean <- function(data) {
  # Calculate raw statistics
  grandmean <- data %>%
    group_by(timepoint) %>%
    summarise(
      mean_value = mean(value, na.rm = TRUE),
      sd = sd(value, na.rm = TRUE),
      n = n(),
      se = sd / sqrt(n),
      ci = 1.96 * se
    )
  
  # Add smoothed mean value using loess
  grandmean <- grandmean %>%
    mutate(
      smoothed_mean_value = predict(loess(mean_value ~ timepoint, data = grandmean))
    )
  
  return(grandmean)
}
```

## fit_univariate_lmm

Function for fitting univariate linear mixed model

```{r}
funcs$fit_univariate_lmm <- function(dv, data, 
                               random_effect = "(1 | subjectID)", 
                               control = lmerControl(optimizer = "bobyqa")) {
  # Construct formula from character input
  formula <- as.formula(
    paste(dv, "~ CAARS_T_index_centred*shock_intensity*recipient +", random_effect)
  )
  
  # Fit model with error handling
  model <- tryCatch(
    {
      lmer(formula, data = data, control = control)
    },
    error = function(e) {
      message("Model failed to converge. Trying Nelder-Mead optimizer...")
      control$optimizer <- "Nelder_Mead"
      lmer(formula, data = data, control = control)
    }
  )
  
  anova_p_adj = funcs$adjust_lmm_p_vals(model, 
                                      "anova", "Chi", "holm", "3")
  return(model)
  #summary_p_adj = funcs$adjust_lmm_p_vals(model, 
  #                                    "summary", "t", "holm", NA)
  #summary_p_adj
}

```

## save_manova_MATS_table

save MANOVA MATS table

```{r}
funcs$save_manova_MATS_table <- function(manova_model, 
                                   savefilepath){
  
  # Create table showing results of interest
  df_manova <- as.data.frame(manova_model$MATS) # take MATS test statistic
  df_manova$term <- rownames(df_manova) #add rownames
  resampled_p_vals <- as.data.frame(manova_model$resampling) #get Wild BS resampled p values
  df_manova$p_WildBS_MATS <- resampled_p_vals$`WildBS (MATS)`
  names(df_manova)[names(df_manova) == "Test statistic"] <- "MATS" #rename test statistic column
  df_manova <- df_manova[,c("term", "MATS", "p_WildBS_MATS")] #reorder columns
  
  write_xlsx(df_manova, savefilepath)
  
}

```

## plot_scatter

Scatter plot between two variables

```{r}
funcs$plot_scatter <- function(dData, 
                               y_var, 
                               x_var, 
                               y_lab, 
                               x_lab, 
                               saveFile){
  #create figure 
  p <- ggplot(dData, aes(y = .data[[y_var]], x=!!sym(x_var) )) +
    geom_point() +
    geom_smooth(method=lm , color = custom_palette[1], fill = custom_palette[1], se=TRUE) + labs(
      y = y_lab,
      x = x_lab) + 
    theme_classic(base_size = 18) + theme(plot.title = element_text(hjust = 0.5))
  
  #save
  ggsave(saveFile, p, 
         dpi = 300, 
         width = 4, 
         height = 4, 
         units = "in")
  
  #return figure
  return(p)
}
```

## plot_adhd_intens_time

```{r}
#----- Function to plot model of ADHD vs shock intensity vs time (3-way)

funcs$plot_adhd_intens_time <- function(pred_vals_adhd_intens_time,
                                  save_destination,
                                  fig_width,
                                  fig_height,
                                  phase,
                                  measure
                                  ){
  #define y axis label
  if (measure == "HR"){
    y_label = "Heart rate (bpm)"
  } else if (measure == "SCL"){ 
    y_label = "SCL (µS)"
  } else if (measure == "fisys"){ 
    y_label = "Systolic blood pressure (mmHg)"
  } else if (measure == "fidia"){ 
    y_label = "Diastolic blood pressure (mmHg)"
  } else{
      print("ERROR: measure needs to be one of HR, SCL, fisys, or fidia")
      break
  }
  
  #define figure title
  title_label = paste0("Model-predicted ", measure, 
                       " during the ", phase, 
                       " phase,\nsplit by ADHD traits, Shock Intensity, and Time Window")
  
  p_adhd_intens_time <- ggplot(pred_vals_adhd_intens_time, aes(x = time, y = predicted, color = facet, fill = facet, group = facet)) +
    geom_line(size = 1.2) +
    geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = 0.15, color = NA) +
    facet_wrap(~group, ncol = 2) +
    labs(
      x = "Time window",
      y = y_label,
      color = "Shock\nintensity",
      fill = "Shock\nintensity"
      #title = title_label
    ) +
    scale_color_manual(values = c(custom_palette[2], custom_palette[1])) + # Replace with your custom_palette if desired
    scale_fill_manual(values = c(custom_palette[2], custom_palette[1])) +  # Replace with your custom_palette if desired
    scale_x_continuous(breaks = 0:3, labels = c("BL", "1", "2", "3")) +
    theme_classic(base_size = 12) + #specify theme and font size
    theme(
      plot.title = element_text(hjust = 0.5, margin = margin(b = 6)),
      panel.spacing = unit(0.5, "lines"),
      strip.background = element_blank(),
      strip.text = element_text(face = "bold"),
      plot.margin = margin(0, 0, 0, 0, "cm"),
      legend.position = "right",
      legend.box.margin = margin(0, 0, 0, 0, "cm"),
      legend.margin = margin(0, 0, 0, 0, )
    )
  
  
  #show figure
  p_adhd_intens_time
  
  #save figure
  save_file_path = paste0(save_destination,"/", measure, "_", phase, "_adhd_intens_time.png")
  
  ggsave(save_file_path, p_adhd_intens_time, width = fig_width, height = fig_height, units = "in", dpi = 300, limitsize = FALSE)
  
  return(p_adhd_intens_time)
}
```

## plot_intens_time_recipient

```{r}
#-------- plot psychophys responses split by shock intensity, shock recipient, and timepoint (3-way)

funcs$plot_intens_time_recipient <- function(lmm_model,
                                             save_destination,
                                             fig_width,
                                             fig_height,
                                             phase,
                                             measure, 
                                             shockIntensityConds
){
  
  
  #define y axis label
  if (measure == "HR"){
    y_label = "Heart rate (bpm)"
  } else if (measure == "SCL"){ 
    y_label = "SCL (µS)"
  } else if (measure == "fisys"){ 
    y_label = "Systolic blood pressure (mmHg)"
  } else if (measure == "fidia"){ 
    y_label = "Diastolic blood pressure (mmHg)"
  } else{
    print("ERROR: measure needs to be one of HR, SCL, fisys, or fidia")
    break
  }
  

  #Set colours for shock intensity based on shockIntensityConds
  if ("Low" %in% shockIntensityConds){
    shockIntensityColours <- c(custom_palette[2], custom_palette[1])
  }else if ("Safe" %in% shockIntensityConds){
    shockIntensityColours <- c(custom_palette[7], custom_palette[1])
  }  

  #define figure title
  title_label = paste0("Model-predicted ", measure, 
                       " during the ", phase, 
                       " phase,\nsplit by Shock Intensity, shock recipient, and Time Window")
  
  
  # Emmeans three way interaction
  emm_intens_X_time_X_recipient <- emmeans(lmm_model, 
    ~ shockIntensity * time * shockRecipient
  )
  
  # Calculate interaction contrasts for the 3-way interaction
  int_contrasts <- contrast(
    emm_intens_X_time_X_recipient, 
    interaction = c("pairwise", "pairwise", "pairwise")
  )
  # Get summary with test statistics
  test_results <- summary(int_contrasts, infer = c(TRUE, TRUE))
  
  
  #
  contrast(emm_intens_X_time_X_recipient, interaction = "pairwise") # Get interaction contrasts (pairwise comparisons between combinations)
  
  # Convert to dataframe and factorize
  emm_df_intens_X_time_X_recipient <- as.data.frame(emm_intens_X_time_X_recipient) %>%
    mutate(
      shockIntensity = factor(shockIntensity, 
                              levels = c(0, 1), 
                              labels = shockIntensityConds),
      shockRecipient = factor(shockRecipient,  # Assuming numeric coding
                              levels = c(0, 1), 
                              labels = c("Other", "Self")),  # Update labels as needed
      time = as.numeric(as.character(time)) #ensure numeric
    )
  
  # Plot with facet wrap
  p_intes_time_recipient <- ggplot(emm_df_intens_X_time_X_recipient, 
                                   aes(x = time, y = emmean, 
                                       color = shockIntensity, 
                                       fill = shockIntensity, 
                                       group = shockIntensity)) +
    # If plotting SE then use the following
    # geom_errorbar(aes(ymin = emmean - SE, ymax = emmean + SE),
    #               width = 0.1, position = position_dodge(width = 0.2)) +
    
    #If plotting CI then use the following
    # geom_errorbar(aes(ymin = lower.CL , ymax = upper.CL),
    #               width = 0.1, position = position_dodge(width = 0.2)) +
    
    geom_ribbon(aes(ymin = lower.CL, ymax = upper.CL), alpha = 0.15, colour = NA) +
    
    geom_line(size = 1.2) +
    facet_wrap(~shockRecipient, ncol = 2) +  # Facet by recipient
    labs(
      y = y_label,
      x = "Time window",
      color = "Shock\nIntensity",
      fill = "Shock\nIntensity"
      #title = title_label
    ) +
    scale_color_manual(values = shockIntensityColours) +
    scale_fill_manual(values = shockIntensityColours) +
    scale_x_continuous(breaks = 0:3, labels = c("BL", "1", "2", "3")) +
    theme_classic(base_size = 12) + #specify theme and font size
    theme(
      plot.title = element_text(hjust = 0.5, margin = margin(b = 6)),
      panel.spacing = unit(0.5, "lines"),
      strip.background = element_blank(),
      strip.text = element_text(face = "bold"),
      plot.margin = margin(0, 0, 0, 0),
      legend.position = "right",
      legend.box.margin = margin(0, 0, 0, 0),
      legend.margin = margin(0, 0, 0, 0)
    )
  
  #show figure
  p_intes_time_recipient
  
  #define save file name based on shockIntensityConds
  if ("Low" %in% shockIntensityConds){
    save_file_path = paste0(save_destination,"/", measure, "_", phase, "_time_intes_recipient.png")
  }else if ("Safe" %in% shockIntensityConds){
    save_file_path = paste0(save_destination,"/", measure, "_", phase, "_time_intes_recipient_safe.png")
  }
  
  #save figure
  ggsave(save_file_path, p_intes_time_recipient, width = fig_width, height = fig_height, units = "in", dpi = 300, limitsize = FALSE)
  
  return(p_intes_time_recipient)
}
```


## plot_psychophys_adhd_intens_recip

```{r}
#----Plot psychophys measure, split by ADHD traits, shock intensity and recipient (3-way)

funcs$plot_psychophys_adhd_intens_recip <- function(lmm_model, 
                                                save_destination,
                                                fig_width,
                                                fig_height,
                                                measure, 
                                                phase){
  #define y axis label and limits
  if (measure == "hr"){
    y_label = "Heart rate (bpm)"
    #y_limits = c(25,70)
  } else if (measure == "scl"){ 
    y_label = "SCL (µS)" 
    #y_limits = c(0,100)
  } else if (measure == "fisys"){
    y_label = "Systolic blood pressure (mmHg)" 
    #y_limits = c(0,8)
  } else if (measure == "fidia"){
    y_label = "Diastolic blood pressure (mmHg)" 
    #y_limits = c(0,8)
  }
  
  # Generate predictions
  preds_rating_adhd_intens_recipient <- ggpredict(
    lmm_model,
    terms = c(
      "CAARS_T_index_centred", # sequence across CAARS
      "shockIntensity [0,1]",
      "shockRecipient [0,1]"
    ),
    bias_correction = TRUE #use bias correction for glmer models
  )
  
  # Label group for shockIntensity
  preds_rating_adhd_intens_recipient$group <- factor(
    preds_rating_adhd_intens_recipient$group, 
    levels = c("0", "1"),
    labels = c("Low", "High")
  )
  
  # Label facets for shockRecipient
  preds_rating_adhd_intens_recipient$facet <- factor(
    preds_rating_adhd_intens_recipient$facet, 
    levels = c("0", "1"),
    labels = c("Other", "Self")
  )
  
  # Plot
  p_arousal_adhd_intens_recip <- ggplot(preds_rating_adhd_intens_recipient, aes(x = x, y = predicted, color = group, fill = group)) +
    geom_line(size = 1.2) +
    geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = 0.15, colour = NA) +
    facet_wrap(~facet, ncol = 2) +
    labs(
      x = "CAARS-S:S Index (centred)",
      y = y_label,
      color = "Shock\nIntensity",
      fill = "Shock\nIntensity"
      #title = "CAARS Index × Shock Intensity x Shock Recipient"
    ) +
    scale_color_manual(values = c(custom_palette[2], custom_palette[1])) +
    scale_fill_manual(values = c(custom_palette[2], custom_palette[1])) +
    #coord_cartesian(ylim = y_limits) +
    theme_classic() +
    theme(
      plot.title = element_text(hjust = 0.5, margin = margin(b = 6)),
      panel.spacing = unit(0.5, "lines"),
      strip.background = element_blank(),
      strip.text = element_text(face = "bold"),
      plot.margin = margin(0, 0, 0, 0),
      legend.position = "right",
      legend.box.margin = margin(0, 0, 0, 0),
      legend.margin = margin(0, 0, 0, 0)
    )
  
  # Show figure
  p_arousal_adhd_intens_recip
  
  #save figure
    save_filepath = paste0(save_destination,"/", phase, "_", measure, "_adhd_X_intens_X_recipient.png")
  
  ggsave(save_filepath, p_arousal_adhd_intens_recip, width = fig_width, height = fig_height, units = "in", dpi = 300, limitsize = FALSE)
}
```

## plot_intens_recipient_two_way

```{r}
#-----Plot psychophys measure, split by intensity and recipient (2-way)

funcs$plot_intens_recipient <- function(lmm_model,
                                             save_destination,
                                             fig_width,
                                             fig_height,
                                             phase,
                                             measure
){
  
  
  #define y axis label
  if (measure == "HR"){
    y_label = "Heart rate (bpm)"
  } else if (measure == "SCL"){ 
    y_label = "SCL (µS)"
  } else if (measure == "fisys"){ 
    y_label = "Systolic blood pressure (mmHg)"
  } else if (measure == "fidia"){ 
    y_label = "Diastolic blood pressure (mmHg)"
  } else{
    print("ERROR: measure needs to be one of HR, SCL, fisys, or fidia")
    break
  }
  
  #define figure title
  title_label = paste0("Model-predicted ", measure, 
                       " during the ", phase, 
                       " phase,\nsplit by Shock Intensity and shock recipient")
  
  
  # Emmeans two way interaction
  emm_intens_X_recipient <- emmeans(
    lmm_model, 
    ~ shockIntensity * shockRecipient
  )
  
  
  # Convert to dataframe and factorize
  emm_df_intens_X_recipient <- as.data.frame(emm_intens_X_recipient) %>%
    mutate(
      shockIntensity = factor(shockIntensity, 
                              levels = c(0, 1), 
                              labels = c("Low", "High")),
      shockRecipient = factor(shockRecipient,  # Assuming numeric coding
                              levels = c(0, 1), 
                              labels = c("Other", "Self"))  # Update labels as needed
    )
  
  # Plot with facet wrap
  p_intes_recipient <- ggplot(emm_df_intens_X_recipient, 
                                   aes(x = shockRecipient, y = emmean, 
                                       color = shockIntensity, 
                                       fill = shockIntensity, 
                                       group = shockIntensity)) +
        geom_errorbar(aes(ymin = lower.CL , ymax = upper.CL),
                  width = 0.1, position = position_dodge(width = 0.2)) +
    geom_line(size = 1.2, 
              position = position_dodge(width = 0.2)) +
    labs(
      y = y_label,
      x = "Shock recipient",
      color = "Shock\nIntensity",
      fill = "Shock\nIntensity"
      #title = title_label
    ) +
    scale_color_manual(values = c(custom_palette[2], custom_palette[1])) +
    scale_fill_manual(values = c(custom_palette[2], custom_palette[1])) +
    theme_classic(base_size = 12) + #specify theme and font size
    theme(
      plot.title = element_text(hjust = 0.5, margin = margin(b = 6)),
      panel.spacing = unit(0.5, "lines"),
      strip.background = element_blank(),
      strip.text = element_text(face = "bold"),
      plot.margin = margin(0, 0, 0, 0),
      legend.position = "right",
      legend.box.margin = margin(0, 0, 0, 0),
      legend.margin = margin(0, 0, 0, 0)
    )
  
  #show figure
  p_intes_recipient
  
  #save figure
  save_file_path = paste0(save_destination,"/", measure, "_", phase, "_intes_recipient.png")
  ggsave(save_file_path, p_intes_recipient, width = fig_width, height = fig_height, units = "in", dpi = 300, limitsize = FALSE)
  
  return(p_intes_recipient)
}

```

## plot_linear_hr

```{r}
#------- Plot linear HR relationship
funcs$plot_linear_hr <- function(pred_data, 
                                     x_label,
                                     y_label,
                                     phase,
                                     ylims = "default"){
p_hr_linear <- ggplot(pred_data, aes(x = x, y = predicted)) +
  geom_line(size = 1.2, colour = custom_palette[5]) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), 
              fill = custom_palette[5], 
              alpha = 0.15, 
              colour = NA) +
  #coord_cartesi\an(ylim = y_limits) +
  theme_classic() +
  labs(
    x = x_label,
    y = y_label,
    #title = ""
  ) +
  theme(
    text = element_text(size = 14),
    plot.title = element_text(hjust = 0.5, margin = margin(b = 6)),
    panel.spacing = unit(0.5, "lines"),
    strip.background = element_blank(),
    strip.text = element_text(face = "bold"),
    plot.margin = margin(0, 0, 0, 0),
    legend.position = "right",
    legend.box.margin = margin(0, 0, 0, 0),
    legend.margin = margin(0, 0, 0, 0)
  ) 

if (ylims[1] != "default"){
  p_hr_linear <- p_hr_linear + coord_cartesian(ylim = ylims)
}


#save figure
save_filepath = paste0(figures_folder,"/", phase, "_", "hr", "_adhd.png")

ggsave(save_filepath, p_hr_linear, 
       height = 2.6, 
       width = 2.6, 
       units = "in", 
       dpi = 300, 
       limitsize = FALSE)

#return fig
return(p_hr_linear)
}
```


## plot_intens_time_two_way

Plot psychophys data split by intensity x time (2-way)

```{r}

funcs$plot_intens_time_two_way <- function(lmm_model,
                                   save_destination,
                                   fig_width,
                                   fig_height,
                                   phase,
                                   measure) {
  
  # Define y axis label
  if (measure == "HR") {
    y_label <- "Heart rate (bpm)"
  } else if (measure == "SCL") { 
    y_label <- "SCL (µS)"
  } else if (measure == "fisys") { 
    y_label <- "Systolic blood pressure (mmHg)"
  } else if (measure == "fidia") { 
    y_label <- "Diastolic blood pressure (mmHg)"
  } else {
    stop("ERROR: measure needs to be one of HR, SCL, fisys, or fidia")
  }
  
  # Get emmeans for time × shockIntensity
  emm_intens_X_time <- emmeans(
    lmm_model, 
    ~ shockIntensity * time
  )
  
  # Convert to dataframe
  emm_df <- as.data.frame(emm_intens_X_time) %>%
    mutate(
      shockIntensity = factor(shockIntensity, 
                              levels = c(0, 1), 
                              labels = c("Low", "High")),
      time = as.numeric(as.character(time))  # Ensure numeric x-axis
    )
  
  # Create plot
  p_intens_time <- ggplot(emm_df, aes(x = time, y = emmean, 
                          color = shockIntensity, 
                          fill = shockIntensity)) +
    # If plotting SE then use the following
    # geom_errorbar(aes(ymin = emmean - SE, ymax = emmean + SE),
    #               width = 0.1, position = position_dodge(width = 0.2)) +
    
    #If plotting CI then use the following
    geom_errorbar(aes(ymin = lower.CL , ymax = upper.CL),
                  width = 0.1, position = position_dodge(width = 0.2)) +
    geom_line(size = 1.2) +
    labs(
      y = y_label,
      x = "Time window",
      color = "Shock\nIntensity",
      fill = "Shock\nIntensity"
    ) +
    scale_color_manual(values = c(custom_palette[2], custom_palette[1])) +
    scale_fill_manual(values = c(custom_palette[2], custom_palette[1])) +
    scale_x_continuous(breaks = 0:3, labels = c("BL", "1", "2", "3")) +
    theme_classic(base_size = 12) +
    theme(
      legend.position = "right",
      plot.margin = margin(0, 0, 0, 0, "cm")
    )
  
  # Save figure
  save_path <- paste0(save_destination, "/", measure, "_", phase, "_time_intensity.png")
  ggsave(save_path, p_intens_time, width = fig_width, height = fig_height, 
         units = "in", dpi = 300)
  
  return(p_intens_time)
}

```

##plot_recipient_time_two_way

Plot psychophys data split by recipient x time

```{r}

funcs$plot_recipient_time_two_way <- function(lmm_model,
                                   save_destination,
                                   fig_width,
                                   fig_height,
                                   phase,
                                   measure) {
  
  # Define y axis label
  if (measure == "HR") {
    y_label <- "Heart rate (bpm)"
  } else if (measure == "SCL") { 
    y_label <- "SCL (µS)"
  } else if (measure == "fisys") { 
    y_label <- "Systolic blood pressure (mmHg)"
  } else if (measure == "fidia") { 
    y_label <- "Diastolic blood pressure (mmHg)"
  } else {
    stop("ERROR: measure needs to be one of HR, SCL, fisys, or fidia")
  }
  
  # Get emmeans for time × shockIntensity
  emm_recipient_X_time <- emmeans(
    lmm_model, 
    ~ shockRecipient * time
  )
  
  # Convert to dataframe
  emm_df <- as.data.frame(emm_recipient_X_time) %>%
    mutate(
      shockRecipient = factor(shockRecipient, 
                              levels = c(0, 1), 
                              labels = c("Other", "Self")),
      time = as.numeric(as.character(time))  # Ensure numeric x-axis
    )
  
  # Create plot
  p_recipient_time <- ggplot(emm_df, aes(x = time, y = emmean, 
                          color = shockRecipient, 
                          fill = shockRecipient)) +
    # If plotting SE then use the following
    # geom_errorbar(aes(ymin = emmean - SE, ymax = emmean + SE),
    #               width = 0.1, position = position_dodge(width = 0.2)) +
    
    #If plotting CI then use the following
    geom_errorbar(aes(ymin = lower.CL , ymax = upper.CL),
                  width = 0.1, position = position_dodge(width = 0.2)) +
    geom_line(size = 1.2) +
    labs(
      y = y_label,
      x = "Time window",
      color = "Shock\nRecipient",
      fill = "Shock\nRecipient"
    ) +
    scale_color_manual(values = c(custom_palette[3], custom_palette[4])) +
    scale_fill_manual(values = c(custom_palette[3], custom_palette[4])) +
    scale_x_continuous(breaks = 0:3, labels = c("BL", "1", "2", "3")) +
    theme_classic(base_size = 12) +
    theme(
      legend.position = "right",
      plot.margin = margin(0, 0, 0, 0, "cm")
    )
  
  # Save figure
  save_path <- paste0(save_destination, "/", measure, "_", phase, "_time_recipient.png")
  ggsave(save_path, p_recipient_time, width = fig_width, height = fig_height, 
         units = "in", dpi = 300)
  
  return(p_recipient_time)
}

```

##plot_adhd_intens_time_recipient

Plot 4-way interaction

```{r}

funcs$plot_adhd_intens_time_recipient <- function(pred_vals_adhd_intens_time,
                                        save_destination,
                                        fig_width,
                                        fig_height,
                                        phase,
                                        measure,
                                        shockIntensityConds
){
  #define y axis label
  if (measure == "HR"){
    y_label = "Heart rate (bpm)"
  } else if (measure == "SCL"){ 
    y_label = "SCL (µS)"
  } else if (measure == "fisys"){ 
    y_label = "Systolic blood pressure (mmHg)"
  } else if (measure == "fidia"){ 
    y_label = "Diastolic blood pressure (mmHg)"
  } else{
    print("ERROR: measure needs to be one of HR, SCL, fisys, or fidia")
    break
  }
  
  #Set colours for shock intensity based on shockIntensityConds
  if ("Low" %in% shockIntensityConds){
    shockIntensityColours <- c(custom_palette[2], custom_palette[1])
  }else if ("Safe" %in% shockIntensityConds){
    shockIntensityColours <- c(custom_palette[7], custom_palette[1])
  }
  
  #define figure title
  title_label = paste0("Model-predicted ", measure, 
                       " during the ", phase, 
                       " phase,\nsplit by ADHD traits, Shock Intensity, and Time Window")
  
  p_adhd_intens_time_recip <- ggplot(pred_vals_adhd_intens_time, aes(x = time, y = predicted, color = facet, fill = facet, group = facet)) +
    geom_line(size = 1.2) +
    geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = 0.15, color = NA) +
    facet_wrap(~ panel + group, nrow = 1) +
    labs(
      x = "Time window",
      y = y_label,
      color = "Shock\nintensity",
      fill = "Shock\nintensity"
      #title = title_label
    ) +
    scale_color_manual(values = shockIntensityColours) + # Replace with your custom_palette if desired
    scale_fill_manual(values = shockIntensityColours) +  # Replace with your custom_palette if desired
    scale_x_continuous(breaks = 0:3, labels = c("BL", "1", "2", "3")) +
    theme_classic(base_size = 12) + #specify theme and font size
    theme(
      plot.title = element_text(hjust = 0.5, margin = margin(b = 6)),
      panel.spacing = unit(0.5, "lines"),
      strip.background = element_blank(),
      strip.text = element_text(face = "bold"),
      plot.margin = margin(0, 0, 0, 0, "cm"),
      legend.position = "right",
      legend.box.margin = margin(0, 0, 0, 0, "cm"),
      legend.margin = margin(0, 0, 0, 0, )
    )
  
  
  #show figure
  p_adhd_intens_time_recip
  
  #define save file name based on shockIntensityConds
  if ("Low" %in% shockIntensityConds){
    save_file_path = paste0(save_destination,"/", measure, "_", phase, "_adhd_intens_time_recip.png")
  }else if ("Safe" %in% shockIntensityConds){
    save_file_path = paste0(save_destination,"/", measure, "_", phase, "_adhd_intens_time_recip_safe.png")
  }
  
  ggsave(save_file_path, p_adhd_intens_time_recip, width = fig_width, height = fig_height, units = "in", dpi = 300, limitsize = FALSE)
  
  return(p_adhd_intens_time_recip)
}


```


## refit_model_minus_outliers

Function for refitting model after excluding outliers

```{r}

funcs$refit_model_minus_outliers <- function(my_model){
  # 1. Simulate residuals for your fitted model
  sim_res <- simulateResiduals(fittedModel = my_model, n = 250)  # Replace 'my_model' with your glmmTMB model
  
  # 2. Identify outlier indices (outside simulation envelope)
  outlier_indices <- outliers(sim_res, return = "index")  # [2][3][5]
  
  # 3. If there are outliers, exclude them and refit the model
  if (length(outlier_indices) > 0) {
    # Get the original model data
    model_data <- model.frame(my_model)
    # Remove outlier rows
    clean_data <- model_data[-outlier_indices, ]
    # Refit the model with cleaned data
    print('Refitting model...')
    my_model_refit <- update(my_model, data = clean_data)
    cat("Model refit after excluding", length(outlier_indices), "outliers.\n")
    return(my_model_refit)
    
  } else {
    cat("No outliers identified by DHARMa.\n")
  }
  
}

```

## plot_rating_intens_recip

Plot intensity ratings, split by shock intensity and recipient

```{r}

funcs$plot_rating_intens_recip <- function(lmm_model, 
                                           save_destination,
                                           fig_width,
                                           fig_height,
                                           measure, 
                                           y_limits = "default", 
                                           shockIntensityConds){
  
  #define y axis label and limits
  if (measure == "arousal"){
    y_label = "Arousal rating"
    #y_limits = c(30,65)
  } else if (measure == "valence"){ 
    y_label = "Valence rating" 
    #y_limits = c(0,100)
  } else if (measure == "intensity"){
    y_label = "Emotional inensity rating" 
    #y_limits = c(0,8)
  } else if (measure == "SensIntens"){
    y_label = "Sensation inensity rating" 
    #y_limits = c(0,8)
  }
  
  #calculate emmeans for each level
  emm_rating_intens_recipient <- emmeans(lmm_model, ~ shockIntensity * shockRecipient,  type = "response")
  contrast(emm_rating_intens_recipient, interaction = "pairwise") # Get interaction contrasts (pairwise comparisons between combinations)
  emm_df_rating_intes_recipient <- as.data.frame(emm_rating_intens_recipient)
  
  # Convert both variables to factors with meaningful labels
  emm_df_rating_intes_recipient$shockIntensity <- factor(emm_df_rating_intes_recipient$shockIntensity, levels = c(0, 1), labels = shockIntensityConds)
  emm_df_rating_intes_recipient$shockRecipient <- factor(emm_df_rating_intes_recipient$shockRecipient, levels = c(0, 1), labels = c("Other", "Self"))
  
  
  #Set colours for shock intensity based on shockIntensityConds
  if ("Low" %in% shockIntensityConds){
    shockIntensityColours <- c(custom_palette[2], custom_palette[1])
  } else if ("Safe" %in% shockIntensityConds){
    shockIntensityColours <- c(custom_palette[7], custom_palette[1])
  }
  
  # Plot Interaction
  p_arousal_intens_recipient <- ggplot(emm_df_rating_intes_recipient, aes(x = shockRecipient, y = response*100,
                                                                           color = shockIntensity,
                                                                           shape = shockIntensity,
                                                                           group = shockIntensity)) +
    geom_point(size = 3, position = position_dodge(width = 0.2)) +
    geom_line(position = position_dodge(width = 0.2)) +
    
    # If plotting SE then use the following
    # geom_errorbar(aes(ymin = response*100 - SE*100, ymax = response*100 + SE*100),
    #               width = 0.1, position = position_dodge(width = 0.2)) +
    
    #If plotting CI then use the following
    geom_errorbar(aes(ymin = asymp.LCL*100 , ymax = asymp.UCL*100),
                  width = 0.1, position = position_dodge(width = 0.2)) +
    
    labs(
      y = y_label,
      x = "Shock Recipient",
      color = "Shock\nIntensity",
      shape = "Shock\nIntensity"
      #title = "Shock Intensity × Shock Recipient,\nresponse phase"
    ) +
    #add custom colours (swap order of first 2 to make high shock blue)
    scale_color_manual(values = shockIntensityColours) +
    theme_classic() +
    theme(
      plot.title = element_text(hjust = 0.5, margin = margin(b = 6)),
      panel.spacing = unit(0.5, "lines"),
      strip.background = element_blank(),
      strip.text = element_text(face = "bold"),
      plot.margin = margin(0, 0, 0, 0),
      legend.position = "right",
      legend.box.margin = margin(0, 0, 0, 0),
      legend.margin = margin(0, 0, 0, 0)
      
    )
  
  #Add y limits
  if (y_limits[1] != "default"){
    p_arousal_intens_recipient <- p_arousal_intens_recipient + coord_cartesian(ylim = y_limits)
  }
  
  #Show figure
  p_arousal_intens_recipient
  
  #define save file name based on shockIntensityConds
  if ("Low" %in% shockIntensityConds){
    save_filepath = paste0(save_destination,"/", measure, "_intes_X_recipient.png")
  }else if ("Safe" %in% shockIntensityConds){
    save_filepath = paste0(save_destination,"/", measure, "_intes_X_recipient_safe.png")
  }
  
  ggsave(save_filepath, p_arousal_intens_recipient, width = fig_width, height = fig_height, units = "in", dpi = 300, limitsize = FALSE)
  
  #Define values to return
  output = list()
  output$p = p_arousal_intens_recipient
  output$emm = emm_df_rating_intes_recipient
  
  return(output)
  
}

```

##plot_rating_adhd_intens_recip

Plot ratings, split by ADHD traits, shock intensity and recipient

```{r}

funcs$plot_rating_adhd_intens_recip <- function(lmm_model, 
                                                save_destination,
                                                fig_width,
                                                fig_height,
                                                measure, 
                                                shockIntensityConds){
  #define y axis label and limits
  if (measure == "arousal"){
    y_label = "Arousal rating"
    #y_limits = c(25,70)
    scaling_factor = 100 #define scaling factor for data (beta regression data must be x100)
  } else if (measure == "valence"){ 
    y_label = "Valence rating" 
    scaling_factor = 100 #define scaling factor for data
    #y_limits = c(0,100)
  } else if (measure == "emotion intensity"){
    y_label = "Emotional intensity rating" 
    scaling_factor = 1 #define scaling factor for data
    #y_limits = c(0,8)
  } else if (measure == "sensation intensity"){
    y_label = "Sensation intensity rating" 
    scaling_factor = 100 #define scaling factor for data
    #y_limits = c(0,8)
  } else{
    print("ERROR: measure must be arousal, valence, emotion intensity, or sensation intensity")
  }
  
  # Generate predictions
  preds_rating_adhd_intens_recipient <- ggpredict(
    lmm_model,
    terms = c(
      "CAARS_T_index_centred", # sequence across CAARS
      "shockIntensity [0,1]",
      "shockRecipient [0,1]"
    ),
    bias_correction = TRUE #use bias correction for glmer models
  )
  
  # Label group for shockIntensity
  preds_rating_adhd_intens_recipient$group <- factor(
    preds_rating_adhd_intens_recipient$group, 
    levels = c("0", "1"),
    labels = shockIntensityConds
  )
  
  # Label facets for shockRecipient
  preds_rating_adhd_intens_recipient$facet <- factor(
    preds_rating_adhd_intens_recipient$facet, 
    levels = c("0", "1"),
    labels = c("Other", "Self")
  )
  
  #Set colours for shock intensity based on shockIntensityConds
  if ("Low" %in% shockIntensityConds){
    shockIntensityColours <- c(custom_palette[2], custom_palette[1])
  }else if ("Safe" %in% shockIntensityConds){
    shockIntensityColours <- c(custom_palette[7], custom_palette[1])
  }
  
  # Plot
  p_arousal_adhd_intens_recip <- ggplot(preds_rating_adhd_intens_recipient, aes(x = x, y = predicted*scaling_factor, color = group, fill = group)) +
    geom_line(size = 1.2) +
    geom_ribbon(aes(ymin = conf.low*scaling_factor, ymax = conf.high*scaling_factor), alpha = 0.15, colour = NA) +
    facet_wrap(~facet, ncol = 2) +
    labs(
      x = "CAARS-S:S Index (centred)",
      y = y_label,
      color = "Shock\nIntensity",
      fill = "Shock\nIntensity"
      #title = "CAARS Index × Shock Intensity x Shock Recipient,\nresponse phase"
    ) +
    scale_color_manual(values = shockIntensityColours) +
    scale_fill_manual(values = shockIntensityColours) +
    #coord_cartesian(ylim = y_limits) +
    theme_classic() +
    theme(
      plot.title = element_text(hjust = 0.5, margin = margin(b = 6)),
      panel.spacing = unit(0.5, "lines"),
      strip.background = element_blank(),
      strip.text = element_text(face = "bold"),
      plot.margin = margin(0, 0, 0, 0),
      legend.position = "right",
      legend.box.margin = margin(0, 0, 0, 0),
      legend.margin = margin(0, 0, 0, 0)
    )
  
  # Show figure
  p_arousal_adhd_intens_recip
  
  #define save file name based on shockIntensityConds
  if ("Low" %in% shockIntensityConds){
    save_filepath = paste0(save_destination,"/", measure, "_adhd_X_intens_X_recipient.png")
  }else if ("Safe" %in% shockIntensityConds){
    save_filepath = paste0(save_destination,"/", measure, "_adhd_X_intens_X_recipient_safe.png")
  }
  
  ggsave(save_filepath, p_arousal_adhd_intens_recip, width = fig_width, height = fig_height, units = "in", dpi = 300, limitsize = FALSE)
}
```



##plot_timeseries_allps

Function for creating timeseries figure

```{r}

funcs$plot_timeseries_allps <- function(data, grandmean_data, title, y_label) {
  
  sample_freq <- 5 #define sampling freq
  duration_pre_phase <- 2 #define duration before start of phase as baseline
  
  duration_s = max(data$timepoint)/sample_freq # calculate duration in s
  
  ggplot() +
    geom_smooth(data = data, 
                aes(x = (timepoint/sample_freq) - duration_pre_phase, y = value, group = subject),
                color = "grey", alpha = 0.8, size = 0.8, se = FALSE, method = "loess") +
    geom_ribbon(data = grandmean_data,
                aes(x = (timepoint/sample_freq) - duration_pre_phase,
                    ymin = smoothed_mean_value - se,
                    ymax = smoothed_mean_value + se),
                fill = "#008384", alpha = 0.2) +
    geom_line(data = grandmean_data,
              aes(x = (timepoint/sample_freq) - duration_pre_phase, y = smoothed_mean_value),
              color = "#008384", size = 1.2) +
    geom_hline(yintercept = 0, linetype = "dashed", colour = "black") + # add horizontal line at y=0
    labs(
      title = title,
      x = "Time (s)",
      y = y_label
    ) +
    coord_cartesian(xlim = c(-duration_pre_phase, max(data$timepoint/sample_freq) - duration_pre_phase)) +
    scale_x_continuous(breaks = seq(-duration_pre_phase, max(data$timepoint/sample_freq) - duration_pre_phase, by = 1)) +
    theme_classic()
}

```

## plot_hr_timeseries_nconds

Plot heartrate timeseries for n conds

```{r}
funcs$plot_hr_timeseries_nconds <- function(data_subsets, phase_timeseries, fig_title, legend_labels) {
  # Check if data_subsets is a list
  if (!is.list(data_subsets) || is.data.frame(data_subsets)) {
    data_subsets <- list(data_subsets)
  }
  
  # Check if legend_labels is provided and has the same length as data_subsets
  if (missing(legend_labels) || length(legend_labels) != length(data_subsets)) {
    legend_labels <- paste("Condition", seq_along(data_subsets))
  }
  
  # Calculate mean timeseries for each subject and condition
  mean_timeseries_list <- lapply(data_subsets, function(data_subset) {
    mean_timeseries_dense <- data_subset %>%
      group_by(subjectID) %>%
      summarise(across(all_of(phase_timeseries),
                       ~ list(funcs$calc_mean_timeseries(map(., funcs$parse_hr_data))))) %>%
      filter(across(all_of(phase_timeseries),
                    ~ !is.null(.x[[1]])))
    
    # Expand timeseries
    max_length <- max(sapply(mean_timeseries_dense[[phase_timeseries]], length))
    mean_timeseries <- funcs$expand_timeseries(mean_timeseries_dense[[phase_timeseries]], max_length)
    
    # Convert to long format
    mean_timeseries_long <- funcs$process_timeseries(mean_timeseries)
    mean_timeseries_long_scaled <- funcs$process_timeseries(mean_timeseries, scaled = TRUE)
    
    # Calculate grandmean
    grandmean_timeseries <- funcs$calc_grandmean(mean_timeseries_long)
    grandmean_timeseries_scaled <- funcs$calc_grandmean(mean_timeseries_long_scaled)
    
    list(
      grandmean_timeseries = grandmean_timeseries,
      grandmean_timeseries_scaled = grandmean_timeseries_scaled
    )
  })
  
  # Combine all grandmean timeseries
  combined_grandmean <- bind_rows(lapply(seq_along(mean_timeseries_list), function(i) {
    mutate(mean_timeseries_list[[i]]$grandmean_timeseries, condition = legend_labels[i])
  }))
  
  combined_grandmean_scaled <- bind_rows(lapply(seq_along(mean_timeseries_list), function(i) {
    mutate(mean_timeseries_list[[i]]$grandmean_timeseries_scaled, 
           condition = legend_labels[i])
  }))
  
  # Create plots
  sample_freq <- 5 #define sampling freq
  duration_pre_phase <- 2 #define duration before start of phase as baseline
  
  duration_s = max(combined_grandmean$timepoint)/sample_freq # calculate duration in s
  
  # Raw data plot
  p_raw <- ggplot(combined_grandmean, aes(x = (timepoint/sample_freq) - duration_pre_phase, 
                                          y = smoothed_mean_value, 
                                          color = condition, 
                                          fill = condition)) +
    geom_ribbon(aes(ymin = smoothed_mean_value - se, 
                    ymax = smoothed_mean_value + se), 
                alpha = 0.2) +
    geom_line(size = 1.2) +
    scale_colour_manual(values = custom_palette) +
    scale_fill_manual(values = custom_palette) +
    labs(
      title = fig_title,
      x = "Time (s)",
      y = "Heart rate (bpm)"
    ) +
    coord_cartesian(xlim = c(-duration_pre_phase, max(combined_grandmean$timepoint/sample_freq) - duration_pre_phase)) +
    scale_x_continuous(breaks = seq(-duration_pre_phase, max(combined_grandmean$timepoint/sample_freq) - duration_pre_phase, by = 1)) +
    theme_classic() +
    theme(legend.title = element_blank())
  
  # Scaled data plot
  p_scaled <- ggplot(combined_grandmean_scaled, aes(x = (timepoint/sample_freq) - duration_pre_phase, 
                                                    y = smoothed_mean_value, 
                                                    color = condition, 
                                                    fill = condition)) +
    geom_ribbon(aes(ymin = smoothed_mean_value - se, 
                    ymax = smoothed_mean_value + se), 
                alpha = 0.2) +
    geom_line(size = 1.2) +
    geom_hline(yintercept = 0, linetype = "dashed", colour = "black") +
    scale_colour_manual(values = custom_palette) +
    scale_fill_manual(values = custom_palette) +
    labs(
      title = paste(fig_title, "(scaled)"),
      x = "Time (s)",
      y = "Heartrate (scaled)"
    ) +
    coord_cartesian(xlim = c(-duration_pre_phase, max(combined_grandmean_scaled$timepoint/sample_freq) - duration_pre_phase)) +
    scale_x_continuous(breaks = seq(-duration_pre_phase, max(combined_grandmean_scaled$timepoint/sample_freq) - duration_pre_phase, by = 1)) +
    theme_classic() +
    theme(legend.title = element_blank())
  
  #print(p_raw)
  #print(p_scaled)

} 

```




##plot_panel_discrete

Function for plotting ratings of discrete emotions, with one panel per emotion

```{r}

funcs$plot_panel_discrete <- function(subject_means, 
                                      rating_vars,
                                      rating_var_labels,
                                      save_destination, 
                                      phase,
                                      emotion_categories){
  
  # Convert to long and set factor levels to preserve order
  subject_means_long <- subject_means %>%
    pivot_longer(
      cols = all_of(rating_vars),
      names_to = "rating_type",
      values_to = "rating_value"
    ) %>%
    mutate(
      rating_type = factor(rating_type, levels = rating_vars, labels = rating_var_labels),
      shock_intensity = factor(shock_intensity, labels = c("Low", "High")),
      recipient = factor(recipient, levels = c("Other", "Self"))
    )
  
  # Create nested facet labels: first level = rating_type, second = recipient
  p_ratings <- ggplot(subject_means_long, aes(x = CAARS_T_index_centred, y = rating_value,
                                              colour = shock_intensity, fill = shock_intensity)) +
    geom_point(alpha = 0.4) +
    geom_smooth(method = "lm", se = TRUE, alpha = 0.2) +
    facet_nested(. ~ rating_type + recipient, nest_line = TRUE) +
    labs(
      x = "CAARS-S:S ADHD Index (centred)",
      y = "Rating",
      colour = "Shock Intensity",
      fill = "Shock Intensity"
      #title = "Subjective ratings by ADHD traits, shock intensity, and recipient"
    ) +
    scale_color_manual(values = c(custom_palette[2], custom_palette[1]), guide = "none") +
    scale_fill_manual(values = c(custom_palette[2], custom_palette[1]), guide = "none") +
    theme_classic() +
    theme(
      strip.text = element_text(face = "bold", size = 10),
      strip.background = element_blank(),
      plot.title = element_text(hjust = 0.5),
      legend.position = "bottom",
      panel.spacing = unit(1, "lines")
    )
  
  # Display plot
  p_ratings
  
  #save plot
  ggsave(paste0(save_destination,"/", "discrete_", phase, "_", emotion_categories, "_panel.png"), 
         p_ratings, width = 10, height = 2.72, units = "in", dpi = 300)
  
}

```

## plot_single_panel_discrete_ADHD_X_recipient

Plot single planel of discrete emotion ratings for ADHD x recipient

```{r}

funcs$plot_single_panel_discrete_ADHD_X_recipient <- function(data, y_var, title, show_y_label = FALSE) {
  ggplot(data, aes(x = CAARS_T_index_centred, 
                   y = .data[[y_var]], 
                   color = factor(recipient),
                   fill = factor(recipient))) +
    geom_smooth(method = "lm", formula = y ~ x, 
                size = 1.2, alpha = 0.15) +
    labs(
      x = "CAARS-S:S Index (centred)",
      y = if(show_y_label) "Mean Rating (±95% CI)" else " ",
      title = title
    ) +
    scale_color_manual(values = c(custom_palette[3], custom_palette[4]),
                       guide = "none") +
    scale_fill_manual(values = c(custom_palette[3], custom_palette[4]),
                      guide = "none") +
    scale_y_continuous(limits = c(0, 100),
                       breaks = seq(0, 100, 20)) +
    theme_classic() +
    theme(
      legend.position = "right",
      plot.title = element_text(hjust = 0.5, size = 12),
      panel.spacing = unit(1, "lines"),
      strip.background = element_blank(),
      strip.text = element_text(face = "bold", size = 10),
      axis.title.x = element_blank(),
      axis.text.x = element_text(angle = 45, hjust = 1)
    )
}
```



# Define useful variables

## Filepaths

```{r}
figures_folder <- "F:/ADHD emotion/Empathy study/Analysis/Shocks Figures"
```

## Lists to store data and models

```{r}
corrs <- list()
sems <- list()
alphas <- list()
means <- list()
lms <- list()
lmms <- list()
formulae <- list()
manovas <- list()
```

## Figure properties

```{r}
# Define custom colour palette
custom_palette <- c("navyblue", "mediumseagreen", "darkorange", "violet", "deeppink", "royalblue", "goldenrod",  "lemonchiffon")
```


## Settings

```{r}
#set pbkr test limit for emmeans to allow estimation of df
emm_options(pbkrtest.limit = 25076)
emm_options(lmerTest.limit = 50000)
```


# -------------------------------------------

# Model assumptions

# -------------------------------------------


Assumptions of linear models taken from https://doi.org/10.1111/ceo.12358 

Assumptions of logistic regression taken from https://pubmed.ncbi.nlm.nih.gov/21996075/

Assumptions of linear mixed effects models taken from https://doi.org/10.1111/2041-210X.13434

1) Linear relationship between continuous predictors and DV (only applies to continuous predictors)
For logistic regression models, the predictor should be linearly related to log odds of outcome.
Use easystats model_checks<- check_model(model)
Then plot(model_checks$NCV$x, model_checks$NCV$y)
> This will give you linearity of overall model
>If violated try adding polynomial terms to your model

OR Simulate residuals using DHARMa simulationOutput = simulateResiduals(model).
Then plot residuals vs predictor using DHARMa function  plotResiduals(simulationOutput, testData$predictorVariable, quantreg = T)
> This will give you linearity of specific predictor variable and outcome. Note for over 1000 observations, 
dharma does not plot each data point, but will plot a smoothed graph

> Note for logistic regression, the DHARMa approach is better 

2) All variables need to be multivariate normal (residuals of the model need to be normally distributed)
>Does not apply to logistic regression
>On easystats Q-Q plot, if all observations are within the shaded error bars then residuals are approximately normal
>If violated, try transforming the data or using robust SEs

Simulate residuals using DHARMa simulationOutput = simulateResiduals(model) then plot using plot(simulationOutput)
You can formally test for over-/under-dispersion using testDispersion(simulationOutput)

Or easystats normality_checks <- check_normality(model) then plot(normality_checks, type = "qq")

Or manual method:
residuals <- residuals(model, type = "response") #get resids
fitted <- model$fitted.values #get fitted values
plot(fitted, residuals) # scatter plot of residuals versus fitted values
abline(h = 0, col = "red", lty = 2)  # Add a reference line

3) Little/no multicollinearity (independent variables should not be correlated)
use easystats function check_collinearity(model)
Violation of multicollinearity must be severe to be a problem in linear mixed effects models https://doi.org/10.1111/2041-210X.13434
> If violated try mean-centring variables. If still and issue try removing some of the highly correlated variables or combining model variables e.g. summing them. If this fails try LASSO or ridge regression

4) Homoscedasticity (homogeneity of variance) 
>Does not apply to logistic regression models

check_homogeneity(model) #for categorical predictors only (Bartlett test)
check_heteroscedasticity(model) #for any predictor (Breusch-Pagan test) 
OR DHARMa plot(simulationOutput)

>Violation of the homoscedasticity assumption must be quite severe in order to present a major problem given the robust nature of OLS regression. If violated, use robust SEs for linear model. However it is very hard to fit robust SEs 
to mixed effects models so use bootstrapped CIs instead.

5) No influential outliers
Default Cook's distance threshold in easystats is the median point of the quantile distribution (Bollen, K. A., and Jackman, R. W. (1985). Regression diagnostics: An expository treatment of outliers and influential cases. Sociological Methods and Research, 13(4), 510-542.)
Use easystats check_outliers(model, method = "cook")
> If violated, remove outliers e.g. via imputation or deletion if there is a good reason to do so. Otherwise use robust regression.

6) Posterior predictive checks
You want to check that your frequency of predicted values is approximately the same as your actual frequency of
values
For linear models, use easystats check_predictions(model)
> You cannot use easystats check_predictions(model) for binary logistic mixed effects  regression models. 
> If violated, try different type of model e.g. beta regression

Instead, use DHARMa to check whether there are as many ones as expected (2 sided test to test for fewer + greater number of 1s at the same time)
first define function for counting numbers countNum <- function(x) sum(x == 1)
Then call testGeneric(simulationOutput, summary = countNum(1), alternative = "two.sided")

If check_predictions(model) doesn't work for a linear dependent variable, you can do a
decent posterior predictive check using testDispersion(simulationOutput) from DHARMa. This tells
you whether your model is overfitting or underitting different values

Mixed effects models also have the following assumptions:

7) No autocorrelation (residuals are independent)
Do not need to worry about this because we have modelled dependency with random intercepts

8) Normality of random effects
Models with random effects also have the assumption that the random effects should be normally distributed.
Use easystats re_normality_checks <- check_normality(model, effects = "random")
plot(re_normality_checks)


Linear Mixed Models are relatively robust to violations of most assumptions

Shielzeth et al. 2020 conclusions:

> Assumption of normally-distributed residuals
- violation results in little bias in fixed effects
  o	For cases of non-normal residuals, transforming DV often does not help

> Heteroskedasticity 
– violation results in little bias in fixed effects

> For violations of distributional assumption (non-normal residuals or heteroskedasticity) 
– Sandwich or Kenwood-Roger estimators provide robust estimates for fixed effects and perform well but may not be necessary because Shielzeth et al. found the ordinary estimation procedures performed sufficiently well. For marginally significant/non-significant effects it may be worth using robust methods.

> Collinearity
– Weak and moderate (r=.3 and .5) collinearity have little effect on fixed effects estimates, Strong collinearity (r=.8) may bias fixed effects estimates for the collinear variables (but not other variables)

> Normality of random effects
- Violation results in less precise but unbiased random effects, with no impact on fixed effects.
  o If faced with omitting nested random effect, you should omit the higher level effect, leaving the lower one.

> Outliers
– Shielzeth 2020 does not comment on outliers. Simple approach is to fit model without outliers and report any differences.


# Data import

# -------------------------------------------

# Import

```{r}

#----Import preprocessed empathy questionnaire data
questionnairesRescoredFolder <- 'F:/ADHD emotion/Empathy study/Participant data/Questionnaire data/Questionnaires preprocessed'
preproc_questionnaires_file <- list.files(questionnairesRescoredFolder, pattern = ".csv", full.names = TRUE)
dQs <- as_tibble(read.csv(preproc_questionnaires_file)) #questionnaire data

#----import empathy task data
preprocTaskDataFolder <- 'F:/ADHD emotion/Empathy study/Participant data/Preprocessed task data/Empathy task' #preprocessed task data
preproc_empathy_task_file <- list.files(preprocTaskDataFolder, pattern = ".csv", full.names = TRUE)
df_all_trials_all_subjs <- as_tibble(read.csv(preproc_empathy_task_file)) #all trials all participants

#Make subjectIDs upper case
df_all_trials_all_subjs$subjectID = toupper(df_all_trials_all_subjs$subjectID)
dQs$ID = toupper(dQs$ID)


```

#Link questionnaire data 

## Empathy task data

```{r}

#get list of variables in dQs
qVars <- names(dQs)
varsToAdd <- qVars[!qVars %in% c("ID")] #delete StartDate and EndDate

subject_IDs_list = unique(df_all_trials_all_subjs$subjectID)

for (subjectID in subject_IDs_list){
  #find participant rows
  pRowsAllTrials = which(df_all_trials_all_subjs$subjectID == subjectID)
  pRowQs =  which(dQs$ID == subjectID)
  
  df_all_trials_all_subjs[pRowsAllTrials, varsToAdd] = dQs[pRowQs, varsToAdd]
}

```

# -------------------------------------------

# Data cleaning

# -------------------------------------------


# Recode/calculate variables

## Empathy Task
```{r}
#recode observerCond
df_all_trials_all_subjs$observerCond <- gsub("intensityhidden", "hidden", df_all_trials_all_subjs$observerCond)
df_all_trials_all_subjs$observerCond <- gsub("intensityvisible", "visible", df_all_trials_all_subjs$observerCond)

#Calculate another observerCond condition to specify what subject's condition was
df_all_trials_all_subjs$subjVisibilityCond <- df_all_trials_all_subjs$observerCond
df_all_trials_all_subjs[df_all_trials_all_subjs$shockRecipient == 1, 'subjVisibilityCond'] = "visible" #set subjVisibilityCond to visible for all self shock trials

#Calculate known shock value for the subject on each trial (i.e. set to 'hidden' when 'shockRepient' is other and 'intensityVisible' is hidden)
df_all_trials_all_subjs$knownShockIntensity <- df_all_trials_all_subjs$shockIntensity
df_all_trials_all_subjs[df_all_trials_all_subjs$subjVisibilityCond == "hidden", "knownShockIntensity" ] = "hidden"

#Calculate session ID
# Extract the first five characters from subjectID to create sessionID
df_all_trials_all_subjs$sessionID <- substr(df_all_trials_all_subjs$subjectID, 1, 5)

#Calculate how sensitive friend thinks participant is to pain
dSubjs <- df_all_trials_all_subjs %>%
  group_by(subjectID) %>%
  summarise(across(everything(), first), .groups = "drop")


dSubjs$pain_sensitivity_rated_by_friend <- NaN #predefine

dSubjs$pain_sensitivity_rated_by_friend[seq(1, nrow(dSubjs), by = 2)] <- #assign even row value to odd rows
  dSubjs$pain_sensitivity[seq(2, nrow(dSubjs), by = 2)]

dSubjs$pain_sensitivity_rated_by_friend[seq(2, nrow(dSubjs), by = 2)] <- #assign odd row values to even rows
  dSubjs$pain_sensitivity[seq(1, nrow(dSubjs), by = 2)]


#predefine
df_all_trials_all_subjs$pain_sensitivity_rated_by_friend = NaN

#add pain sensitivity rated by friend to df_all_trials_all_subjs
for (subjectID in subject_IDs_list){
  subjRowsAllTsAllPs <- df_all_trials_all_subjs$subjectID == subjectID
  subjRowsSubjs <- dSubjs$subjectID == subjectID

  df_all_trials_all_subjs[subjRowsAllTsAllPs, 'pain_sensitivity_rated_by_friend'] = dSubjs[subjRowsSubjs, 'pain_sensitivity_rated_by_friend']
}

#make sex + ethnicity a factor
df_all_trials_all_subjs$sex <- as.factor(df_all_trials_all_subjs$sex)
df_all_trials_all_subjs$ethnicity <- as.factor(df_all_trials_all_subjs$ethnicity)

# Calculate BMI
df_all_trials_all_subjs$BMI <- df_all_trials_all_subjs$weight / ((df_all_trials_all_subjs$height/ 100)^2)

#Specify levels of shockIntensity
df_all_trials_all_subjs$shockIntensity <- as.factor(df_all_trials_all_subjs$shockIntensity)
contrasts(df_all_trials_all_subjs$shockIntensity)
codes <- cbind( "high" = c(1, 0, 0),
                "safe" = c(0, 0, 1)) #define contrasts
contrasts(df_all_trials_all_subjs$shockIntensity) <- codes #recode contrasts for shockIntensity

#Specify shockRecipient as binary variable (self = 1, other =0)
df_all_trials_all_subjs$shockRecipient <- as.numeric(df_all_trials_all_subjs$shockRecipient == "self")

```

### Convert psychophys timeseries to numeric

Convert psychophys timeseries to numeric

```{r}

#------- Waiting phase
#Create numeric versions of timeseries data to numeric
#HR
df_all_trials_all_subjs$hr_series_waiting_numeric <- lapply(df_all_trials_all_subjs$hr_series_waiting, function(x) {
  as.numeric(strsplit(gsub("\\[|\\]", "", x), ",")[[1]])
})

#EDA
df_all_trials_all_subjs$scl_series_waiting_numeric <- lapply(df_all_trials_all_subjs$scl_series_waiting, function(x) {
  as.numeric(strsplit(gsub("\\[|\\]", "", x), ",")[[1]])
})

#FiSYS
df_all_trials_all_subjs$fisys_series_waiting_numeric <- lapply(df_all_trials_all_subjs$fisys_series_waiting, function(x) {
  as.numeric(strsplit(gsub("\\[|\\]", "", x), ",")[[1]])
})

#FiSYS
df_all_trials_all_subjs$fidia_series_waiting_numeric <- lapply(df_all_trials_all_subjs$fidia_series_waiting, function(x) {
  as.numeric(strsplit(gsub("\\[|\\]", "", x), ",")[[1]])
})

#------- Anticipation phase

#Create numeric versions of timeseries data to numeric
#HR
df_all_trials_all_subjs$hr_series_anticipation_numeric <- lapply(df_all_trials_all_subjs$hr_series_anticipation, function(x) {
  as.numeric(strsplit(gsub("\\[|\\]", "", x), ",")[[1]])
})

#EDA
df_all_trials_all_subjs$scl_series_anticipation_numeric <- lapply(df_all_trials_all_subjs$scl_series_anticipation, function(x) {
  as.numeric(strsplit(gsub("\\[|\\]", "", x), ",")[[1]])
})

#fiSYS
df_all_trials_all_subjs$fisys_series_anticipation_numeric <- lapply(df_all_trials_all_subjs$fisys_series_anticipation, function(x) {
  as.numeric(strsplit(gsub("\\[|\\]", "", x), ",")[[1]])
})

#fiDIA
df_all_trials_all_subjs$fidia_series_anticipation_numeric <- lapply(df_all_trials_all_subjs$fidia_series_anticipation, function(x) {
  as.numeric(strsplit(gsub("\\[|\\]", "", x), ",")[[1]])
})


#------- Response phase

#Create numeric versions of timeseries data to numeric
#HR
df_all_trials_all_subjs$hr_series_response_numeric <- lapply(df_all_trials_all_subjs$hr_series_response, function(x) {
  as.numeric(strsplit(gsub("\\[|\\]", "", x), ",")[[1]])
})

#EDA
df_all_trials_all_subjs$scl_series_response_numeric <- lapply(df_all_trials_all_subjs$scl_series_response, function(x) {
  as.numeric(strsplit(gsub("\\[|\\]", "", x), ",")[[1]])
})

#fiSYS
df_all_trials_all_subjs$fisys_series_response_numeric <- lapply(df_all_trials_all_subjs$fisys_series_response, function(x) {
  as.numeric(strsplit(gsub("\\[|\\]", "", x), ",")[[1]])
})

#fiDIA
df_all_trials_all_subjs$fidia_series_response_numeric <- lapply(df_all_trials_all_subjs$fidia_series_response, function(x) {
  as.numeric(strsplit(gsub("\\[|\\]", "", x), ",")[[1]])
})
```

### Calculate mean/SD failures per P

```{r}
#Calculate mean n faulty trials in Pain Task
n_faulty_shocks_per_p <- df_all_trials_all_subjs %>%
  group_by( subjectID) %>%
  summarise(
    n_faulty_shocks = sum(faultyShock==1),
  )

#Set trial-by-trial ratings on trials with faulty shock to NaN
faultyTrials = df_all_trials_all_subjs$faultyShock == 1
df_all_trials_all_subjs[faultyTrials, c("sensationLocation", "sensationCoordinates", "sensationCoordinatesPerc")] = ""
df_all_trials_all_subjs[faultyTrials, c("sensationIntensity", "ratingArousal", "ratingValence", "emotionIntensity")] = NA

#Set trial-by-trial hr responses for Response phase on trials with faulty shock to NaN
df_all_trials_all_subjs[faultyTrials, "hr_series_response"] = "[nan]"
df_all_trials_all_subjs[faultyTrials, "mean_hr_response"] = NA

#Set trial-by-trial EDA responses for Response phase on trials with faulty shock to NaN
df_all_trials_all_subjs[faultyTrials, "scl_series_response"] = "[nan]"
df_all_trials_all_subjs[faultyTrials, "mean_scl_response"] = NA
df_all_trials_all_subjs[faultyTrials, "scr_amplitude_sum_response"] = NA

#Set trial-by-trial b2 responses for Response phase on trials with faulty shock to NaN
df_all_trials_all_subjs[faultyTrials, "fisys_series_response"] = "[nan]"
df_all_trials_all_subjs[faultyTrials, "fidia_series_response"] = "[nan]"
df_all_trials_all_subjs[faultyTrials, "mean_fisys_response"] = NA
df_all_trials_all_subjs[faultyTrials, "mean_fidia_response"] = NA

#Add n faulty shocks to df_all_trials_all_subjs
for (subjectID in subject_IDs_list){
  subjRowsAllTsAllPs <- df_all_trials_all_subjs$subjectID == subjectID
  subjRowsFaulty <- n_faulty_shocks_per_p$subjectID == subjectID

  df_all_trials_all_subjs[subjRowsAllTsAllPs, 'n_faulty_shocks'] = n_faulty_shocks_per_p[subjRowsFaulty, 'n_faulty_shocks']
}

print(paste0('N faulty shocks in Pain Task range = ', min(n_faulty_shocks_per_p$n_faulty_shocks), ' to ', max(n_faulty_shocks_per_p$n_faulty_shocks)) )

#Calculate mean n missing ratings in Pain Task
dRatings <- subset(df_all_trials_all_subjs, 
                    ratingSubmitted == "yes")

n_missing_ratings_per_p <- dRatings %>%
  #Calculate n missing ratings per participant
  group_by( subjectID) %>%
  summarise(
    n_missing = sum(is.na(ratingArousal)),
  )

n_missing_ratings_summary <- n_missing_ratings_per_p %>%
  #calculate mean, sd, range n missing ratings across participants
  summarise(
    n_missing_mean = mean(n_missing),
    n_missing_sd = sd(n_missing),
    n_missing_min = min(n_missing),
    n_missing_max = max(n_missing),
  )

print(n_missing_ratings_summary)

#Calculate number of pariticipants with X faulty trials
n_ps_per_faulty_count <- df_all_trials_all_subjs %>%
  group_by(subjectID) %>%
  summarise(n_faulty = sum(faultyShock == 1)) %>%
  count(n_faulty)

```

### Define subjs with HR/EDA/B2B data

```{r}
#Define subjects with HR data
subjects_with_HR <- subject_IDs_list
subjects_with_HR <- subjects_with_HR[subjects_with_HR != "BG047C"] #Exclude BG047C (ventricular arrhythmia)

#Define subjects with EDA data
subjects_with_EDA <- subject_IDs_list
subjects_with_EDA <- subjects_with_EDA[subjects_with_EDA != "BG007C"] #Exclude BG007C (ususable data)

#Define subjects with b2b data
subjects_with_B2B <- subject_IDs_list[grepl("P", subject_IDs_list)] #Include Ps not Cs
subjects_with_B2B <- subjects_with_B2B[subjects_with_B2B != "BG001P"] #Exclude BG001p (unusable data)
subjects_with_B2B[subjects_with_B2B == "BG041P"] <- "BG041C" #Swap BG041P to BG041C
```


### Calculate mean/SD trials noisy psychophys

#### Noisy ECG

```{r}
#Calculate n Response Phases on non-faulty trials with noisy ECG data 
dNonFaultyShock <- subset(df_all_trials_all_subjs, 
                     faultyShock == 0)

n_missing_ECG_per_p <- dNonFaultyShock %>%
  #Calculate n missing ECG per participant
  group_by( subjectID) %>%
  summarise(
    n_missing_ECG_response= sum(hr_series_response == '[nan]'),
  )

#Remove BG047c with ventricular arrythmia
n_missing_ECG_per_p = n_missing_ECG_per_p[n_missing_ECG_per_p$subjectID != 'BG047C',]

n_missing_ECG_resp <- n_missing_ECG_per_p %>%
  #calculate mean, sd, range n missing ECG data in each phase across participants
  summarise(
    
    n_missing_response_mean = round(mean(n_missing_ECG_response),2),
    n_missing_response_sd = round(sd(n_missing_ECG_response),2),
    n_missing_response_max = round(max(n_missing_ECG_response),2),
  )

print('N missing on non-faulty trials')
print(t(n_missing_ECG_resp))

#---------
# Calculate across all trials

#Calculate n Waiting/Anticipation/Response Phases with noisy ECG data

n_missing_ECG_per_p <- df_all_trials_all_subjs %>%
  #Calculate n missing ECG per participant
  group_by( subjectID) %>%
  summarise(
    n_missing_ECG_waiting = sum(hr_series_waiting == '[nan]'),
    n_missing_ECG_anticipation = sum(hr_series_anticipation == '[nan]'),
    n_missing_ECG_response= sum(hr_series_response == '[nan]'),
  )

#Remove BG047c with ventricular arrythmia
n_missing_ECG_per_p = n_missing_ECG_per_p[n_missing_ECG_per_p$subjectID != 'BG047C',]

n_missing_ECG_phases <- n_missing_ECG_per_p %>%
  #calculate mean, sd, range n missing ECG data in each phase across participants
  summarise(
    n_missing_waiting_mean = round(mean(n_missing_ECG_waiting),2),
    n_missing_waiting_sd = round(sd(n_missing_ECG_waiting),2),
    n_missing_waiting_max = round(max(n_missing_ECG_waiting),2),
    
    n_missing_anticipation_mean = round(mean(n_missing_ECG_anticipation),2),
    n_missing_anticipation_sd = round(sd(n_missing_ECG_anticipation),2),
    n_missing_anticipation_max = round(max(n_missing_ECG_anticipation),2),
    
    n_missing_response_mean = round(mean(n_missing_ECG_response),2),
    n_missing_response_sd = round(sd(n_missing_ECG_response),2),
    n_missing_response_max = round(max(n_missing_ECG_response),2),
  )


print('N missing all trials')
print(t(n_missing_ECG_phases))

```

#### Noisy EDA

```{r}
#Calculate n Response Phases on non-faulty trials with noisy scl data 

n_missing_scl_per_p <- dNonFaultyShock %>%
  #Calculate n missing scl per participant
  group_by( subjectID) %>%
  summarise(
    n_missing_scl_response= sum(scl_series_response == '[nan]'),
  )

#Remove BG007C with unusable EDA
n_missing_scl_per_p = n_missing_scl_per_p[n_missing_scl_per_p$subjectID != 'BG007C',]

n_missing_scl_resp <- n_missing_scl_per_p %>%
  #calculate mean, sd, range n missing scl data in each phase across participants
  summarise(
    
    n_missing_response_mean = round(mean(n_missing_scl_response),2),
    n_missing_response_sd = round(sd(n_missing_scl_response),2),
    n_missing_response_max = round(max(n_missing_scl_response),2),
  )

print('N missing on non-faulty trials')
print(t(n_missing_scl_resp))

#---------
# Calculate across all trials

#Calculate n Waiting/Anticipation/Response Phases with noisy scl data

n_missing_scl_per_p <- df_all_trials_all_subjs %>%
  #Calculate n missing scl per participant
  group_by( subjectID) %>%
  summarise(
    n_missing_scl_waiting = sum(scl_series_waiting == '[nan]'),
    n_missing_scl_anticipation = sum(scl_series_anticipation == '[nan]'),
    n_missing_scl_response= sum(scl_series_response == '[nan]'),
  )

#Remove BG007C with unusable EDA
n_missing_scl_per_p = n_missing_scl_per_p[n_missing_scl_per_p$subjectID != 'BG007C',]

n_missing_scl_phases <- n_missing_scl_per_p %>%
  #calculate mean, sd, range n missing scl data in each phase across participants
  summarise(
    n_missing_waiting_mean = round(mean(n_missing_scl_waiting),2),
    n_missing_waiting_sd = round(sd(n_missing_scl_waiting),2),
    n_missing_waiting_max = round(max(n_missing_scl_waiting),2),
    
    n_missing_anticipation_mean = round(mean(n_missing_scl_anticipation),2),
    n_missing_anticipation_sd = round(sd(n_missing_scl_anticipation),2),
    n_missing_anticipation_max = round(max(n_missing_scl_anticipation),2),
    
    n_missing_response_mean = round(mean(n_missing_scl_response),2),
    n_missing_response_sd = round(sd(n_missing_scl_response),2),
    n_missing_response_max = round(max(n_missing_scl_response),2),
  )


print('N missing all trials')
print(t(n_missing_scl_phases))

```

#### Noisy B2B

```{r}

#Calculate n Response Phases on non-faulty trials with noisy fisys data 

#Get B2B data for included subjects
dB2Bnonfaulty <- subset(df_all_trials_all_subjs, toupper(subjectID) %in% subjects_with_B2B & faultyShock == FALSE)

n_missing_fisys_per_p <- dB2Bnonfaulty %>%
  #Calculate n missing fisys per participant
  group_by( subjectID) %>%
  summarise(
    n_missing_fisys_response= sum(fisys_series_response == '[nan]'),
  )


n_missing_fisys_resp <- n_missing_fisys_per_p %>%
  #calculate mean, sd, range n missing fisys data in each phase across participants
  summarise(
    
    n_missing_response_mean = round(mean(n_missing_fisys_response),2),
    n_missing_response_sd = round(sd(n_missing_fisys_response),2),
    n_missing_response_max = round(max(n_missing_fisys_response),2),
  )

print('N missing on non-faulty trials')
print(t(n_missing_fisys_resp))

#---------
# Calculate across all trials

#Get B2B data for included subjects
dB2BAll <- subset(df_all_trials_all_subjs, toupper(subjectID) %in% subjects_with_B2B)

#Calculate n Waiting/Anticipation/Response Phases with noisy fisys data

n_missing_fisys_per_p <- dB2BAll %>%
  #Calculate n missing fisys per participant
  group_by( subjectID) %>%
  summarise(
    n_missing_fisys_waiting = sum(fisys_series_waiting == '[nan]'),
    n_missing_fisys_anticipation = sum(fisys_series_anticipation == '[nan]'),
    n_missing_fisys_response= sum(fisys_series_response == '[nan]'),
  )

n_missing_fisys_phases <- n_missing_fisys_per_p %>%
  #calculate mean, sd, range n missing fisys data in each phase across participants
  summarise(
    n_missing_waiting_mean = round(mean(n_missing_fisys_waiting),2),
    n_missing_waiting_sd = round(sd(n_missing_fisys_waiting),2),
    n_missing_waiting_max = round(max(n_missing_fisys_waiting),2),
    
    n_missing_anticipation_mean = round(mean(n_missing_fisys_anticipation),2),
    n_missing_anticipation_sd = round(sd(n_missing_fisys_anticipation),2),
    n_missing_anticipation_max = round(max(n_missing_fisys_anticipation),2),
    
    n_missing_response_mean = round(mean(n_missing_fisys_response),2),
    n_missing_response_sd = round(sd(n_missing_fisys_response),2),
    n_missing_response_max = round(max(n_missing_fisys_response),2),
  )


print('N missing all trials')
print(t(n_missing_fisys_phases))

```
## Tranform ratings for beta models

For use as DVs in beta models, transform trial-by-trial arousal and valence ratings

```{r}
#range(df_all_trials_all_subjs$ratingArousal, na.rm = TRUE)
#range(df_all_trials_all_subjs$ratingValence, na.rm = TRUE)

#Divide by 100
df_all_trials_all_subjs$ratingArousal_beta = df_all_trials_all_subjs$ratingArousal / 100
df_all_trials_all_subjs$ratingValence_beta = df_all_trials_all_subjs$ratingValence / 100

#Add 0.01 to the zeros
df_all_trials_all_subjs$ratingArousal_beta[df_all_trials_all_subjs$ratingArousal_beta == 0] <- 0.01
df_all_trials_all_subjs$ratingValence_beta[df_all_trials_all_subjs$ratingValence_beta == 0] <- 0.01

```


# Create demographics table

## Empathy task

```{r}
# Get unique subject IDs
subjects <- unique(df_all_trials_all_subjs$subjectID)

# Preallocate df_demographs with 0 rows and same columns as df_all_trials_all_subjs
df_demographs <- df_all_trials_all_subjs[0, ]

# Loop over subjects and fill in the first row for each
for (i_row in seq_along(subjects)) {
  subject <- subjects[i_row]
  subjectFirstRow <- which(df_all_trials_all_subjs$subjectID == subject)[1]
  df_demographs[i_row, ] <- df_all_trials_all_subjs[subjectFirstRow, ]
}

#Mean centre variables

vars_to_centre <- c("CASES_cog", "CASES_aff", "CASES_som", "ICU_callousness", "ICU_uncaring", "ICU_total")

df_demographs <- df_demographs %>%
  mutate(across(all_of(vars_to_centre), 
                ~ . - mean(., na.rm = TRUE), 
                .names = "{.col}_centred"))


# Calculate means and frequencies
dDemographs_summary <- df_demographs %>%
  summarise(n = n(),
            age_mean = mean(age),
            age_SD = sd(age), 
            BMI_mean = mean(BMI),
            BMI_SD = sd(BMI),
            adhd_diagnosis = sum(adhd_diagnosis == 1),
            drugs_yesno = sum(drugs_yesno == 1),
            meds_stimulants_but_not_today = sum(meds_stimulants_but_not_today == 1),
            completed_SRT = sum(completedSRT == 1),
            faulty_shocks_mean = mean(n_faulty_shocks),
            faulty_shocks_sd = sd(n_faulty_shocks)
            )

dDemographs_summary = t(dDemographs_summary)
colnames(dDemographs_summary) <- c("Value") 

# List of string variables to summarise
categorical_vars <- c("sex", "occupation", "ethnicity", "drugs_class", "meds_stimulants_but_not_today_drug")

# Initialise an empty data frame to store results
level_counts <- data.frame(Variable = character(), Level = character(), Count = numeric(), stringsAsFactors = FALSE)

# Loop through each categorical variable
for (var in categorical_vars) {
  # Count the frequency of each level
  temp_counts <- df_demographs %>%
    group_by(!!sym(var)) %>%
    summarise(Count = n(), .groups = "drop") %>%
    rename(Level = !!sym(var)) %>%
    mutate(Variable = var)
  
  # Append to the results
  level_counts <- bind_rows(level_counts, temp_counts)
}

#Delete NA rows
level_counts <- level_counts[!is.na(level_counts$Level),]

# Set 'Variable' as row names
rownames(level_counts) <- level_counts$Level
level_counts$Variable = NULL
level_counts$Level = NULL
colnames(level_counts) <- c("Value")

# Add the new data to dDemographs_summary as rows
dDemographs_summary <- rbind(dDemographs_summary, level_counts)
dDemographs_summary$Value = as.numeric(dDemographs_summary$Value )

#Save
write.csv(dDemographs_summary, file= paste0(figures_folder, "/", "dDemographs_summary.csv"))

#Mean-centre selected dDemograhs variables for use in lms

vars_to_centre = c("CAARS_T_index", "CAARS_T_inatt", "CAARS_T_hyp", "CAARS_T_imp", "age", "BMI")

df_demographs <- df_demographs %>%
  mutate(across(all_of(vars_to_centre),
                ~ . - mean(.),
                .names = "{.col}_centred"))

```




# Bin psychophys into time windows

Split Anticipation Phase and Response Phase into 3 time bins and calculate mean psychophys values within each bin.

## Anticipation Phase

```{r}
#IMPORTANT - define bin start and end times
duration_baseline <- 2 #reference baseline duration in s
timeseries_sample_freq <- 5 #editme - timeseries sample frequency

#Define bin start and ends in s
anticipation_bin_starts <- c(-2, 0, 3, 6) #times of bin starts in Anticipation Phase (times start at .2 to take first sample after end of previous phase with fs = 5Hz)
anticipation_bin_ends <- c(-0.2, 2.8, 5.8, 10) #times of bin ends in Anticipation Phase [N.B. final end bin time does not matter and is calculated below]

#calculate end sample in samples
anticipation_bin_starts_samples <- (anticipation_bin_starts + duration_baseline) * timeseries_sample_freq
anticipation_bin_ends_samples <- (anticipation_bin_ends + duration_baseline) * timeseries_sample_freq

#Calculate mean HR in each bin - anticipation phase
for (i_time_bin in 1:length(anticipation_bin_starts)){
  
  #create variables in df_all_trials_all_subjs
  df_all_trials_all_subjs[ , paste0("hr_anticipation_bin", i_time_bin-1)] = NaN
  df_all_trials_all_subjs[ , paste0("scl_anticipation_bin", i_time_bin-1)] = NaN
  df_all_trials_all_subjs[ , paste0("fisys_anticipation_bin", i_time_bin-1)] = NaN
  df_all_trials_all_subjs[ , paste0("fidia_anticipation_bin", i_time_bin-1)] = NaN
  
  #get bin start and end samples
  bin_start_sample = anticipation_bin_starts_samples[i_time_bin]
  bin_end_sample = anticipation_bin_ends_samples[i_time_bin]
  
  #For each trial
  for (i_row in 1:nrow(df_all_trials_all_subjs)){
    
    #if this is the final time bin then set bin_end_sample to exactly the length of hr_series_anticipation_numeric
    if (i_time_bin == length(anticipation_bin_starts) ){
      bin_end_sample =  length(df_all_trials_all_subjs$hr_series_anticipation_numeric[[i_row]])
    }
  
    #get hr and scl timeseries for this bin
    hr_series_anticipation_bin = df_all_trials_all_subjs$hr_series_anticipation_numeric[[i_row]][bin_start_sample : bin_end_sample]
    scl_series_anticipation_bin = df_all_trials_all_subjs$scl_series_anticipation_numeric[[i_row]][bin_start_sample : bin_end_sample]
    fisys_series_anticipation_bin = df_all_trials_all_subjs$fisys_series_anticipation_numeric[[i_row]][bin_start_sample : bin_end_sample]
    fidia_series_anticipation_bin = df_all_trials_all_subjs$fidia_series_anticipation_numeric[[i_row]][bin_start_sample : bin_end_sample]
    
    #calculate mean hr and SCL in this bin
    mean_hr_anticipation_bin = round(mean(hr_series_anticipation_bin), 2)
    mean_scl_anticipation_bin = round(mean(scl_series_anticipation_bin), 4)
    mean_fisys_anticipation_bin = round(mean(fisys_series_anticipation_bin), 2)
    mean_fidia_anticipation_bin = round(mean(fidia_series_anticipation_bin), 2)
    
    
    #add to df_all_trials_all_subjs
    df_all_trials_all_subjs[i_row, paste0("hr_anticipation_bin", i_time_bin-1)] = mean_hr_anticipation_bin
    df_all_trials_all_subjs[i_row, paste0("scl_anticipation_bin", i_time_bin-1)] = mean_scl_anticipation_bin
    df_all_trials_all_subjs[i_row, paste0("fisys_anticipation_bin", i_time_bin-1)] = mean_fisys_anticipation_bin
    df_all_trials_all_subjs[i_row, paste0("fidia_anticipation_bin", i_time_bin-1)] = mean_fidia_anticipation_bin
    
  }
  
}


#Check how many trials only have 40 samples for anticipation phase
samples_each_anticipation <- map_int(df_all_trials_all_subjs$hr_series_anticipation_numeric, length)
min_samples = 40 #minimum number of samples possible (6s + 2s baseline)
min_anticipation_phases = samples_each_anticipation > 1 & samples_each_anticipation <= min_samples #get trials where anticipation phase is <= minimum (and also >1 to avoid nans)
n_min_anticipation_duration = sum(min_anticipation_phases) 
print(paste0("Number of trials with no data for bin 3 of anticipation phase: ", n_min_anticipation_duration))

trials_min_anticipation <- df_all_trials_all_subjs[min_anticipation_phases, ]
#View(trials_min_anticipation)

```

## Response Phase

```{r}
#Define bin start and ends in s
response_bin_starts <- c(-2, 0.6, 2.6, 4.8) #times of bin starts in Response Phase [N.B. .4 and .6 not .5 to ensure whole sample numbers]
response_bin_ends <- c(-0.2, 2.4, 4.6, 6.6) #times of bin ends in Response Phase [N.B. .4 and .6 not .5 to ensure whole sample numbers; 
#N.B. final end bin time does not matter and is calculated below]

#calculate bin start and ends in samples
response_bin_starts_samples <- (response_bin_starts + duration_baseline) * timeseries_sample_freq
response_bin_ends_samples <- (response_bin_ends + duration_baseline) * timeseries_sample_freq

#Calculate mean HR in each bin - response phase
for (i_time_bin in 1:length(response_bin_starts)){
  
  #create variable in df_all_trials_all_subjs
  df_all_trials_all_subjs[ , paste0("hr_response_bin", i_time_bin-1)] = NaN
  df_all_trials_all_subjs[ , paste0("scl_response_bin", i_time_bin-1)] = NaN
  df_all_trials_all_subjs[ , paste0("fisys_response_bin", i_time_bin-1)] = NaN
  df_all_trials_all_subjs[ , paste0("fidia_response_bin", i_time_bin-1)] = NaN
  
  #get bin start and end samples
  bin_start_sample = response_bin_starts_samples[i_time_bin]
  bin_end_sample = response_bin_ends_samples[i_time_bin]
  
  #For each trial
  for (i_row in 1:nrow(df_all_trials_all_subjs)){
  
    #get hr and scl timeseries for this bin
    hr_series_response_bin = df_all_trials_all_subjs$hr_series_response_numeric[[i_row]][bin_start_sample : bin_end_sample]
    scl_series_response_bin = df_all_trials_all_subjs$scl_series_response_numeric[[i_row]][bin_start_sample : bin_end_sample]
    fisys_series_response_bin = df_all_trials_all_subjs$fisys_series_response_numeric[[i_row]][bin_start_sample : bin_end_sample]
    fidia_series_response_bin = df_all_trials_all_subjs$fidia_series_response_numeric[[i_row]][bin_start_sample : bin_end_sample]
    
    #calculate mean hr in this bin
    mean_hr_response_bin = round(mean(hr_series_response_bin), 2)
    mean_scl_response_bin = round(mean(scl_series_response_bin), 4)
    mean_fisys_response_bin = round(mean(fisys_series_response_bin), 2)
    mean_fidia_response_bin = round(mean(fidia_series_response_bin), 4)
    
    #add to df_all_trials_all_subjs
    df_all_trials_all_subjs[i_row, paste0("hr_response_bin", i_time_bin-1)] = mean_hr_response_bin
    df_all_trials_all_subjs[i_row, paste0("scl_response_bin", i_time_bin-1)] = mean_scl_response_bin
    df_all_trials_all_subjs[i_row, paste0("fisys_response_bin", i_time_bin-1)] = mean_fisys_response_bin
    df_all_trials_all_subjs[i_row, paste0("fidia_response_bin", i_time_bin-1)] = mean_fidia_response_bin
    
  }
  
}

```

# -------------------------------------------

# Explore Psychophys timeseries

# -------------------------------------------




##HR timeseries, mean per P

### Define fig parameters

```{r}
#ylims_hr_anticipation = c(-7.5, 0.8)
ylims_hr_anticipation = c(-7.5, 3.5)
#ylims_hr_response = c(-2.5, 3.5)
ylims_hr_response = ylims_hr_anticipation

```




### Self shock, high low safe

```{r}

# Calculate data subsets
self_high = subset(df_all_trials_all_subjs, shockRecipient == 1 & shockIntensity == 'high')
self_low = subset(df_all_trials_all_subjs, shockRecipient == 1 & shockIntensity == 'low')
self_safe = subset(df_all_trials_all_subjs, shockRecipient == 1 & shockIntensity == 'safe')

# Create a list of data subsets
data_subsets_self <- list(self_high, self_low, self_safe)

# Specify legend labels
legend_labels <- c("High", "Low", "Safe")

#-------Waiting phase

# Create plots
hr_ts_waiting_self = funcs$plot_hr_timeseries_nconds(
  data_subsets = data_subsets_self,
  phase_timeseries = "hr_series_waiting",
  fig_title = "Heartrate responses, waiting phase, self shock",
  legend_labels = legend_labels
)

#------- Anticipation phase

hr_ts_anticipation_self = funcs$plot_hr_timeseries_nconds(
  data_subsets = data_subsets_self,
  phase_timeseries = "hr_series_anticipation",
  fig_title = "Heartrate responses, anticipation phase, self shock",
  legend_labels = legend_labels
)

#expand y axis range to compare with other shock figure
hr_ts_anticipation_self <- hr_ts_anticipation_self +
  coord_cartesian(ylim = ylims_hr_anticipation) +
  labs(y = "HR Change (bpm)")
print(hr_ts_anticipation_self)

#------- Response phase

# Calculate data subsets
self_high_non_faulty = subset(df_all_trials_all_subjs, shockRecipient == 1 & shockIntensity == 'high' & faultyShock == 0)
self_low_non_faulty = subset(df_all_trials_all_subjs, shockRecipient == 1 & shockIntensity == 'low' & faultyShock == 0)
self_safe_non_faulty = subset(df_all_trials_all_subjs, shockRecipient == 1 & shockIntensity == 'safe' & faultyShock == 0)

# Create a list of data subsets
data_subsets_self_nonfaulty <- list(self_high_non_faulty, self_low_non_faulty, self_safe_non_faulty)

hr_ts_response_self = funcs$plot_hr_timeseries_nconds(
  data_subsets = data_subsets_self_nonfaulty,
  phase_timeseries = "hr_series_response",
  fig_title = "Heartrate responses, response phase, self shock",
  legend_labels = legend_labels
)

#expand y axis range to fit in epoch labels
hr_ts_response_self <- hr_ts_response_self +
  coord_cartesian(ylim = ylims_hr_response) + 
  labs(y = "HR Change (bpm)")
print(hr_ts_response_self)

```

###  Other shock, high low safe

```{r}
# Calculate data subsets
other_high = subset(df_all_trials_all_subjs, shockRecipient == 0 & shockIntensity == 'high')
other_low = subset(df_all_trials_all_subjs, shockRecipient == 0 & shockIntensity == 'low')
other_safe = subset(df_all_trials_all_subjs, shockRecipient == 0 & shockIntensity == 'safe')

# Create a list of data subsets
data_subsets_other <- list(other_high, other_low, other_safe)

# Specify legend labels
legend_labels <- c("High", "Low", "Safe")


#------Waiting phase

# Create plots
hr_ts_waiting_other = funcs$plot_hr_timeseries_nconds(
  data_subsets = data_subsets_other,
  phase_timeseries = "hr_series_waiting",
  fig_title = "Heartrate responses, waiting phase, other shock",
  legend_labels = legend_labels)

#------ Anticipation phase

hr_ts_anticipation_other = funcs$plot_hr_timeseries_nconds(
  data_subsets = data_subsets_other,
  phase_timeseries = "hr_series_anticipation",
  fig_title = "Heartrate responses, anticipation phase, other shock",
  legend_labels = legend_labels)

#expand y axis range to compare with other shock figure
hr_ts_anticipation_other <- hr_ts_anticipation_other +
  coord_cartesian(ylim = ylims_hr_anticipation) + 
  labs(y = "HR Change (bpm)")
print(hr_ts_anticipation_other)

#----- Response phase

# Calculate data subsets
other_high_non_faulty = subset(df_all_trials_all_subjs, shockRecipient == 0 & shockIntensity == 'high' & faultyShock == 0)
other_low_non_faulty = subset(df_all_trials_all_subjs, shockRecipient == 0 & shockIntensity == 'low' & faultyShock == 0)
other_safe_non_faulty = subset(df_all_trials_all_subjs, shockRecipient == 0 & shockIntensity == 'safe' & faultyShock == 0)

# Create a list of data subsets
data_subsets_other_nonfaulty <- list(other_high_non_faulty, other_low_non_faulty, other_safe_non_faulty)

hr_ts_response_other = funcs$plot_hr_timeseries_nconds(
  data_subsets = data_subsets_other_nonfaulty,
  phase_timeseries = "hr_series_response",
  fig_title = "Heartrate responses, response phase, other shock",
  legend_labels = legend_labels
)

#expand y axis range to fit in epoch labels + compare with other figure
hr_ts_response_other <- hr_ts_response_other +
  coord_cartesian(ylim = ylims_hr_response) + 
  labs(y = "HR Change (bpm)")
print(hr_ts_response_other)

```

## SCL timeseries, mean per P

### Define fig parameters

```{r}
ylims_scl_anticipation = c(-0.2, 0.35)
#ylims_scl_response = c(-0.06, 0.20)
ylims_scl_response = ylims_scl_anticipation

```



### Self shock, high low safe

```{r}

# Calculate data subsets
self_high = subset(df_all_trials_all_subjs, shockRecipient == 1 & shockIntensity == 'high')
self_low = subset(df_all_trials_all_subjs, shockRecipient == 1 & shockIntensity == 'low')
self_safe = subset(df_all_trials_all_subjs, shockRecipient == 1 & shockIntensity == 'safe')

# Create a list of data subsets
data_subsets_self <- list(self_high, self_low, self_safe)

# Specify legend labels
legend_labels <- c("High", "Low", "Safe")

#-------Waiting phase

# Create plots
scl_ts_waiting_self = funcs$plot_hr_timeseries_nconds(
  data_subsets = data_subsets_self,
  phase_timeseries = "scl_series_waiting",
  fig_title = "SCL change, waiting phase, self shock",
  legend_labels = legend_labels
)

#expand y axis range to compare with other shock figure
scl_ts_waiting_self <- scl_ts_waiting_self +
  ylab('Skin conductance (µS)') 
#print(scl_ts_waiting_self)

#------- Anticipation phase

scl_ts_anticipation_self = funcs$plot_hr_timeseries_nconds(
  data_subsets = data_subsets_self,
  phase_timeseries = "scl_series_anticipation",
  fig_title = "SCL change, anticipation phase, self shock",
  legend_labels = legend_labels
)

#expand y axis range to compare with other shock figure
scl_ts_anticipation_self <- scl_ts_anticipation_self +
  coord_cartesian(ylim = ylims_scl_anticipation) + 
  ylab('Skin conductance (µS)')

print(scl_ts_anticipation_self)

#------- Response phase

# Calculate data subsets
self_high_non_faulty = subset(df_all_trials_all_subjs, shockRecipient == 1 & shockIntensity == 'high' & faultyShock == 0)
self_low_non_faulty = subset(df_all_trials_all_subjs, shockRecipient == 1 & shockIntensity == 'low' & faultyShock == 0)
self_safe_non_faulty = subset(df_all_trials_all_subjs, shockRecipient == 1 & shockIntensity == 'safe' & faultyShock == 0)

# Create a list of data subsets
data_subsets_self_nonfaulty <- list(self_high_non_faulty, self_low_non_faulty, self_safe_non_faulty)

scl_ts_response_self = funcs$plot_hr_timeseries_nconds(
  data_subsets = data_subsets_self_nonfaulty,
  phase_timeseries = "scl_series_response",
  fig_title = "SCL change, response phase, self shock",
  legend_labels = legend_labels
)

#expand y axis range to fit in epoch labels
scl_ts_response_self <- scl_ts_response_self +
  coord_cartesian(ylim = ylims_scl_response) +
  ylab('Skin conductance (µS)')

print(scl_ts_response_self)

```

###  Other shock, high low safe

```{r}
# Calculate data subsets
other_high = subset(df_all_trials_all_subjs, shockRecipient == 0 & shockIntensity == 'high')
other_low = subset(df_all_trials_all_subjs, shockRecipient == 0 & shockIntensity == 'low')
other_safe = subset(df_all_trials_all_subjs, shockRecipient == 0 & shockIntensity == 'safe')

# Create a list of data subsets
data_subsets_other <- list(other_high, other_low, other_safe)

# Specify legend labels
legend_labels <- c("High", "Low", "Safe")


#------Waiting phase

# Create plots
scl_ts_waiting_other = funcs$plot_hr_timeseries_nconds(
  data_subsets = data_subsets_other,
  phase_timeseries = "scl_series_waiting",
  fig_title = "SCL change, waiting phase, other shock",
  legend_labels = legend_labels)

#expand y axis range to compare with other shock figure
scl_ts_waiting_other <- scl_ts_waiting_other +
  ylab('Skin conductance (µS)')
print(scl_ts_waiting_other)

#------ Anticipation phase

scl_ts_anticipation_other = funcs$plot_hr_timeseries_nconds(
  data_subsets = data_subsets_other,
  phase_timeseries = "scl_series_anticipation",
  fig_title = "SCL change, anticipation phase, other shock",
  legend_labels = legend_labels)

#expand y axis range to compare with other shock figure
scl_ts_anticipation_other <- scl_ts_anticipation_other +
  coord_cartesian(ylim = ylims_scl_anticipation) +
  ylab('Skin conductance (µS)')

print(scl_ts_anticipation_other)

#----- Response phase

# Calculate data subsets
other_high_non_faulty = subset(df_all_trials_all_subjs, shockRecipient == 0 & shockIntensity == 'high' & faultyShock == 0)
other_low_non_faulty = subset(df_all_trials_all_subjs, shockRecipient == 0 & shockIntensity == 'low' & faultyShock == 0)
other_safe_non_faulty = subset(df_all_trials_all_subjs, shockRecipient == 0 & shockIntensity == 'safe' & faultyShock == 0)

# Create a list of data subsets
data_subsets_other_nonfaulty <- list(other_high_non_faulty, other_low_non_faulty, other_safe_non_faulty)

scl_ts_response_other = funcs$plot_hr_timeseries_nconds(
  data_subsets = data_subsets_other_nonfaulty,
  phase_timeseries = "scl_series_response",
  fig_title = "SCL change, response phase, other shock",
  legend_labels = legend_labels
)

#expand y axis range to fit in epoch labels + compare with other figure
scl_ts_response_other <- scl_ts_response_other +
  coord_cartesian(ylim = ylims_scl_response) +
ylab('Skin conductance (µS)')
print(scl_ts_response_other)

```

##sumSCRs, mean per P

### Calculate means

Calculate means for each P for each condition

```{r}
#Mean across all trials in each condition
mean_scrs_intes_perP <- subset(df_all_trials_all_subjs, subjectID %in% subjects_with_EDA) %>%
    group_by(subjectID, shockIntensity, shockRecipient) %>%
    summarise(
      sum_scrs_waiting = mean(scr_amplitude_sum_waiting, na.rm = TRUE),
      sum_scrs_anticipation = mean(scr_amplitude_sum_anticipation, na.rm = TRUE),
      sum_scrs_response = mean(scr_amplitude_sum_response, na.rm = TRUE),
      n_scr_waiting = mean(n_scr_waiting, na.rm = TRUE),
      n_scr_anticipation = mean(n_scr_anticipation, na.rm = TRUE),
      n_scr_response = mean(n_scr_response, na.rm = TRUE)
      )

#First trial of each condition only
first_scrs_intes_perP <- subset(df_all_trials_all_subjs, subjectID %in% subjects_with_EDA) %>%
    group_by(subjectID, shockIntensity, shockRecipient) %>%
    slice(1) %>%  # Take the first row in each group
    summarise(
      sum_scrs_waiting = scr_amplitude_sum_waiting,
      sum_scrs_anticipation = scr_amplitude_sum_anticipation,
      sum_scrs_response = scr_amplitude_sum_response,
      n_scr_waiting = n_scr_waiting,
      n_scr_anticipation = n_scr_anticipation,
      n_scr_response = n_scr_response,
      .groups = 'drop'
    )


```

### Report SCR issues

```{r}
#calculate number of subjects with with no SCRS for high self shock
scrs_high_self = mean_scrs_intes_perP[mean_scrs_intes_perP$shockIntensity == "high" &
                                              mean_scrs_intes_perP$shockRecipient == 1, ]
scrs_low_self = mean_scrs_intes_perP[mean_scrs_intes_perP$shockIntensity == "low" &
                                              mean_scrs_intes_perP$shockRecipient == 1, ]

n_Ps_no_scrs_high_self_waiting = sum(scrs_high_self$n_scr_waiting == 0, na.rm = TRUE)
n_Ps_no_scrs_high_self_anticipation = sum(scrs_high_self$n_scr_anticipation == 0, na.rm = TRUE)
n_Ps_no_scrs_high_self_response = sum(scrs_high_self$n_scr_response == 0, na.rm = TRUE)

n_Ps_no_scrs_low_self_waiting = sum(scrs_low_self$n_scr_waiting == 0, na.rm = TRUE)
n_Ps_no_scrs_low_self_anticipation = sum(scrs_low_self$n_scr_anticipation == 0, na.rm = TRUE)
n_Ps_no_scrs_low_self_response = sum(scrs_low_self$n_scr_response == 0, na.rm = TRUE)

print(paste0(
  "Mean (SD) n SCRs in each phase for high self shock: ",
  "waiting ", round(mean(scrs_high_self$n_scr_waiting), 1), "(", round(sd(scrs_high_self$n_scr_waiting), 1), ")",
  "; anticipation ", round(mean(scrs_high_self$n_scr_anticipation), 1), "(", round(sd(scrs_high_self$n_scr_anticipation), 1), ")",
  "; response ", round(mean(scrs_high_self$n_scr_response), 1), "(", round(sd(scrs_high_self$n_scr_response), 1), ")"
  ))

print(paste0(
  "Mean (SD) n SCRs in each phase for low self shock: ",
  "waiting ", round(mean(scrs_low_self$n_scr_waiting), 1), "(", round(sd(scrs_low_self$n_scr_waiting), 1), ")",
  "; anticipation ", round(mean(scrs_low_self$n_scr_anticipation), 1), "(", round(sd(scrs_low_self$n_scr_anticipation), 1), ")",
  "; response ", round(mean(scrs_low_self$n_scr_response), 1), "(", round(sd(scrs_low_self$n_scr_response), 1), ")"
  ))


print(paste0(
  "n Ps with 0 SCRs in each phase for high self shock: ",
  "waiting ", round(n_Ps_no_scrs_high_self_waiting, 1),
  "; anticipation ", round(n_Ps_no_scrs_high_self_anticipation, 1), 
  "; response ", round(n_Ps_no_scrs_high_self_response, 1) ))

print(paste0(
  "n Ps with 0 SCRs in each phase for high self shock: ",
  "waiting ", round(n_Ps_no_scrs_high_self_waiting, 1),
  "; anticipation ", round(n_Ps_no_scrs_high_self_anticipation, 1), 
  "; response ", round(n_Ps_no_scrs_high_self_response, 1) ))

print(paste0(
  "n Ps with 0 SCRs in each phase for low self shock: ",
  "waiting ", round(n_Ps_no_scrs_low_self_waiting, 1),
  "; anticipation ", round(n_Ps_no_scrs_low_self_anticipation, 1), 
  "; response ", round(n_Ps_no_scrs_low_self_response, 1) ))

hist(scrs_high_self$n_scr_response)
hist(scrs_low_self$n_scr_response)
#hist(scrs_high_self$sum_scrs_response )
#hist(scrs_low_self$sum_scrs_response )
#> 10 subjects have no SCR responses to high self shock. 32 subjects have no SCR responses to low self shock
#> All subjects have <1.2 SCRs on average in response to high self shock


#> There are so few SCRs that there is not much variation in SCRs. 
#> May not be able to analyse SCRs

```



## B2B timeseries, mean per P

### Define fig parameters

```{r}
ylims_fisys_anticipation = c(-2, 6)
ylims_fisys_response = ylims_fisys_anticipation

ylims_fidia_anticipation = c(-2.5, 4)
ylims_fidia_response = ylims_fidia_anticipation
```

### fisys




#### Self shock, high, low, safe

```{r}
# Calculate data subsets
self_high_b2b = subset(df_all_trials_all_subjs, shockRecipient == 1 & shockIntensity == 'high' & subjectID %in% subjects_with_B2B)
self_low_BP = subset(df_all_trials_all_subjs, shockRecipient == 1 & shockIntensity == 'low' & subjectID %in% subjects_with_B2B)
self_safe_b2b = subset(df_all_trials_all_subjs, shockRecipient == 1 & shockIntensity == 'safe' & subjectID %in% subjects_with_B2B)

# Create a list of data subsets
data_subsets_self_BP <- list(self_high_b2b, self_low_BP, self_safe_b2b)

# Specify legend labels
legend_labels <- c("High", "Low", "Safe")

#-------Waiting phase

# Create plots
fisys_ts_waiting_self = funcs$plot_hr_timeseries_nconds(
  data_subsets = data_subsets_self_BP,
  phase_timeseries = "fisys_series_waiting",
  fig_title = "fisys change, waiting phase, self shock",
  legend_labels = legend_labels
)

#expand y axis range to compare with other shock figure
fisys_ts_waiting_self <- fisys_ts_waiting_self +
  ylab('mmHg') 
#print(fisys_ts_waiting_self)

#------- Anticipation phase

fisys_ts_anticipation_self = funcs$plot_hr_timeseries_nconds(
  data_subsets = data_subsets_self_BP,
  phase_timeseries = "fisys_series_anticipation",
  fig_title = "fisys change, anticipation phase, self shock",
  legend_labels = legend_labels
)

#expand y axis range to compare with other shock figure
fisys_ts_anticipation_self <- fisys_ts_anticipation_self +
  coord_cartesian(ylim = ylims_fisys_anticipation) + 
  ylab('mmHg')

print(fisys_ts_anticipation_self)

#------- Response phase

# Calculate data subsets
self_high_b2b_non_faulty = subset(df_all_trials_all_subjs, shockRecipient == 1 & shockIntensity == 'high' & faultyShock == 0 & subjectID %in% subjects_with_B2B)
self_low_b2b_non_faulty = subset(df_all_trials_all_subjs, shockRecipient == 1 & shockIntensity == 'low' & faultyShock == 0 & subjectID %in% subjects_with_B2B)
self_safe_b2b_non_faulty = subset(df_all_trials_all_subjs, shockRecipient == 1 & shockIntensity == 'safe' & faultyShock == 0 & subjectID %in% subjects_with_B2B)

# Create a list of data subsets
data_subsets_self_BP_nonfaulty <- list(self_high_b2b_non_faulty, self_low_b2b_non_faulty, self_safe_b2b_non_faulty)

fisys_ts_response_self = funcs$plot_hr_timeseries_nconds(
  data_subsets = data_subsets_self_BP_nonfaulty,
  phase_timeseries = "fisys_series_response",
  fig_title = "fisys change, response phase, self shock",
  legend_labels = legend_labels
)

#expand y axis range to fit in epoch labels
fisys_ts_response_self <- fisys_ts_response_self +
  coord_cartesian(ylim = ylims_fisys_response) +
  ylab('mmHg')

print(fisys_ts_response_self)

```

#### Other shock, high, low, safe

```{r}
# Calculate data subsets
other_high_b2b = subset(df_all_trials_all_subjs, shockRecipient == 0 & shockIntensity == 'high' & subjectID %in% subjects_with_B2B)
other_low_b2b = subset(df_all_trials_all_subjs, shockRecipient == 0 & shockIntensity == 'low' & subjectID %in% subjects_with_B2B)
other_safe_b2b = subset(df_all_trials_all_subjs, shockRecipient == 0 & shockIntensity == 'safe' & subjectID %in% subjects_with_B2B)

# Create a list of data subsets
data_subsets_other_BP <- list(other_high_b2b, other_low_b2b, other_safe_b2b)

# Specify legend labels
legend_labels <- c("High", "Low", "Safe")

#-------Waiting phase

# Create plots
fisys_ts_waiting_self = funcs$plot_hr_timeseries_nconds(
  data_subsets = data_subsets_other_BP,
  phase_timeseries = "fisys_series_waiting",
  fig_title = "fisys change, waiting phase, self shock",
  legend_labels = legend_labels
)

#expand y axis range to compare with other shock figure
fisys_ts_waiting_self <- fisys_ts_waiting_self +
  ylab('mmHg') 
#print(fisys_ts_waiting_self)

#------- Anticipation phase

fisys_ts_anticipation_self = funcs$plot_hr_timeseries_nconds(
  data_subsets = data_subsets_other_BP,
  phase_timeseries = "fisys_series_anticipation",
  fig_title = "fisys change, anticipation phase, other shock",
  legend_labels = legend_labels
)

#expand y axis range to compare with other shock figure
fisys_ts_anticipation_self <- fisys_ts_anticipation_self +
  coord_cartesian(ylim = ylims_fisys_anticipation) + 
  ylab('mmHg')

print(fisys_ts_anticipation_self)

#------- Response phase

# Calculate data subsets
other_high_b2b_non-faulty = subset(df_all_trials_all_subjs, shockRecipient == 0 & shockIntensity == 'high' & faultyShock == 0 & subjectID %in% subjects_with_B2B)
other_low_b2b_non_faulty = subset(df_all_trials_all_subjs, shockRecipient == 0 & shockIntensity == 'low' & faultyShock == 0 & subjectID %in% subjects_with_B2B)
other_safe_b2b_non_faulty = subset(df_all_trials_all_subjs, shockRecipient == 0 & shockIntensity == 'safe' & faultyShock == 0 & subjectID %in% subjects_with_B2B)

# Create a list of data subsets
data_subsets_other_BP_nonfaulty <- list(other_high_b2b_non-faulty, other_low_b2b_non_faulty, other_safe_b2b_non_faulty)

fisys_ts_response_self = funcs$plot_hr_timeseries_nconds(
  data_subsets = data_subsets_other_BP_nonfaulty,
  phase_timeseries = "fisys_series_response",
  fig_title = "fisys change, response phase, other shock",
  legend_labels = legend_labels
)

#expand y axis range to fit in epoch labels
fisys_ts_response_self <- fisys_ts_response_self +
  coord_cartesian(ylim = ylims_fisys_response) +
  ylab('mmHg')

print(fisys_ts_response_self)

```


###fidia




#### Self shock, high, low, safe

```{r}
# Calculate data subsets
self_high_b2b = subset(df_all_trials_all_subjs, shockRecipient == 1 & shockIntensity == 'high' & subjectID %in% subjects_with_B2B)
self_low_BP = subset(df_all_trials_all_subjs, shockRecipient == 1 & shockIntensity == 'low' & subjectID %in% subjects_with_B2B)
self_safe_b2b = subset(df_all_trials_all_subjs, shockRecipient == 1 & shockIntensity == 'safe' & subjectID %in% subjects_with_B2B)

# Create a list of data subsets
data_subsets_self_BP <- list(self_high_b2b, self_low_BP, self_safe_b2b)

# Specify legend labels
legend_labels <- c("High", "Low", "Safe")

#-------Waiting phase

# Create plots
fidia_ts_waiting_self = funcs$plot_hr_timeseries_nconds(
  data_subsets = data_subsets_self_BP,
  phase_timeseries = "fidia_series_waiting",
  fig_title = "fidia change, waiting phase, self shock",
  legend_labels = legend_labels
)

#expand y axis range to compare with other shock figure
fidia_ts_waiting_self <- fidia_ts_waiting_self +
  ylab('mmHg') 
#print(fidia_ts_waiting_self)

#------- Anticipation phase

fidia_ts_anticipation_self = funcs$plot_hr_timeseries_nconds(
  data_subsets = data_subsets_self_BP,
  phase_timeseries = "fidia_series_anticipation",
  fig_title = "fidia change, anticipation phase, self shock",
  legend_labels = legend_labels
)

#expand y axis range to compare with other shock figure
fidia_ts_anticipation_self <- fidia_ts_anticipation_self +
  coord_cartesian(ylim = ylims_fidia_anticipation) + 
  ylab('mmHg')

print(fidia_ts_anticipation_self)

#------- Response phase

# Calculate data subsets
self_high_b2b_non_faulty = subset(df_all_trials_all_subjs, shockRecipient == 1 & shockIntensity == 'high' & faultyShock == 0 & subjectID %in% subjects_with_B2B)
self_low_b2b_non_faulty = subset(df_all_trials_all_subjs, shockRecipient == 1 & shockIntensity == 'low' & faultyShock == 0 & subjectID %in% subjects_with_B2B)
self_safe_b2b_non_faulty = subset(df_all_trials_all_subjs, shockRecipient == 1 & shockIntensity == 'safe' & faultyShock == 0 & subjectID %in% subjects_with_B2B)

# Create a list of data subsets
data_subsets_self_BP_nonfaulty <- list(self_high_b2b_non_faulty, self_low_b2b_non_faulty, self_safe_b2b_non_faulty)

fidia_ts_response_self = funcs$plot_hr_timeseries_nconds(
  data_subsets = data_subsets_self_BP_nonfaulty,
  phase_timeseries = "fidia_series_response",
  fig_title = "fidia change, response phase, self shock",
  legend_labels = legend_labels
)

#expand y axis range to fit in epoch labels
fidia_ts_response_self <- fidia_ts_response_self +
  coord_cartesian(ylim = ylims_fidia_response) +
  ylab('mmHg')

print(fidia_ts_response_self)

```

#### Other shock, high, low, safe

```{r}
# Calculate data subsets
other_high_b2b = subset(df_all_trials_all_subjs, shockRecipient == 0 & shockIntensity == 'high' & subjectID %in% subjects_with_B2B)
other_low_b2b = subset(df_all_trials_all_subjs, shockRecipient == 0 & shockIntensity == 'low' & subjectID %in% subjects_with_B2B)
other_safe_b2b = subset(df_all_trials_all_subjs, shockRecipient == 0 & shockIntensity == 'safe' & subjectID %in% subjects_with_B2B)

# Create a list of data subsets
data_subsets_other_BP <- list(other_high_b2b, other_low_b2b, other_safe_b2b)

# Specify legend labels
legend_labels <- c("High", "Low", "Safe")

#-------Waiting phase

# Create plots
fidia_ts_waiting_self = funcs$plot_hr_timeseries_nconds(
  data_subsets = data_subsets_other_BP,
  phase_timeseries = "fidia_series_waiting",
  fig_title = "fidia change, waiting phase, self shock",
  legend_labels = legend_labels
)

#expand y axis range to compare with other shock figure
fidia_ts_waiting_self <- fidia_ts_waiting_self +
  ylab('mmHg') 
#print(fidia_ts_waiting_self)

#------- Anticipation phase

fidia_ts_anticipation_self = funcs$plot_hr_timeseries_nconds(
  data_subsets = data_subsets_other_BP,
  phase_timeseries = "fidia_series_anticipation",
  fig_title = "fidia change, anticipation phase, other shock",
  legend_labels = legend_labels
)

#expand y axis range to compare with other shock figure
fidia_ts_anticipation_self <- fidia_ts_anticipation_self +
  coord_cartesian(ylim = ylims_fidia_anticipation) + 
  ylab('mmHg')

print(fidia_ts_anticipation_self)

#------- Response phase

# Calculate data subsets
other_high_b2b_non-faulty = subset(df_all_trials_all_subjs, shockRecipient == 0 & shockIntensity == 'high' & faultyShock == 0 & subjectID %in% subjects_with_B2B)
other_low_b2b_non_faulty = subset(df_all_trials_all_subjs, shockRecipient == 0 & shockIntensity == 'low' & faultyShock == 0 & subjectID %in% subjects_with_B2B)
other_safe_b2b_non_faulty = subset(df_all_trials_all_subjs, shockRecipient == 0 & shockIntensity == 'safe' & faultyShock == 0 & subjectID %in% subjects_with_B2B)

# Create a list of data subsets
data_subsets_other_BP_nonfaulty <- list(other_high_b2b_non-faulty, other_low_b2b_non_faulty, other_safe_b2b_non_faulty)

fidia_ts_response_self = funcs$plot_hr_timeseries_nconds(
  data_subsets = data_subsets_other_BP_nonfaulty,
  phase_timeseries = "fidia_series_response",
  fig_title = "fidia change, response phase, other shock",
  legend_labels = legend_labels
)

#expand y axis range to fit in epoch labels
fidia_ts_response_self <- fidia_ts_response_self +
  coord_cartesian(ylim = ylims_fidia_response) +
  ylab('mmHg')

print(fidia_ts_response_self)

```

# -------------------------------------------

# Statistical modelling

# -------------------------------------------



## PRQ 1a - anticipation phase analyses

Test whether ADHD traits are associated with the magnitude of autonomic reactions:
a.	during anticipation of receiving painful electric shocks

## Principles for model simplification

Always check model warnings when fitting model not when running summary()

Use bobyqa optimiser as default. If that doesn't work, try Nelder-Mead

1. Remove correlations between random effects

2. Remove Random Slopes with Small or Zero Variance

Removing random effects for continuous predictors (e.g. trialNo_centered) - this will drastically reduce the number of parameters that need to be estimated

3. Remove Higher-Order Random Effects first - (remove random effects for session)

4. Remove unimportant random Intercepts

5. Simplify fixed effects


Explainer of model notation below:
>(trialNo | subjectID)
random slope + intercept for subject nested within sessions

>(shockIntensity | sessionID / subjectID)
random slope and intercept for sessions and subjects

>(trialNo || subjectID) 
uncorrelated random slope + intercept for trialNo for subjects

>(shockIntensity || subjectID:sessionID)
uncorrelated random slope + intercept for shockIntensity for subjects. For us, because the subject only appears in one session, the ':sessionID' term is redundant and I can use the usual notation (effect || subject) + (effect || session).

Statistical tests:
- Use type 3 ANOVA if there are interactions, use type 2 if none
- Use Holm-Bonferroni adjusted p values as default because it does not assume independence of tests.
- Use ANOVA instead of summary() to test effects where possible because it will use fewer parameters for p value adjustment so will be more powerful
- Use Tukey FWE corrected p values for pairwise comparisons in emmeans (default). It is optimal for pairwise comparisons





### HR timecourse

#### Prepare model data

```{r}
#Drop safe level from shockIntensity and exlude subjects without HR data
mod_data_prq1a_hr = droplevels(subset(df_all_trials_all_subjs, !is.na(mean_hr_anticipation) & shockIntensity != 'safe' & subjectID %in% subjects_with_HR ) )

#convert shockIntensity to numeric coding (1,0) to stop R fitting random effects separately for low and high
mod_data_prq1a_hr$shockIntensity <- as.numeric(mod_data_prq1a_hr$shockIntensity == "high")

# Calculate means for each CAARS subscale
mean_CAARS_index <- mean(unlist(df_demographs[df_demographs$subjectID %in% subjects_with_HR, "CAARS_T_index"]), na.rm = TRUE)
mean_CAARS_inatt <- mean(unlist(df_demographs[df_demographs$subjectID %in% subjects_with_HR, "CAARS_T_inatt"]), na.rm = TRUE)
mean_CAARS_hyp <- mean(unlist(df_demographs[df_demographs$subjectID %in% subjects_with_HR, "CAARS_T_hyp"]), na.rm = TRUE)
mean_CAARS_imp <- mean(unlist(df_demographs[df_demographs$subjectID %in% subjects_with_HR, "CAARS_T_imp"]), na.rm = TRUE)
mean_CAARS_self <- mean(unlist(df_demographs[df_demographs$subjectID %in% subjects_with_HR, "CAARS_T_self"]), na.rm = TRUE)

# Mean-centre each CAARS subscale
mod_data_prq1a_hr$CAARS_T_index_centred <- mod_data_prq1a_hr$CAARS_T_index - mean_CAARS_index
mod_data_prq1a_hr$CAARS_T_inatt_centred <- mod_data_prq1a_hr$CAARS_T_inatt - mean_CAARS_inatt
mod_data_prq1a_hr$CAARS_T_hyp_centred <- mod_data_prq1a_hr$CAARS_T_hyp - mean_CAARS_hyp
mod_data_prq1a_hr$CAARS_T_imp_centred <- mod_data_prq1a_hr$CAARS_T_imp - mean_CAARS_imp
mod_data_prq1a_hr$CAARS_T_self_centred <- mod_data_prq1a_hr$CAARS_T_self - mean_CAARS_self

# Mean centre trialNo within subjects
mod_data_prq1a_hr <- mod_data_prq1a_hr %>%
  group_by(subjectID) %>%
  mutate(trialNo_centered = trialNo - mean(trialNo, na.rm = TRUE)) %>%
  ungroup()

#Convert data to long format for analysis of time windows
mod_data_prq1a_hr_long = mod_data_prq1a_hr %>%
  pivot_longer(
    cols = starts_with("hr_anticipation_bin"),
    names_to = "time",
    names_prefix = "hr_anticipation_bin",
    values_to = "hr_value",
    values_drop_na = TRUE
  )

#Ensure time is in correct format (factor)
mod_data_prq1a_hr_long$time <- factor(mod_data_prq1a_hr_long$time, 
                                      levels = c(0, 1, 2, 3))

```

#### High vs Low shocks

Test whether ADHD-related differences in timecourse of HR responses split as a function of Shock Intensity (high vs. low) varies significantly based on the Shock Recipient (self vs. other).

> Pre-registered model to aim for:

Variable ~ CAARSADHD index*ShockIntensity*Time*ShockRecipient + shockIntensity*trialNo_centered + (trialNo_centered | Subject) + (shockIntensity + Time | Session / Subject)

```{r}

#Try fitting preregistered model using OLS
lmms$prq1a_hr_time_ShockRecipient <- lmer(hr_value ~ CAARS_T_index_centred*shockIntensity*time*shockRecipient
                                  + shockIntensity*trialNo_centered 
                                  + (trialNo_centered | subjectID) 
                                  + (shockIntensity + time | sessionID / subjectID), 
                                 data = mod_data_prq1a_hr_long,
                                 control = lmerControl(optimizer = "bobyqa") )
#> Model fails to converge with bobyqa or Nelder_Mead optimiser

#drop slope-intercept correlations for shockIntensity and trialNo
lmms$prq1a_hr_time_ShockRecipient_a <- lmer(hr_value ~                                         CAARS_T_index_centred*shockIntensity*time*shockRecipient
                                       + shockIntensity*trialNo_centered 
                                       + (trialNo_centered || subjectID) 
                                       + (shockIntensity + time || sessionID) +  
                                         (shockIntensity + time || subjectID),  
                                       data = mod_data_prq1a_hr_long,
                                       control = lmerControl(optimizer = "Nelder_Mead") )
#> Model fails to converge

#Remove random slopes for trialNo_centered
lmms$prq1a_hr_time_ShockRecipient_b <- lmer(hr_value ~ CAARS_T_index_centred*shockIntensity*time*shockRecipient
                                       + shockIntensity*trialNo_centered 
                                       + (shockIntensity + time || sessionID) +  
                                         (shockIntensity + time || subjectID), 
                                       data = mod_data_prq1a_hr_long,
                                       control = lmerControl(optimizer = "Nelder_Mead") )
#> Model fails to converge


#Remove session-level slope for time
lmms$prq1a_hr_time_ShockRecipient_c <- lmer(hr_value ~ CAARS_T_index_centred*shockIntensity*time*shockRecipient
                                       + shockIntensity*trialNo_centered 
                                       + (shockIntensity || sessionID) +  
                                         (shockIntensity + time || subjectID),  
                                       data = mod_data_prq1a_hr_long,
                                       control = lmerControl(optimizer = "Nelder_Mead") )
#> Model fails to converge


#Remove session-level slope for shockIntensity
lmms$prq1a_hr_time_ShockRecipient_d <- lmer(hr_value ~ CAARS_T_index_centred*shockIntensity*time*shockRecipient 
                                       + shockIntensity*trialNo_centered 
                                       + (1 | sessionID) +
                                         (shockIntensity + time || subjectID),  
                                       data = mod_data_prq1a_hr_long,
                                       control = lmerControl(optimizer = "Nelder_Mead") )
#> Model fails to converge

#Remove subject-level slope for time
lmms$prq1a_hr_time_ShockRecipient_e <- lmer(hr_value ~ CAARS_T_index_centred*shockIntensity*time*shockRecipient 
                                       + shockIntensity*trialNo_centered 
                                       + (1 | sessionID) +
                                         (shockIntensity || subjectID),  
                                       data = mod_data_prq1a_hr_long,
                                       control = lmerControl(optimizer = "bobyqa") )
#> Model converges with bobyqa optimiser :D :D
check_predictions(lmms$prq1a_hr_time_ShockRecipient_e)
check_outliers(lmms$prq1a_hr_time_ShockRecipient_e)
check_model(lmms$prq1a_hr_time_ShockRecipient_e)

#define winning model
lmms$prq1a_hr_time_ShockRecipient_WINNER <- lmms$prq1a_hr_time_ShockRecipient_e

#Anova with raw
Anova(lmms$prq1a_hr_time_ShockRecipient_WINNER, type = "3")

#summary with adj. pvals
summary_p_adj = funcs$adjust_lmm_p_vals(lmms$prq1a_hr_time_ShockRecipient_WINNER, 
                                      "summary", "t", "holm", NA)
print(summary_p_adj)


```

##### Report results

```{r}

#Save model table
funcs$savelmmTable(lmms$prq1a_hr_time_ShockRecipient_WINNER, 
                   paste0(figures_folder,"/", "prq1a_hr_time_ShockRecipient.doc"))

#Save ANOVA table
anova_prq1a_hr_time_ShockRecipient <- Anova(lmms$prq1a_hr_time_ShockRecipient_WINNER, type = "3")
#get rownames
anova_prq1a_hr_time_ShockRecipient$Term <- rownames(anova_prq1a_hr_time_ShockRecipient)
# Move the 'Term' column to the first position
anova_prq1a_hr_time_ShockRecipient <- anova_prq1a_hr_time_ShockRecipient[, c("Term",  setdiff(names(anova_prq1a_hr_time_ShockRecipient), "Term"))]
write_xlsx(as.data.frame(anova_prq1a_hr_time_ShockRecipient), 
           paste0(figures_folder,"/", "anova_prq1a_hr_time_ShockRecipient.xlsx"))


```

##### Figs

```{r}
# Calculate mean and SD of CAARS_T_index_centred
mean_caars <- 0 #mean of mean centred is zero!
sd_caars <- sd(subset(df_demographs,subjectID %in% subjects_with_HR)$CAARS_T_index_centred, na.rm = TRUE)
caars_low <- mean_caars - sd_caars
caars_high <- mean_caars + sd_caars


#------------- Plot 4-way interaction

# Generate predictions for the interaction
preds_ant_hr_adhd_intens_time_recipient <- ggpredict(
  lmms$prq1a_hr_time_ShockRecipient_WINNER,
  terms = c(
    "time", 
    sprintf("CAARS_T_index_centred [%.3f,%.3f]", caars_low, caars_high), 
    "shockIntensity [0,1]", 
    "shockRecipient [0,1]"
  )
)

#label group as ADHD +- 1SD from the mean
group_numeric <- as.numeric(as.character(preds_ant_hr_adhd_intens_time_recipient$group)) # Convert group to numeric for ordering
group_levels <- sort(unique(group_numeric)) # Get unique sorted values
preds_ant_hr_adhd_intens_time_recipient$group <- factor( # Assign labels: lower = "-1 SD", higher = "+1 SD"
  group_numeric,
  levels = group_levels,
  labels = c("CAARS-S:S\nMean -1 SD", "CAARS-S:S\nMean +1 SD")
)

# Label facets for shockIntensity
preds_ant_hr_adhd_intens_time_recipient$facet <- factor(preds_ant_hr_adhd_intens_time_recipient$facet, levels = c("0", "1"), labels = c("Low", "High"))

# Label facets for shockRecipient
preds_ant_hr_adhd_intens_time_recipient$panel <- factor(preds_ant_hr_adhd_intens_time_recipient$panel, levels = c("0", "1"), labels = c("Other", "Self"))

#convert time to numeric
preds_ant_hr_adhd_intens_time_recipient$time <- as.numeric(as.character(preds_ant_hr_adhd_intens_time_recipient$x))

#Make figure + save
p_ant_hr_adhd_intens_time_recipient <- funcs$plot_adhd_intens_time_recipient(preds_ant_hr_adhd_intens_time_recipient,
save_destination = figures_folder,
fig_width = 7,
fig_height = 2.6,
phase = "Anticipation",
measure = "HR", 
shockIntensityConds = c("Low", "High"))

#-----Main effects of ADHD traits
#predict values
preds_ant_hr_adhd <- ggpredict(
  lmms$prq1a_hr_time_ShockRecipient_WINNER,
  terms ="CAARS_T_index_centred")

# Plot figure
p_ant_hr_index <- funcs$plot_linear_hr(pred_data = preds_ant_hr_adhd, 
                                       x_label = "CAARS-S:S Index\n(centred)",
                                       y_label = "Heart rate (bpm)",
                                       phase = "ant",
                                       ylims = c(65,92))



#----intense X time X recipient main effect and interactions

p_ant_hr_time_intensity_recipient <- funcs$plot_intens_time_recipient(lmms$prq1a_hr_time_ShockRecipient_WINNER,
                                  save_destination = figures_folder,
                                  fig_width = 5,
                                  fig_height = 2.6,
                                  phase = "Anticipation",
                                  measure = "HR", 
                                  shockIntensityConds = c("Low", "High"))


```

##### Main/simple effects

```{r}

#----Simple effects of shockIntensity × time within each shockRecipient condition

# Define emms for shockIntensity * time within each level of shock recipient
emm_int <- emmeans(
  lmms$prq1a_hr_time_ShockRecipient_WINNER,
  ~ shockIntensity * time | shockRecipient ,
  adjust = "holm",
  lmer.df = "satterthwaite"
)

# Define contrast coefficients for interaction (averaged over all timepoints)
# For 2 levels of shockIntensity and 4 levels of time_window,
# the interaction contrast tests if the difference (High - Low)
# differs across timepoints within each recipient.

#Check order of conditions
#emm_int

# This is a "joint" test, not pairwise differences at each timepoint.
custom_contrast <- list(
  "shockIntensity × time_window interaction" = c(-1, 1, -1, 1, -1, 1, -1, 1) / 4
)

# Apply the contrast, with "by = shockRecipient"
cont_int <- contrast(emm_int, 
                     custom_contrast, 
                     adjust = "holm", 
                    lmer.df = "satterthwaite",
                     by = "shockRecipient")

# Summary results: one joint test per recipient
summary(cont_int)


# Test interaction contrasts (pairwise comparisons for time) separately for each shockRecipient
emm_int <- contrast(
  emm_ant_hr_intens_X_time, 
  interaction = "pairwise", 
  adjust = "holm",
  lmer.df = "satterthwaite"   # Use Satterthwaite's df
)
# View results
print(contrast_results_emm_ant_intens_X_time)

# save emmeans
write_xlsx(as.data.frame(emm_ant_hr_intens_X_time), 
           paste0(figures_folder,"/", "emm_ant_hr_intens_X_time.xlsx"))

# Save contrasts
write_xlsx(as.data.frame(contrast_results_emm_ant_intens_X_time), 
           paste0(figures_folder,"/", "contrast_results_ant_emm_intens_X_time.xlsx"))

```






### SCL timecourse

#### Prepare model data

```{r}
#Drop safe level from shockIntensity and exlude subjects without SCL data
mod_data_prq1a_scl = droplevels(subset(df_all_trials_all_subjs, !is.na(mean_scl_anticipation) & shockIntensity != 'safe' & subjectID %in% subjects_with_EDA ) )

#convert shockIntensity to numeric coding (1,0) to stop R fitting random effects separately for low and high
mod_data_prq1a_scl$shockIntensity <- as.numeric(mod_data_prq1a_scl$shockIntensity == "high")


# Calculate mean of each CAARS subscale
mean_CAARS_index <- mean(unlist(df_demographs[df_demographs$subjectID %in% subjects_with_EDA, "CAARS_T_index"]), na.rm = TRUE)
mean_CAARS_inatt <- mean(unlist(df_demographs[df_demographs$subjectID %in% subjects_with_EDA, "CAARS_T_inatt"]), na.rm = TRUE)
mean_CAARS_hyp <- mean(unlist(df_demographs[df_demographs$subjectID %in% subjects_with_EDA, "CAARS_T_hyp"]), na.rm = TRUE)
mean_CAARS_imp <- mean(unlist(df_demographs[df_demographs$subjectID %in% subjects_with_EDA, "CAARS_T_imp"]), na.rm = TRUE)
mean_CAARS_self <- mean(unlist(df_demographs[df_demographs$subjectID %in% subjects_with_EDA, "CAARS_T_self"]), na.rm = TRUE)

#Mean centre CAARS subscales
mod_data_prq1a_scl$CAARS_T_index_centred <- mod_data_prq1a_scl$CAARS_T_index - mean_CAARS_index
mod_data_prq1a_scl$CAARS_T_inatt_centred <- mod_data_prq1a_scl$CAARS_T_inatt - mean_CAARS_inatt
mod_data_prq1a_scl$CAARS_T_hyp_centred <- mod_data_prq1a_scl$CAARS_T_hyp - mean_CAARS_hyp
mod_data_prq1a_scl$CAARS_T_imp_centred <- mod_data_prq1a_scl$CAARS_T_imp - mean_CAARS_imp
mod_data_prq1a_scl$CAARS_T_self_centred <- mod_data_prq1a_scl$CAARS_T_self - mean_CAARS_self

# Mean centre trialNo within subjects
mod_data_prq1a_scl <- mod_data_prq1a_scl %>%
  group_by(subjectID) %>%
  mutate(trialNo_centered = trialNo - mean(trialNo, na.rm = TRUE)) %>%
  ungroup()

#Convert data to long format for analysis of time windows
mod_data_prq1a_scl_long = mod_data_prq1a_scl %>%
  pivot_longer(
    cols = starts_with("scl_anticipation_bin"),
    names_to = "time",
    names_prefix = "scl_anticipation_bin",
    values_to = "scl_value",
    values_drop_na = TRUE
  )

#Ensure time is in correct format (factor)
mod_data_prq1a_scl_long$time <- factor(mod_data_prq1a_scl_long$time, 
                                      levels = c(0, 1, 2, 3))

```


#### High vs Low shocks

Test whether ADHD-related differences in timecourse of SCL responses split as a function of Shock Intensity (high vs. low) varies significantly based on the Shock Recipient (self vs. other).

> Pre-registered model to aim for:
  
  Variable ~ CAARSADHD index*ShockIntensity*Time*ShockRecipient + shockIntensity*trialNo_centered + (trialNo_centered | Subject) + (shockIntensity + Time | Session / Subject)

```{r}

#Try fitting preregistered model using OLS
lmms$prq1a_scl_time_ShockRecipient <- lmer(scl_value ~ CAARS_T_index_centred*shockIntensity*time*shockRecipient
                                          + shockIntensity*trialNo_centered 
                                          + (trialNo_centered | subjectID) 
                                          + (shockIntensity + time | sessionID / subjectID), 
                                          data = mod_data_prq1a_scl_long,
                                          control = lmerControl(optimizer = "bobyqa") )
#> Model fails to converge with bobyqa or Nelder_Mead optimiser

#drop slope-intercept correlations for shockIntensity and trialNo
lmms$prq1a_scl_time_ShockRecipient_a <- lmer(scl_value ~                                         CAARS_T_index_centred*shockIntensity*time*shockRecipient
                                            + shockIntensity*trialNo_centered 
                                            + (trialNo_centered || subjectID) 
                                            + (shockIntensity + time || sessionID) +  
                                              (shockIntensity + time || subjectID),  
                                            data = mod_data_prq1a_scl_long,
                                            control = lmerControl(optimizer = "bobyqa") )
#> Model fails to converge

#Remove random slopes for trialNo_centered
lmms$prq1a_scl_time_ShockRecipient_b <- lmer(scl_value ~ CAARS_T_index_centred*shockIntensity*time*shockRecipient
                                            + shockIntensity*trialNo_centered 
                                            + (shockIntensity + time || sessionID) +  
                                              (shockIntensity + time || subjectID), 
                                            data = mod_data_prq1a_scl_long,
                                            control = lmerControl(optimizer = "Nelder_Mead") )
#> Model fails to converge


#Remove session-level slope for time
lmms$prq1a_scl_time_ShockRecipient_c <- lmer(scl_value ~ CAARS_T_index_centred*shockIntensity*time*shockRecipient
                                            + shockIntensity*trialNo_centered 
                                            + (shockIntensity || sessionID) +  
                                              (shockIntensity + time || subjectID),  
                                            data = mod_data_prq1a_scl_long,
                                            control = lmerControl(optimizer = "Nelder_Mead") )
#> Model fails to converge


#Remove session-level slope for shockIntensity
lmms$prq1a_scl_time_ShockRecipient_d <- lmer(scl_value ~ CAARS_T_index_centred*shockIntensity*time*shockRecipient 
                                            + shockIntensity*trialNo_centered 
                                            + (1 | sessionID) +
                                              (shockIntensity + time || subjectID),  
                                            data = mod_data_prq1a_scl_long,
                                            control = lmerControl(optimizer = "Nelder_Mead") )
#> Model fails to converge


#Remove subject-level slope for time
lmms$prq1a_scl_time_ShockRecipient_e <- lmer(scl_value ~ CAARS_T_index_centred*shockIntensity*time*shockRecipient 
                                       + shockIntensity*trialNo_centered 
                                       + (1 | sessionID) +
                                         (shockIntensity || subjectID),  
                                       data = mod_data_prq1a_scl_long,
                                       control = lmerControl(optimizer = "Nelder_Mead") )
#> Model converges with Nelder-Mead optimiser :D :D
check_predictions(lmms$prq1a_scl_time_ShockRecipient_e)
check_outliers(lmms$prq1a_scl_time_ShockRecipient_e)
check_model(lmms$prq1a_scl_time_ShockRecipient_e)

#define winning model
lmms$prq1a_scl_time_ShockRecipient_WINNER <- lmms$prq1a_scl_time_ShockRecipient_e

```

##### Report results

```{r}

#Save model table
funcs$savelmmTable(lmms$prq1a_scl_time_ShockRecipient_WINNER, 
                   paste0(figures_folder,"/", "prq1a_scl_time_ShockRecipient.doc"))

#Save ANOVA table
anova_prq1a_scl_time_ShockRecipient <- Anova(lmms$prq1a_scl_time_ShockRecipient_WINNER, type = "3")
anova_prq1a_scl_time_ShockRecipient$Term <- rownames(anova_prq1a_scl_time_ShockRecipient)
# Move the 'Term' column to the first position
anova_prq1a_scl_time_ShockRecipient <- anova_prq1a_scl_time_ShockRecipient[, c("Term",  setdiff(names(anova_prq1a_scl_time_ShockRecipient), "Term"))]
write_xlsx(as.data.frame(anova_prq1a_scl_time_ShockRecipient), 
           paste0(figures_folder,"/", "anova_prq1a_scl_time_ShockRecipient.xlsx"))


```

##### Figs

```{r}
# Calculate mean and SD of CAARS_T_index_centred
mean_caars <- 0 #mean of mean centred is zero!
sd_caars <- sd(subset(df_demographs,subjectID %in% subjects_with_EDA)$CAARS_T_index_centred, na.rm = TRUE)
caars_low <- mean_caars - sd_caars
caars_high <- mean_caars + sd_caars


#------------- Plot 4-way interaction

# Generate predictions for the interaction
preds_ant_SCL_adhd_intens_time_recipient <- ggpredict(
  lmms$prq1a_scl_time_ShockRecipient_WINNER,
  terms = c(
    "time", 
    sprintf("CAARS_T_index_centred [%.3f,%.3f]", caars_low, caars_high), 
    "shockIntensity [0,1]", 
    "shockRecipient [0,1]"
  )
)

#label group as ADHD +- 1SD from the mean
group_numeric <- as.numeric(as.character(preds_ant_SCL_adhd_intens_time_recipient$group)) # Convert group to numeric for ordering
group_levels <- sort(unique(group_numeric)) # Get unique sorted values
preds_ant_SCL_adhd_intens_time_recipient$group <- factor( # Assign labels: lower = "-1 SD", higher = "+1 SD"
  group_numeric,
  levels = group_levels,
  labels = c("CAARS-S:S\nMean -1 SD", "CAARS-S:S\nMean +1 SD")
)

# Label facets for shockIntensity
preds_ant_SCL_adhd_intens_time_recipient$facet <- factor(preds_ant_SCL_adhd_intens_time_recipient$facet, levels = c("0", "1"), labels = c("Low", "High"))

# Label facets for shockRecipient
preds_ant_SCL_adhd_intens_time_recipient$panel <- factor(preds_ant_SCL_adhd_intens_time_recipient$panel, levels = c("0", "1"), labels = c("Other", "Self"))

#convert time to numeric
preds_ant_SCL_adhd_intens_time_recipient$time <- as.numeric(as.character(preds_ant_SCL_adhd_intens_time_recipient$x))

#Make figure + save
p_ant_hr_adhd_intens_time_recipient <- funcs$plot_adhd_intens_time_recipient(preds_ant_SCL_adhd_intens_time_recipient,                                                                save_destination = figures_folder,                                                               fig_width = 7,                                                              fig_height = 2.6,                                                               phase = "Anticipation",                                                      measure = "SCL", 
shockIntensityConds = c("Low", "High"))



#----- intense X time X recipient main effect and interactions
p_ant_scl_time_intensity_recipient <- funcs$plot_intens_time_recipient(lmms$prq1a_scl_time_ShockRecipient_WINNER,
                                  save_destination = figures_folder,
                                  fig_width = 5,
                                  fig_height = 2.6,
                                  phase = "Anticipation",
                                  measure = "SCL", 
                                  shockIntensityConds = c("Low", "High"))

```

##### Main/simple effects

```{r}

#----Simple effects of shockIntensity × time within each shockRecipient condition

# Define emms for shockIntensity * time within each level of shock recipient
emm_ant_SCL_intens_X_time <- emmeans(
  lmms$prq1a_scl_time_ShockRecipient_WINNER,
  ~ shockIntensity * time | shockRecipient ,
  adjust = "holm",
  lmer.df = "satterthwaite"
)

# Define contrast coefficients for interaction (averaged over all timepoints)
# For 2 levels of shockIntensity and 4 levels of time_window,
# the interaction contrast tests if the difference (High - Low)
# differs across timepoints within each recipient.

#Check order of conditions
#emm_int

# This is a "joint" test, not pairwise differences at each timepoint.
custom_contrast <- list(
  "shockIntensity × time_window interaction" = c(-1, 1, -1, 1, -1, 1, -1, 1) / 4
)

# Apply the contrast, with "by = shockRecipient"
cont_int <- contrast(emm_ant_SCL_intens_X_time, 
                     custom_contrast, 
                     adjust = "holm", 
                    lmer.df = "satterthwaite",
                     by = "shockRecipient")

# Summary results: one joint test per recipient
summary(cont_int)


# Test interaction contrasts (pairwise comparisons for time) separately for each shockRecipient
contrast_results_emm_ant_intens_X_time <- contrast(
  emm_ant_SCL_intens_X_time, 
  interaction = "pairwise", 
  adjust = "holm",
  lmer.df = "satterthwaite"   # Use Satterthwaite's df
)
# View results
print(contrast_results_emm_ant_intens_X_time)

# save emmeans
write_xlsx(as.data.frame(emm_ant_SCL_intens_X_time), 
           paste0(figures_folder,"/", "emm_ant_SCL_intens_X_time.xlsx"))

# Save contrasts
write_xlsx(as.data.frame(contrast_results_emm_ant_intens_X_time), 
           paste0(figures_folder,"/", "contrast_results_ant_emm_intens_X_time.xlsx"))

```



### fisys timecourse

#### Prepare model data

```{r}
#Drop safe level from shockIntensity and exlude subjects without fisys data
mod_data_prq1a_fisys = droplevels(subset(df_all_trials_all_subjs, !is.na(mean_fisys_anticipation) & shockIntensity != 'safe' & subjectID %in% subjects_with_B2B ) )

#convert shockIntensity to numeric coding (1,0) to stop R fitting random effects separately for low and high
mod_data_prq1a_fisys$shockIntensity <- as.numeric(mod_data_prq1a_fisys$shockIntensity == "high")

# Calculate mean of each CAARS subscale
mean_CAARS_index <- mean(unlist(df_demographs[df_demographs$subjectID %in% subjects_with_B2B, "CAARS_T_index"]), na.rm = TRUE)
mean_CAARS_inatt <- mean(unlist(df_demographs[df_demographs$subjectID %in% subjects_with_B2B, "CAARS_T_inatt"]), na.rm = TRUE)
mean_CAARS_hyp <- mean(unlist(df_demographs[df_demographs$subjectID %in% subjects_with_B2B, "CAARS_T_hyp"]), na.rm = TRUE)
mean_CAARS_imp <- mean(unlist(df_demographs[df_demographs$subjectID %in% subjects_with_B2B, "CAARS_T_imp"]), na.rm = TRUE)
mean_CAARS_self <- mean(unlist(df_demographs[df_demographs$subjectID %in% subjects_with_B2B, "CAARS_T_self"]), na.rm = TRUE)

#Mean centre CAARS subscales
mod_data_prq1a_fisys$CAARS_T_index_centred <- mod_data_prq1a_fisys$CAARS_T_index - mean_CAARS_index
mod_data_prq1a_fisys$CAARS_T_inatt_centred <- mod_data_prq1a_fisys$CAARS_T_inatt - mean_CAARS_inatt
mod_data_prq1a_fisys$CAARS_T_hyp_centred <- mod_data_prq1a_fisys$CAARS_T_hyp - mean_CAARS_hyp
mod_data_prq1a_fisys$CAARS_T_imp_centred <- mod_data_prq1a_fisys$CAARS_T_imp - mean_CAARS_imp
mod_data_prq1a_fisys$CAARS_T_self_centred <- mod_data_prq1a_fisys$CAARS_T_self - mean_CAARS_self

# Mean centre trialNo within subjects
mod_data_prq1a_fisys <- mod_data_prq1a_fisys %>%
  group_by(subjectID) %>%
  mutate(trialNo_centered = trialNo - mean(trialNo, na.rm = TRUE)) %>%
  ungroup()


#Convert data to long format for time window analyses
mod_data_prq1a_fisys_long = mod_data_prq1a_fisys %>%
  pivot_longer(
    cols = starts_with("fisys_anticipation_bin"),
    names_to = "time",
    names_prefix = "fisys_anticipation_bin",
    values_to = "fisys_value",
    values_drop_na = TRUE
  )

#Ensure time is in correct format (factor)
mod_data_prq1a_fisys_long$time <- factor(mod_data_prq1a_fisys_long$time, 
                                       levels = c(0, 1, 2, 3))
```



#### High vs Low shocks

Test whether ADHD-related differences in timecourse of fisys responses split as a function of Shock Intensity (high vs. low) varies significantly based on the Shock Recipient (self vs. other).

> Pre-registered model to aim for:
  
  Variable ~ CAARSADHD index*ShockIntensity*Time*ShockRecipient + shockIntensity*trialNo_centered + (trialNo_centered | Subject) + (shockIntensity + Time | Session / Subject)

```{r}

#Try fitting preregistered model using OLS
lmms$prq1a_fisys_time_ShockRecipient <- lmer(fisys_value ~ CAARS_T_index_centred*shockIntensity*time*shockRecipient
                                             + shockIntensity*trialNo_centered 
                                             + (trialNo_centered | subjectID) 
                                             + (shockIntensity + time | sessionID / subjectID), 
                                             data = mod_data_prq1a_fisys_long,
                                             control = lmerControl(optimizer = "bobyqa") )
#> Model fails to converge with bobyqa or Nelder_Mead optimiser

#drop slope-intercept correlations for shockIntensity and trialNo
lmms$prq1a_fisys_time_ShockRecipient_a <- lmer(fisys_value ~                                         CAARS_T_index_centred*shockIntensity*time*shockRecipient
                                               + shockIntensity*trialNo_centered 
                                               + (trialNo_centered || subjectID) 
                                               + (shockIntensity + time || sessionID) +  
                                                 (shockIntensity + time || subjectID),  
                                               data = mod_data_prq1a_fisys_long,
                                               control = lmerControl(optimizer = "Nelder_Mead") )
#> Model fails to converge

#Remove random slopes for trialNo_centered
lmms$prq1a_fisys_time_ShockRecipient_b <- lmer(fisys_value ~ CAARS_T_index_centred*shockIntensity*time*shockRecipient
                                               + shockIntensity*trialNo_centered 
                                               + (shockIntensity + time || sessionID) +  
                                                 (shockIntensity + time || subjectID), 
                                               data = mod_data_prq1a_fisys_long,
                                               control = lmerControl(optimizer = "Nelder_Mead") )
#> Model fails to converge


#Remove session-level slope for time
lmms$prq1a_fisys_time_ShockRecipient_c <- lmer(fisys_value ~ CAARS_T_index_centred*shockIntensity*time*shockRecipient
                                               + shockIntensity*trialNo_centered 
                                               + (shockIntensity || sessionID) +  
                                                 (shockIntensity + time || subjectID),  
                                               data = mod_data_prq1a_fisys_long,
                                               control = lmerControl(optimizer = "Nelder_Mead") )
#> Model fails to converge


#Remove session-level slope for shockIntensity
lmms$prq1a_fisys_time_ShockRecipient_d <- lmer(fisys_value ~ CAARS_T_index_centred*shockIntensity*time*shockRecipient 
                                               + shockIntensity*trialNo_centered 
                                               + (1 | sessionID) +
                                                 (shockIntensity + time || subjectID),  
                                               data = mod_data_prq1a_fisys_long,
                                               control = lmerControl(optimizer = "Nelder_Mead") )
#> Model fails to converge

#Remove subject-level slope for time
lmms$prq1a_fisys_time_ShockRecipient_e <- lmer(fisys_value ~ CAARS_T_index_centred*shockIntensity*time*shockRecipient 
                                               + shockIntensity*trialNo_centered 
                                               + (1 | sessionID) +
                                                 (shockIntensity || subjectID),  
                                               data = mod_data_prq1a_fisys_long,
                                               control = lmerControl(optimizer = "Nelder_Mead") )
#> Model converges with bobyqa optimiser :D :D
check_predictions(lmms$prq1a_fisys_time_ShockRecipient_e)
check_outliers(lmms$prq1a_fisys_time_ShockRecipient_e)
check_model(lmms$prq1a_fisys_time_ShockRecipient_e)

#define winning model
lmms$prq1a_fisys_time_ShockRecipient_WINNER <- lmms$prq1a_fisys_time_ShockRecipient_e

```


##### Report results

```{r}

#Save model table
funcs$savelmmTable(lmms$prq1a_fisys_time_ShockRecipient_WINNER, 
                   paste0(figures_folder,"/", "prq1a_fisys_time_ShockRecipient.doc"))

#Save ANOVA table
anova_prq1a_fisys_time_ShockRecipient <- Anova(lmms$prq1a_fisys_time_ShockRecipient_WINNER, type = "3")
anova_prq1a_fisys_time_ShockRecipient$Term <- rownames(anova_prq1a_fisys_time_ShockRecipient)
# Move the 'Term' column to the first position
anova_prq1a_fisys_time_ShockRecipient <- anova_prq1a_fisys_time_ShockRecipient[, c("Term",  setdiff(names(anova_prq1a_fisys_time_ShockRecipient), "Term"))]
write_xlsx(as.data.frame(anova_prq1a_fisys_time_ShockRecipient), 
           paste0(figures_folder,"/", "anova_prq1a_fisys_time_ShockRecipient.xlsx"))


```

##### Figs

```{r}
# Calculate mean and SD of CAARS_T_index_centred
mean_caars <- 0 #mean of mean centred is zero!
sd_caars <- sd(subset(df_demographs,subjectID %in% subjects_with_B2B)$CAARS_T_index_centred, na.rm = TRUE)
caars_low <- mean_caars - sd_caars
caars_high <- mean_caars + sd_caars


#------------- Plot 4-way interaction

# Generate predictions for the interaction
preds_ant_fisys_adhd_intens_time_recipient <- ggpredict(
  lmms$prq1a_fisys_time_ShockRecipient_WINNER,
  terms = c(
    "time", 
    sprintf("CAARS_T_index_centred [%.3f,%.3f]", caars_low, caars_high), 
    "shockIntensity [0,1]", 
    "shockRecipient [0,1]"
  )
)

#label group as ADHD +- 1SD from the mean
group_numeric <- as.numeric(as.character(preds_ant_fisys_adhd_intens_time_recipient$group)) # Convert group to numeric for ordering
group_levels <- sort(unique(group_numeric)) # Get unique sorted values
preds_ant_fisys_adhd_intens_time_recipient$group <- factor( # Assign labels: lower = "-1 SD", higher = "+1 SD"
  group_numeric,
  levels = group_levels,
  labels = c("CAARS-S:S\nMean -1 SD", "CAARS-S:S\nMean +1 SD")
)

# Label facets for shockIntensity
preds_ant_fisys_adhd_intens_time_recipient$facet <- factor(preds_ant_fisys_adhd_intens_time_recipient$facet, levels = c("0", "1"), labels = c("Low", "High"))

# Label facets for shockRecipient
preds_ant_fisys_adhd_intens_time_recipient$panel <- factor(preds_ant_fisys_adhd_intens_time_recipient$panel, levels = c("0", "1"), labels = c("Other", "Self"))

#convert time to numeric
preds_ant_fisys_adhd_intens_time_recipient$time <- as.numeric(as.character(preds_ant_fisys_adhd_intens_time_recipient$x))

#Make figure + save
p_ant_fisys_adhd_intens_time_recipient <- funcs$plot_adhd_intens_time_recipient(preds_ant_fisys_adhd_intens_time_recipient,
save_destination = figures_folder,
fig_width = 7,
fig_height = 2.6,
phase = "Anticipation",
measure = "fisys", 
shockIntensityConds = c("Low", "High"))


#------ intense X time X recipient main effect and interactions

p_ant_fisys_time_intensity_recipient <- funcs$plot_intens_time_recipient(lmms$prq1a_fisys_time_ShockRecipient_WINNER,
                                  save_destination = figures_folder,
                                  fig_width = 5,
                                  fig_height = 2.6,
                                  phase = "Anticipation",
                                  measure = "fisys", 
                                  shockIntensityConds = c("Low", "High"))


#--- Plot CAARS_T_index * shock intensity * shock recipient interaction
p_ant_fisys_adhd_intens_recip <- funcs$plot_psychophys_adhd_intens_recip(lmms$prq1a_fisys_time_ShockRecipient_WINNER, 
                                                         figures_folder,
                                                         fig_width = 4,
                                                         fig_height = 2.6,
                                                         measure = "fisys",
                                                         phase = "ant")


```

##### Main/simple effects

```{r}
#----Simple effects of CAARS index x shockIntensity within each shockRecipient condition

# Get the estimated marginal trends (slopes) of CAARS_T_index_centred by shockIntensity
emm_trends_index_intensity <- emtrends(
  lmms$prq1a_fisys_time_ShockRecipient_WINNER,
  specs = ~ shockIntensity,
  var = "CAARS_T_index_centred", 
  by = "shockRecipient",
  adjust = "holm",
  lmer.df = "satterthwaite"
)

# Test the difference in slopes between shockIntensity levels
pairs(emm_trends_index_intensity)

#Save emtrends
write_xlsx(as.data.frame(emm_trends_index_intensity), 
            paste0(figures_folder,"/", "ant_fisys_emmtrends_index_intensity.xlsx"))

#Save contrasts
write_xlsx(as.data.frame(pairs(emm_trends_index_intensity)), 
            paste0(figures_folder,"/", "contrasts_ant_fisys_emmtrends_index_intensity.xlsx"))


#----Plot emtrends figure
p_emtrends_ant_intens_recip_index <- ggplot(
  as.data.frame(emm_trends_index_intensity), 
  aes(
    x = factor(shockRecipient), 
    y = CAARS_T_index_centred.trend, 
    color = factor(shockIntensity), 
    group = factor(shockIntensity)
  )
) +
  geom_line(size = 1.2, position = position_dodge(width = 0.2)) +
  geom_point(size = 3, position = position_dodge(width = 0.2)) +
  geom_errorbar(
    aes(
      ymin = CAARS_T_index_centred.trend - SE, 
      ymax = CAARS_T_index_centred.trend + SE
    ),
    width = 0.1, 
    position = position_dodge(width = 0.2)
  ) +
  labs(
    x = "Shock Recipient",
    y = "Estimated Slope of CAARS-S:S ADHD index",
    color = "Shock Intensity",
    title = "Estimated Marginal Trends of CAARS-S:S ADHD index\nby Shock Intensity and Recipient"
  ) +
  scale_x_discrete(labels = c("other", "self")) +
  scale_color_manual(values = c(custom_palette[2], custom_palette[1]), labels = c("Low", "High")) +
  theme_classic()

p_emtrends_ant_intens_recip_index

#save figure
ggsave(paste0(figures_folder,"/", "emtrends_ant_intens_recip_index.png"), p_emtrends_ant_intens_recip_index, width = 6, height = 4, units = "in", dpi = 300, limitsize = FALSE)

#---Plot model predicted values figure

# Calculate mean and SD of CAARS_T_index_centred
mean_caars <- mean(mod_data_prq1a_fisys_long$CAARS_T_index_centred, na.rm = TRUE)
sd_caars <- sd(mod_data_prq1a_fisys_long$CAARS_T_index_centred, na.rm = TRUE)
caars_low <- mean_caars - sd_caars
caars_high <- mean_caars + sd_caars

# Generate predictions: ADHD traits on x, facet by ShockRecipient, color by shockIntensity
preds_adhd_intens_recipient <- ggpredict(
  lmms$prq1a_fisys_time_ShockRecipient_WINNER,
  terms = c(
    sprintf("CAARS_T_index_centred [%.3f,%.3f]", caars_low, caars_high), 
    "shockIntensity [0,1]",
    "shockRecipient [0,1]"
  )
)

# Label shockIntensity for color
preds_adhd_intens_recipient$group <- factor(
  preds_adhd_intens_recipient$group,
  levels = c("0", "1"),
  labels = c("Low", "High")
)

# Label facets for shockRecipient
preds_adhd_intens_recipient$facet <- factor(
  preds_adhd_intens_recipient$facet,
  levels = c("0", "1"),
  labels = c("Other", "Self") # Adjust labels as appropriate
)

#label ADHD traits as ADHD +- 1SD from the mean
x_numeric <- as.numeric(as.character(preds_adhd_intens_recipient$x)) # Convert group to numeric for ordering
x_levels <- sort(unique(x_numeric)) # Get unique sorted values
preds_adhd_intens_recipient$x_numeric <- factor( # Assign labels: lower = "-1 SD", higher = "+1 SD"
  x_numeric,
  levels = x_levels,
  labels = c("-1 SD", "+1 SD")
)

# Plot
p_adhd_intens_Recipient <- ggplot(
  preds_adhd_intens_recipient,
  aes(x = x_numeric, y = predicted, color = group, group = group)
) +
  geom_line(aes(color = group), size = 1.2, position = position_dodge(width = 0.2)) +
  geom_point(aes(fill = group), size = 1.2, position = position_dodge(width = 0.2)) +
  geom_errorbar(
    aes(ymin = conf.low, ymax = conf.high),
    width = 0.1, position = position_dodge(width = 0.2)
  ) +
  facet_wrap(~facet, ncol = 2) +
  labs(
    x = "ADHD Traits (CAARS-S:S Index)",
    y = "Systolic blood pressure (mmHg)",
    color = "Shock Intensity",
    fill = "Shock Intensity",
    title = "Model-predicted fisys during the Anticipation phase\nby ADHD Traits, Shock Intensity, and recipient"
  ) +
  scale_color_manual(values = c(custom_palette[2], custom_palette[1]), labels = c("Low", "High")) +
  scale_fill_manual(values = c(custom_palette[2], custom_palette[1]), labels = c("Low", "High")) +
  theme_classic() +
  theme(
    plot.title = element_text(hjust = 0.5),
    panel.spacing = unit(1.5, "lines"),
    strip.background = element_blank(),
    strip.text = element_text(face = "bold")
  )

# Show figure
p_adhd_intens_Recipient

#save figure
ggsave(paste0(figures_folder,"/", "ant_fisys_index_intensity_recipient.png"), p_adhd_intens_Recipient, width = 6, height = 4, units = "in", dpi = 300, limitsize = FALSE)

```


### fidia timecourse

#### Prepare model data

```{r}
#Drop safe level from shockIntensity and exlude subjects without fisys data
mod_data_prq1a_fidia = droplevels(subset(df_all_trials_all_subjs, !is.na(mean_fidia_anticipation) & shockIntensity != 'safe' & subjectID %in% subjects_with_B2B ) )

#convert shockIntensity to numeric coding (1,0) to stop R fitting random effects separately for low and high
mod_data_prq1a_fidia$shockIntensity <- as.numeric(mod_data_prq1a_fidia$shockIntensity == "high")

# Calculate mean of each CAARS subscale
mean_CAARS_index <- mean(unlist(df_demographs[df_demographs$subjectID %in% subjects_with_B2B, "CAARS_T_index"]), na.rm = TRUE)
mean_CAARS_inatt <- mean(unlist(df_demographs[df_demographs$subjectID %in% subjects_with_B2B, "CAARS_T_inatt"]), na.rm = TRUE)
mean_CAARS_hyp <- mean(unlist(df_demographs[df_demographs$subjectID %in% subjects_with_B2B, "CAARS_T_hyp"]), na.rm = TRUE)
mean_CAARS_imp <- mean(unlist(df_demographs[df_demographs$subjectID %in% subjects_with_B2B, "CAARS_T_imp"]), na.rm = TRUE)
mean_CAARS_self <- mean(unlist(df_demographs[df_demographs$subjectID %in% subjects_with_B2B, "CAARS_T_self"]), na.rm = TRUE)

#Mean centre CAARS subscales
mod_data_prq1a_fidia$CAARS_T_index_centred <- mod_data_prq1a_fidia$CAARS_T_index - mean_CAARS_index
mod_data_prq1a_fidia$CAARS_T_inatt_centred <- mod_data_prq1a_fidia$CAARS_T_inatt - mean_CAARS_inatt
mod_data_prq1a_fidia$CAARS_T_hyp_centred <- mod_data_prq1a_fidia$CAARS_T_hyp - mean_CAARS_hyp
mod_data_prq1a_fidia$CAARS_T_imp_centred <- mod_data_prq1a_fidia$CAARS_T_imp - mean_CAARS_imp
mod_data_prq1a_fidia$CAARS_T_self_centred <- mod_data_prq1a_fidia$CAARS_T_imp - mean_CAARS_self

# Mean centre trialNo within subjects
mod_data_prq1a_fidia <- mod_data_prq1a_fidia %>%
  group_by(subjectID) %>%
  mutate(trialNo_centered = trialNo - mean(trialNo, na.rm = TRUE)) %>%
  ungroup()


#Convert data to long format for time window analyses
mod_data_prq1a_fidia_long = mod_data_prq1a_fidia %>%
  pivot_longer(
    cols = starts_with("fidia_anticipation_bin"),
    names_to = "time",
    names_prefix = "fidia_anticipation_bin",
    values_to = "fidia_value",
    values_drop_na = TRUE
  )

#Ensure time is in correct format (factor)
mod_data_prq1a_fidia_long$time <- factor(mod_data_prq1a_fidia_long$time, 
                                         levels = c(0, 1, 2, 3))
```

#### High vs Low shocks

Test whether ADHD-related differences in timecourse of fidia responses split as a function of Shock Intensity (high vs. low) varies significantly based on the Shock Recipient (self vs. other).

> Pre-registered model to aim for:
  
  Variable ~ CAARSADHD index*ShockIntensity*Time*ShockRecipient + shockIntensity*trialNo_centered + (trialNo_centered | Subject) + (shockIntensity + Time | Session / Subject)

```{r}

#Try fitting preregistered model using OLS
lmms$prq1a_fidia_time_ShockRecipient <- lmer(fidia_value ~ CAARS_T_index_centred*shockIntensity*time*shockRecipient
                                             + shockIntensity*trialNo_centered 
                                             + (trialNo_centered | subjectID) 
                                             + (shockIntensity + time | sessionID / subjectID), 
                                             data = mod_data_prq1a_fidia_long,
                                             control = lmerControl(optimizer = "bobyqa") )
#> Model fails to converge with bobyqa or Nelder_Mead optimiser

#drop slope-intercept correlations for shockIntensity and trialNo
lmms$prq1a_fidia_time_ShockRecipient_a <- lmer(fidia_value ~                                         CAARS_T_index_centred*shockIntensity*time*shockRecipient
                                               + shockIntensity*trialNo_centered 
                                               + (trialNo_centered || subjectID) 
                                               + (shockIntensity + time || sessionID) +  
                                                 (shockIntensity + time || subjectID),  
                                               data = mod_data_prq1a_fidia_long,
                                               control = lmerControl(optimizer = "Nelder_Mead") )
#> Model fails to converge

#Remove random slopes for trialNo_centered
lmms$prq1a_fidia_time_ShockRecipient_b <- lmer(fidia_value ~ CAARS_T_index_centred*shockIntensity*time*shockRecipient
                                               + shockIntensity*trialNo_centered 
                                               + (shockIntensity + time || sessionID) +  
                                                 (shockIntensity + time || subjectID), 
                                               data = mod_data_prq1a_fidia_long,
                                               control = lmerControl(optimizer = "Nelder_Mead") )
#> Model fails to converge


#Remove session-level slope for time
lmms$prq1a_fidia_time_ShockRecipient_c <- lmer(fidia_value ~ CAARS_T_index_centred*shockIntensity*time*shockRecipient
                                               + shockIntensity*trialNo_centered 
                                               + (shockIntensity || sessionID) +  
                                                 (shockIntensity + time || subjectID),  
                                               data = mod_data_prq1a_fidia_long,
                                               control = lmerControl(optimizer = "Nelder_Mead") )
#> Model fails to converge


#Remove session-level slope for shockIntensity
lmms$prq1a_fidia_time_ShockRecipient_d <- lmer(fidia_value ~ CAARS_T_index_centred*shockIntensity*time*shockRecipient 
                                               + shockIntensity*trialNo_centered 
                                               + (1 | sessionID) +
                                                 (shockIntensity + time || subjectID),  
                                               data = mod_data_prq1a_fidia_long,
                                               control = lmerControl(optimizer = "Nelder_Mead") )
#> Model fails to converge

#Remove subject-level slope for time
lmms$prq1a_fidia_time_ShockRecipient_e <- lmer(fidia_value ~ CAARS_T_index_centred*shockIntensity*time*shockRecipient 
                                               + shockIntensity*trialNo_centered 
                                               + (1 | sessionID) +
                                                 (shockIntensity || subjectID),  
                                               data = mod_data_prq1a_fidia_long,
                                               control = lmerControl(optimizer = "bobyqa") )
#> Model converges with bobyqa optimiser :D :D
check_predictions(lmms$prq1a_fidia_time_ShockRecipient_e)
check_outliers(lmms$prq1a_fidia_time_ShockRecipient_e)
check_model(lmms$prq1a_fidia_time_ShockRecipient_e)

#define winning model
lmms$prq1a_fidia_time_ShockRecipient_WINNER <- lmms$prq1a_fidia_time_ShockRecipient_e

```



##### Report results

```{r}

#Save model table
funcs$savelmmTable(lmms$prq1a_fidia_time_ShockRecipient_WINNER, 
                   paste0(figures_folder,"/", "prq1a_fidia_time_ShockRecipient.doc"))

#Save ANOVA table
anova_prq1a_fidia_time_ShockRecipient <- Anova(lmms$prq1a_fidia_time_ShockRecipient_WINNER, type = "3")
anova_prq1a_fidia_time_ShockRecipient$Term <- rownames(anova_prq1a_fidia_time_ShockRecipient)
# Move the 'Term' column to the first position
anova_prq1a_fidia_time_ShockRecipient <- anova_prq1a_fidia_time_ShockRecipient[, c("Term",  setdiff(names(anova_prq1a_fidia_time_ShockRecipient), "Term"))]
write_xlsx(as.data.frame(anova_prq1a_fidia_time_ShockRecipient), 
           paste0(figures_folder,"/", "anova_prq1a_fidia_time_ShockRecipient.xlsx"))


```

##### Figs

```{r}

# Calculate mean and SD of CAARS_T_index_centred
mean_caars <- 0 #mean of mean centred is zero!
sd_caars <- sd(subset(df_demographs,subjectID %in% subjects_with_B2B)$CAARS_T_index_centred, na.rm = TRUE)
caars_low <- mean_caars - sd_caars
caars_high <- mean_caars + sd_caars


#------------- Plot 4-way interaction

# Generate predictions for the interaction
preds_ant_fidia_adhd_intens_time_recipient <- ggpredict(
  lmms$prq1a_fidia_time_ShockRecipient_WINNER,
  terms = c(
    "time", 
    sprintf("CAARS_T_index_centred [%.3f,%.3f]", caars_low, caars_high), 
    "shockIntensity [0,1]", 
    "shockRecipient [0,1]"
  )
)

#label group as ADHD +- 1SD from the mean
group_numeric <- as.numeric(as.character(preds_ant_fidia_adhd_intens_time_recipient$group)) # Convert group to numeric for ordering
group_levels <- sort(unique(group_numeric)) # Get unique sorted values
preds_ant_fidia_adhd_intens_time_recipient$group <- factor( # Assign labels: lower = "-1 SD", higher = "+1 SD"
  group_numeric,
  levels = group_levels,
  labels = c("CAARS-S:S\nMean -1 SD", "CAARS-S:S\nMean +1 SD")
)

# Label facets for shockIntensity
preds_ant_fidia_adhd_intens_time_recipient$facet <- factor(preds_ant_fidia_adhd_intens_time_recipient$facet, levels = c("0", "1"), labels = c("Low", "High"))

# Label facets for shockRecipient
preds_ant_fidia_adhd_intens_time_recipient$panel <- factor(preds_ant_fidia_adhd_intens_time_recipient$panel, levels = c("0", "1"), labels = c("Other", "Self"))

#convert time to numeric
preds_ant_fidia_adhd_intens_time_recipient$time <- as.numeric(as.character(preds_ant_fidia_adhd_intens_time_recipient$x))

#Make figure + save
p_ant_fidia_adhd_intens_time_recipient <- funcs$plot_adhd_intens_time_recipient(preds_ant_fidia_adhd_intens_time_recipient,
save_destination = figures_folder,
fig_width = 7,
fig_height = 2.6,
phase = "Anticipation",
measure = "fidia", 
shockIntensityConds = c("Low", "High"))

#--- intense X time X recipient main effect and interactions

p_ant_fidia_time_intensity_recipient <- funcs$plot_intens_time_recipient(lmms$prq1a_fidia_time_ShockRecipient_WINNER,
                                  save_destination = figures_folder,
                                  fig_width = 5,
                                  fig_height = 2.6,
                                  phase = "Anticipation",
                                  measure = "fidia", 
                                  shockIntensityConds = c("Low", "High"))



#--- Plot CAARS_T_index * shock intensity * shock recipient interaction
p_ant_fidia_adhd_intens_recip <- funcs$plot_psychophys_adhd_intens_recip(lmms$prq1a_fidia_time_ShockRecipient_WINNER, 
                                                         figures_folder,
                                                         fig_width = 4,
                                                         fig_height = 2.6,
                                                         measure = "fidia",
                                                         phase = "ant")

#----- intens X recipient interaction
p_ant_fidia_intensity_recipient <- funcs$plot_intens_recipient(lmms$prq1a_fidia_time_ShockRecipient_WINNER,
                                  save_destination = figures_folder,
                                  fig_width = 4,
                                  fig_height = 2.6,
                                  phase = "Anticipation",
                                  measure = "fidia")

```

##### Main/simple effects

```{r}

#----Simple effects of CAARS index x shockIntensity within each shockRecipient condition

# Get the estimated marginal trends (slopes) of CAARS_T_index_centred by shockIntensity
emm_trends_index_intensity <- emtrends(
  lmms$prq1a_fidia_time_ShockRecipient_WINNER,
  specs = ~ shockIntensity,
  var = "CAARS_T_index_centred", 
  by = "shockRecipient",
  adjust = "holm",
  lmer.df = "satterthwaite"
)

# Test the difference in slopes between shockIntensity levels
pairs(emm_trends_index_intensity)


#Save emtrends
write_xlsx(as.data.frame(emm_trends_index_intensity), 
            paste0(figures_folder,"/", "ant_fidia_emmtrends_index_intensity.xlsx"))

#Save contrasts
write_xlsx(as.data.frame(pairs(emm_trends_index_intensity)), 
            paste0(figures_folder,"/", "contrasts_ant_fidia_emmtrends_index_intensity.xlsx"))


#----Plot emtrends figure
p_emtrends_ant_intens_recip_index <- ggplot(
  as.data.frame(emm_trends_index_intensity), 
  aes(
    x = factor(shockRecipient), 
    y = CAARS_T_index_centred.trend, 
    color = factor(shockIntensity), 
    group = factor(shockIntensity)
  )
) +
  geom_line(size = 1.2, position = position_dodge(width = 0.2)) +
  geom_point(size = 3, position = position_dodge(width = 0.2)) +
  geom_errorbar(
    aes(
      ymin = CAARS_T_index_centred.trend - SE, 
      ymax = CAARS_T_index_centred.trend + SE
    ),
    width = 0.1, 
    position = position_dodge(width = 0.2)
  ) +
  labs(
    x = "Shock Recipient",
    y = "Estimated Slope of CAARS-S:S ADHD index",
    color = "Shock Intensity",
    title = "Estimated Marginal Trends of CAARS-S:S ADHD index\nby Shock Intensity and Recipient"
  ) +
  scale_x_discrete(labels = c("other", "self")) +
  scale_color_manual(values = c(custom_palette[2], custom_palette[1]), labels = c("Low", "High")) +
  theme_classic()

p_emtrends_ant_intens_recip_index

#save figure
ggsave(paste0(figures_folder,"/", "emtrends_ant_intens_recip_index.png"), p_emtrends_ant_intens_recip_index, width = 6, height = 4, units = "in", dpi = 300, limitsize = FALSE)

#---Plot model predicted values figure

# Calculate mean and SD of CAARS_T_index_centred
mean_caars <- mean(mod_data_prq1a_fidia_long$CAARS_T_index_centred, na.rm = TRUE)
sd_caars <- sd(mod_data_prq1a_fidia_long$CAARS_T_index_centred, na.rm = TRUE)
caars_low <- mean_caars - sd_caars
caars_high <- mean_caars + sd_caars

# Generate predictions: ADHD traits on x, facet by ShockRecipient, color by shockIntensity
preds_adhd_intens_recipient <- ggpredict(
  lmms$prq1a_fidia_time_ShockRecipient_WINNER,
  terms = c(
    sprintf("CAARS_T_index_centred [%.3f,%.3f]", caars_low, caars_high), 
    "shockIntensity [0,1]",
    "shockRecipient [0,1]"
  )
)

# Label shockIntensity for color
preds_adhd_intens_recipient$group <- factor(
  preds_adhd_intens_recipient$group,
  levels = c("0", "1"),
  labels = c("Low", "High")
)

# Label facets for shockRecipient
preds_adhd_intens_recipient$facet <- factor(
  preds_adhd_intens_recipient$facet,
  levels = c("0", "1"),
  labels = c("Other", "Self") # Adjust labels as appropriate
)

#label ADHD traits as ADHD +- 1SD from the mean
x_numeric <- as.numeric(as.character(preds_adhd_intens_recipient$x)) # Convert group to numeric for ordering
x_levels <- sort(unique(x_numeric)) # Get unique sorted values
preds_adhd_intens_recipient$x_numeric <- factor( # Assign labels: lower = "-1 SD", higher = "+1 SD"
  x_numeric,
  levels = x_levels,
  labels = c("-1 SD", "+1 SD")
)

# Plot
p_adhd_intens_Recipient <- ggplot(
  preds_adhd_intens_recipient,
  aes(x = x_numeric, y = predicted, color = group, group = group)
) +
  geom_line(aes(color = group), size = 1.2, position = position_dodge(width = 0.2)) +
  geom_point(aes(fill = group), size = 1.2, position = position_dodge(width = 0.2)) +
  geom_errorbar(
    aes(ymin = conf.low, ymax = conf.high),
    width = 0.1, position = position_dodge(width = 0.2)
  ) +
  facet_wrap(~facet, ncol = 2) +
  labs(
    x = "ADHD Traits (CAARS-S:S Index)",
    y = "Diastolic blood pressure (mmHg)",
    color = "Shock Intensity",
    fill = "Shock Intensity",
    title = "Model-predicted fidia during the Anticipation phase\nby ADHD Traits, Shock Intensity, and recipient"
  ) +
  scale_color_manual(values = c(custom_palette[2], custom_palette[1]), labels = c("Low", "High")) +
  scale_fill_manual(values = c(custom_palette[2], custom_palette[1]), labels = c("Low", "High")) +
  theme_classic() +
  theme(
    plot.title = element_text(hjust = 0.5),
    panel.spacing = unit(1.5, "lines"),
    strip.background = element_blank(),
    strip.text = element_text(face = "bold")
  )

# Show figure
p_adhd_intens_Recipient

#save figure
ggsave(paste0(figures_folder,"/", "ant_fidia_index_intensity_recipient.png"), p_adhd_intens_Recipient, width = 6, height = 4, units = "in", dpi = 300, limitsize = FALSE)





#---- Shock intensity x shock recipient interaction

#calculate emmeans
emm_ant_fidia_intensity_X_recipient <- emmeans(
  lmms$prq1a_fidia_time_ShockRecipient_WINNER, 
  ~  shockIntensity | shockRecipient,
  
)

#calculate paired contrasts
contrast_emm_ant_fidia_intensity_X_recipient <- contrast(emm_ant_fidia_intensity_X_recipient, 
interaction = "pairwise", 
  adjust = "holm",
  lmer.df = "satterthwaite"   # Use Satterthwaite's df
  )
  
# View results
print(contrast_emm_ant_fidia_intensity_X_recipient)

# Save
write_xlsx(as.data.frame(emm_ant_fidia_intensity_X_recipient), 
           paste0(figures_folder,"/", "emm_ant_fidia_intensity_X_recipient.xlsx"))

# Save contrasts
write_xlsx(as.data.frame(contrast_emm_ant_fidia_intensity_X_recipient), 
           paste0(figures_folder,"/", "contrasts_emm_ant_fidia_intensity_X_recipient.xlsx"))

```

#----

## PRQ 1b - response phase analyses

Test whether ADHD traits are associated with the magnitude of autonomic reactions:
  b.	immediately following painful electric shocks

### hr timecourse

#### Prepare model data

```{r}
#Drop safe level from shockIntensity and exlude subjects without hr data
mod_data_prq1b_hr = droplevels(subset(df_all_trials_all_subjs, !is.na(mean_hr_response) 
                                      & shockIntensity != 'safe' 
                                      & faultyShock == 0
                                      & subjectID %in% subjects_with_HR ) )

#convert shockIntensity to numeric coding (1,0) to stop R fitting random effects separately for low and high
mod_data_prq1b_hr$shockIntensity <- as.numeric(mod_data_prq1b_hr$shockIntensity == "high")

# Calculate means for each CAARS subscale
mean_CAARS_index <- mean(unlist(df_demographs[df_demographs$subjectID %in% subjects_with_HR, "CAARS_T_index"]), na.rm = TRUE)
mean_CAARS_inatt <- mean(unlist(df_demographs[df_demographs$subjectID %in% subjects_with_HR, "CAARS_T_inatt"]), na.rm = TRUE)
mean_CAARS_hyp <- mean(unlist(df_demographs[df_demographs$subjectID %in% subjects_with_HR, "CAARS_T_hyp"]), na.rm = TRUE)
mean_CAARS_imp <- mean(unlist(df_demographs[df_demographs$subjectID %in% subjects_with_HR, "CAARS_T_imp"]), na.rm = TRUE)
mean_CAARS_self <- mean(unlist(df_demographs[df_demographs$subjectID %in% subjects_with_HR, "CAARS_T_self"]), na.rm = TRUE)

# Mean-centre each CAARS subscale
mod_data_prq1b_hr$CAARS_T_index_centred <- mod_data_prq1b_hr$CAARS_T_index - mean_CAARS_index
mod_data_prq1b_hr$CAARS_T_inatt_centred <- mod_data_prq1b_hr$CAARS_T_inatt - mean_CAARS_inatt
mod_data_prq1b_hr$CAARS_T_hyp_centred <- mod_data_prq1b_hr$CAARS_T_hyp - mean_CAARS_hyp
mod_data_prq1b_hr$CAARS_T_imp_centred <- mod_data_prq1b_hr$CAARS_T_imp - mean_CAARS_imp
mod_data_prq1b_hr$CAARS_T_self_centred <- mod_data_prq1b_hr$CAARS_T_self - mean_CAARS_self
# Mean centre trialNo within subjects
mod_data_prq1b_hr <- mod_data_prq1b_hr %>%
  group_by(subjectID) %>%
  mutate(trialNo_centered = trialNo - mean(trialNo, na.rm = TRUE)) %>%
  ungroup()


#Convert data to long format for time window analyses
mod_data_prq1b_hr_long = mod_data_prq1b_hr %>%
  pivot_longer(
    cols = starts_with("hr_response_bin"),
    names_to = "time",
    names_prefix = "hr_response_bin",
    values_to = "hr_value",
    values_drop_na = TRUE
  )

#Ensure time is in correct format (factor)
mod_data_prq1b_hr_long$time <- factor(mod_data_prq1b_hr_long$time, 
                                      levels = c(0, 1, 2, 3))
```



#### High vs Low shocks

Test whether ADHD-related differences in timecourse of hr responses split as a function of Shock Intensity (high vs. low) varies significantly based on the Shock Recipient (self vs. other).

> Pre-registered model to aim for:
  
  Variable ~ CAARSADHD index*ShockIntensity*Time*ShockRecipient + shockIntensity*trialNo_centered + (trialNo_centered | Subject) + (shockIntensity + Time | Session / Subject)

```{r}

#Try fitting preregistered model using OLS
lmms$prq1b_hr_time_ShockRecipient <- lmer(hr_value ~ CAARS_T_index_centred*shockIntensity*time*shockRecipient
                                          + shockIntensity*trialNo_centered 
                                          + (trialNo_centered | subjectID) 
                                          + (shockIntensity + time | sessionID / subjectID), 
                                          data = mod_data_prq1b_hr_long,
                                          control = lmerControl(optimizer = "bobyqa") )
#> Model fails to converge with bobyqa or Nelder_Mead optimiser

#drop slope-intercept correlations for shockIntensity and trialNo
lmms$prq1b_hr_time_ShockRecipient_a <- lmer(hr_value ~                                         CAARS_T_index_centred*shockIntensity*time*shockRecipient
                                            + shockIntensity*trialNo_centered 
                                            + (trialNo_centered || subjectID) 
                                            + (shockIntensity + time || sessionID) +  
                                              (shockIntensity + time || subjectID),  
                                            data = mod_data_prq1b_hr_long,
                                            control = lmerControl(optimizer = "Nelder_Mead") )
#> Model fails to converge

#Remove random slopes for trialNo_centered
lmms$prq1b_hr_time_ShockRecipient_b <- lmer(hr_value ~ CAARS_T_index_centred*shockIntensity*time*shockRecipient
                                            + shockIntensity*trialNo_centered 
                                            + (shockIntensity + time || sessionID) +  
                                              (shockIntensity + time || subjectID), 
                                            data = mod_data_prq1b_hr_long,
                                            control = lmerControl(optimizer = "Nelder_Mead") )
#> Model fails to converge


#Remove session-level slope for time
lmms$prq1b_hr_time_ShockRecipient_c <- lmer(hr_value ~ CAARS_T_index_centred*shockIntensity*time*shockRecipient
                                            + shockIntensity*trialNo_centered 
                                            + (shockIntensity || sessionID) +  
                                              (shockIntensity + time || subjectID),  
                                            data = mod_data_prq1b_hr_long,
                                            control = lmerControl(optimizer = "Nelder_Mead") )
#> Model fails to converge


#Remove session-level slope for shockIntensity
lmms$prq1b_hr_time_ShockRecipient_d <- lmer(hr_value ~ CAARS_T_index_centred*shockIntensity*time*shockRecipient 
                                            + shockIntensity*trialNo_centered 
                                            + (1 | sessionID) +
                                              (shockIntensity + time || subjectID),  
                                            data = mod_data_prq1b_hr_long,
                                            control = lmerControl(optimizer = "Nelder_Mead") )
#> Model fails to converge

#Remove subject-level slope for time
lmms$prq1b_hr_time_ShockRecipient_e <- lmer(hr_value ~ CAARS_T_index_centred*shockIntensity*time*shockRecipient 
                                            + shockIntensity*trialNo_centered 
                                            + (1 | sessionID) +
                                              (shockIntensity || subjectID),  
                                            data = mod_data_prq1b_hr_long,
                                            control = lmerControl(optimizer = "bobyqa") )
#> Model converges with bobyqa optimiser :D :D
check_predictions(lmms$prq1b_hr_time_ShockRecipient_e)
check_outliers(lmms$prq1b_hr_time_ShockRecipient_e)
check_model(lmms$prq1b_hr_time_ShockRecipient_e)

#define winning model
lmms$prq1b_hr_time_ShockRecipient_WINNER <- lmms$prq1b_hr_time_ShockRecipient_e

#Anova
Anova(lmms$prq1b_hr_time_ShockRecipient_WINNER, type = "3")

```

##### Report results

```{r}

#Save model table
funcs$savelmmTable(lmms$prq1b_hr_time_ShockRecipient_WINNER, 
                   paste0(figures_folder,"/", "prq1b_hr_time_ShockRecipient.doc"))

#Save ANOVA table
anova_prq1b_hr_time_ShockRecipient <- Anova(lmms$prq1b_hr_time_ShockRecipient_WINNER, type = "3")
anova_prq1b_hr_time_ShockRecipient <- as.data.frame(anova_prq1b_hr_time_ShockRecipient) #convert to df
anova_prq1b_hr_time_ShockRecipient <- cbind(rownames(anova_prq1b_hr_time_ShockRecipient), anova_prq1b_hr_time_ShockRecipient) #add rownames
write_xlsx(anova_prq1b_hr_time_ShockRecipient, 
           paste0(figures_folder,"/", "anova_prq1b_hr_time_ShockRecipient.xlsx")) #save

```

##### Figs

```{r}

# Calculate mean and SD of CAARS_T_index_centred
mean_caars <- 0 #mean of mean centred is zero!
sd_caars <- sd(subset(df_demographs,subjectID %in% subjects_with_HR)$CAARS_T_index_centred, na.rm = TRUE)
caars_low <- mean_caars - sd_caars
caars_high <- mean_caars + sd_caars


#------------- Plot 4-way interaction

# Generate predictions for the interaction
preds_response_hr_adhd_intens_time_recipient <- ggpredict(
  lmms$prq1b_hr_time_ShockRecipient_WINNER,
  terms = c(
    "time", 
    sprintf("CAARS_T_index_centred [%.3f,%.3f]", caars_low, caars_high), 
    "shockIntensity [0,1]", 
    "shockRecipient [0,1]"
  )
)

#label group as ADHD +- 1SD from the mean
group_numeric <- as.numeric(as.character(preds_response_hr_adhd_intens_time_recipient$group)) # Convert group to numeric for ordering
group_levels <- sort(unique(group_numeric)) # Get unique sorted values
preds_response_hr_adhd_intens_time_recipient$group <- factor( # Assign labels: lower = "-1 SD", higher = "+1 SD"
  group_numeric,
  levels = group_levels,
  labels = c("CAARS-S:S\nMean -1 SD", "CAARS-S:S\nMean +1 SD")
)

# Label facets for shockIntensity
preds_response_hr_adhd_intens_time_recipient$facet <- factor(preds_response_hr_adhd_intens_time_recipient$facet, levels = c("0", "1"), labels = c("Low", "High"))

# Label facets for shockRecipient
preds_response_hr_adhd_intens_time_recipient$panel <- factor(preds_response_hr_adhd_intens_time_recipient$panel, levels = c("0", "1"), labels = c("Other", "Self"))

#convert time to numeric
preds_response_hr_adhd_intens_time_recipient$time <- as.numeric(as.character(preds_response_hr_adhd_intens_time_recipient$x))

#Make figure + save
p_response_hr_adhd_intens_time_recipient <- funcs$plot_adhd_intens_time_recipient(preds_response_hr_adhd_intens_time_recipient,                                                                save_destination = figures_folder,                                                               fig_width = 7,                                                              fig_height = 2.6,                                                               phase = "Response",                                                      measure = "HR", 
shockIntensityConds = c("Low", "High"))




#-----Main effects of ADHD traits
preds_response_hr_adhd <- ggpredict(
  lmms$prq1b_hr_time_ShockRecipient_WINNER,
  terms ="CAARS_T_index_centred")

p_response_hr_index <- funcs$plot_linear_hr(pred_data = preds_response_hr_adhd, 
                         x_label = "CAARS-S:S Index (centred)",
                         y_label = "Heart rate (bpm)",
                         phase = "response",
                         ylims = c(65,92))

#--ADHD*shockIntensity*time

# # Calculate mean and SD of CAARS_T_index_centred
# mean_caars <- 0 #mean of mean centred is zero!
# sd_caars <- sd(subset(df_demographs,subjectID %in% subjects_with_HR)$CAARS_T_index_centred, na.rm = TRUE)
# caars_low <- mean_caars - sd_caars
# caars_high <- mean_caars + sd_caars
# 
# # Generate predictions for the interaction
# preds_response_hr_adhd_intens_time <- ggpredict(
#   lmms$prq1b_hr_time_ShockRecipient_WINNER,
#   terms = c(
#     "time", 
#     sprintf("CAARS_T_index_centred [%.3f,%.3f]", caars_low, caars_high), 
#     "shockIntensity [0,1]"
#   )
# )
# 
# # Convert group to numeric for ordering
# group_numeric <- as.numeric(as.character(preds_response_hr_adhd_intens_time$group))
# 
# # Get unique sorted values
# group_levels <- sort(unique(group_numeric))
# 
# # Assign labels: lower = "-1 SD", higher = "+1 SD"
# preds_response_hr_adhd_intens_time$group <- factor(
#   group_numeric,
#   levels = group_levels,
#   labels = c("CAARS-S:S\nMean -1 SD", "CAARS-S:S\nMean +1 SD")
# )
# 
# #convert time to numeric
# preds_response_hr_adhd_intens_time$time <- as.numeric(as.character(preds_response_hr_adhd_intens_time$x))
# 
# 
# # Label facets for shockIntensity
# preds_response_hr_adhd_intens_time$facet <- factor(preds_response_hr_adhd_intens_time$facet, levels = c("0", "1"),
#                                        labels = c("Low", "High"))
# 
# #Make figure and save
# p_response_hr_adhd_intens_time <- funcs$plot_adhd_intens_time(preds_response_hr_adhd_intens_time,
#                                   save_destination = figures_folder,
#                                   fig_width = 5,
#                                   fig_height = 2.6,
#                                   phase = "Response",
#                                   measure = "HR")

#----- intense X time X recipient main effect and interactions
p_response_hr_time_intensity_recipient <- funcs$plot_intens_time_recipient(lmms$prq1b_hr_time_ShockRecipient_WINNER,
                                  save_destination = figures_folder,
                                  fig_width = 5,
                                  fig_height = 2.6,
                                  phase = "Response",
                                  measure = "HR", 
                                  shockIntensityConds = c("Low", "High"))


#--- Plot CAARS_T_index * shock intensity * shock recipient interaction
p_response_hr_adhd_intens_recip <- funcs$plot_psychophys_adhd_intens_recip(lmms$prq1b_hr_time_ShockRecipient_WINNER, 
                                                         figures_folder,
                                                         fig_width = 3.4,
                                                         fig_height = 2.6,
                                                         measure = "hr",
                                                         phase = "response")


#-----Main effects of ADHD traits, split by shock intensity
# preds_response_hr_adhd <- ggpredict(
#   lmms$prq1b_hr_time_ShockRecipient_WINNER,
#   terms = c(
#     "CAARS_T_index_centred",
#     "shockIntensity [0,1]"
#   )
# )
# 
# #label group as High/Low
# group_numeric <- as.numeric(as.character(preds_response_hr_adhd$group)) # Convert group to numeric for ordering
# group_levels <- sort(unique(group_numeric)) # Get unique sorted values
# preds_response_hr_adhd$group <- factor( # Assign labels
#   group_numeric,
#   levels = group_levels,
#   labels = c("Low", "High")
# )
# 
# 
# # Plot
#   p_hr_index <- ggplot(preds_response_hr_adhd, aes(x = x, y = predicted, color = group, fill = group)) +
#     geom_line(size = 1.2) +
#     geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = 0.15, colour = NA) +
#     labs(
#       x = "CAARS-S:S Index (centred)",
#       y = "Heart rate (bpm)",
#       color = "Shock\nIntensity",
#       fill = "Shock\nIntensity"
#       #title = "CAARS Index × Shock Intensity x Shock Recipient"
#     ) +
#     scale_color_manual(values = c(custom_palette[2], custom_palette[1])) +
#     scale_fill_manual(values = c(custom_palette[2], custom_palette[1])) +
#     #coord_cartesian(ylim = y_limits) +
#     theme_classic() +
#     theme(
#       text = element_text(size = 14),
#       plot.title = element_text(hjust = 0.5, margin = margin(b = 6)),
#       panel.spacing = unit(0.5, "lines"),
#       strip.background = element_blank(),
#       strip.text = element_text(face = "bold"),
#       plot.margin = margin(0, 0, 0, 0),
#       legend.position = "right",
#       legend.box.margin = margin(0, 0, 0, 0),
#       legend.margin = margin(0, 0, 0, 0)
#     )
#   
#   # Show figure
#   p_hr_index
#   
#   #save figure
#     save_filepath = paste0(figures_folder,"/", "response", "_", "hr", "_adhd_X_intens.png")
#   
#   ggsave(save_filepath, p_hr_index, height = 2.6, width = 3.4, units = "in", dpi = 300, limitsize = FALSE)

```

##### Main/simple effects

```{r}

#----Interaction of CAARS index x shock intensity x time within each shockRecipient condition

# Get the estimated marginal trends (slopes) of CAARS_T_index_centred by shockIntensity
emm_trends_index_intensity_time_recip <- emtrends(
  lmms$prq1b_hr_time_ShockRecipient_WINNER,
  specs = ~ shockIntensity * time,
  var = "CAARS_T_index_centred", 
  by = "shockRecipient",
  adjust = "holm",
  lmer.df = "satterthwaite"
)

#create df with selected contrasts of interest
contrasts_emm_trends_index_intensity_time_recip <- as.data.frame(pairs(emm_trends_index_intensity_time_recip, adjust = "none"))
contrasts_emm_trends_index_intensity_time_recip <- contrasts_emm_trends_index_intensity_time_recip[ c(3,5,7,31,33,35), ]
contrasts_emm_trends_index_intensity_time_recip$p.value <- p.adjust(contrasts_emm_trends_index_intensity_time_recip$p.value, 
                                                                  method = "holm") #Holm-bonferroni adjusted p vals

#Save trends
write_xlsx(as.data.frame(emm_trends_index_intensity_time_recip), 
            paste0(figures_folder,"/", "trends_response_hr_emmtrends_index_intensity_time_recip.xlsx"))

#Save contrasts
write_xlsx(as.data.frame(contrasts_emm_trends_index_intensity_time_recip), 
            paste0(figures_folder,"/", "contrasts_response_hr_emmtrends_index_intensity_time_recip.xlsx"))


#----Simple effects of shockIntensity × time within each shockRecipient condition

# Define emms for shockIntensity * time within each level of shock recipient
emm_response_hr_intens_X_time <- emmeans(
  lmms$prq1b_hr_time_ShockRecipient_WINNER,
  ~ shockIntensity * time | shockRecipient ,
  adjust = "holm",
  lmer.df = "satterthwaite"
)

# Define contrast coefficients for interaction (averaged over all timepoints)
# For 2 levels of shockIntensity and 4 levels of time_window,
# the interaction contrast tests if the difference (High - Low)
# differs across timepoints within each recipient.

#Check order of conditions
#emm_int

# This is a "joint" test, not pairwise differences at each timepoint.
custom_contrast <- list(
  "shockIntensity × time_window interaction" = c(-1, 1, -1, 1, -1, 1, -1, 1) / 4
)

# Apply the contrast, with "by = shockRecipient"
cont_int <- contrast(emm_response_hr_intens_X_time, 
                     custom_contrast, 
                     adjust = "holm", 
                    lmer.df = "satterthwaite",
                     by = "shockRecipient")

# Summary results: one joint test per recipient
summary(cont_int)


# Test interaction contrasts (pairwise comparisons for time) separately for each shockRecipient
contrast_results_emm_response_intens_X_time <- contrast(
  emm_response_hr_intens_X_time, 
  interaction = "pairwise", 
  adjust = "holm",
  lmer.df = "satterthwaite"   # Use Satterthwaite's df
)
# View results
print(contrast_results_emm_response_intens_X_time)

# save emmeans
write_xlsx(as.data.frame(emm_response_hr_intens_X_time), 
           paste0(figures_folder,"/", "emm_response_hr_intens_X_time.xlsx"))

# Save contrasts
write_xlsx(as.data.frame(contrast_results_emm_response_intens_X_time), 
           paste0(figures_folder,"/", "contrast_results_response_emm_intens_X_time.xlsx"))

```

###### Unpack 4-way - emms

```{r}

#---- Work out what is driving 4-way interaction

#1. Simple effects of CAARS index x shockIntensity x time within each shockRecipient condition

# Get the estimated marginal trends (slopes) of CAARS_T_index_centred by shockIntensity
emt_index_time_intensity <- emtrends(
  lmms$prq1b_hr_time_ShockRecipient_WINNER,
  specs = ~ shockIntensity*time | shockRecipient,
  var = "CAARS_T_index_centred", 
  adjust = "holm",
  lmer.df = "satterthwaite"
)

# This is a "joint" test, not pairwise differences at each timepoint.
custom_contrast <- list(
  "CAARS x shockIntensity × time_window" = c(-1, 1, -1, 1, -1, 1, -1, 1) / 4
)

# Apply the contrast, with "by = shockRecipient"
cont_int <- contrast(emt_index_time_intensity, 
                     custom_contrast, 
                     adjust = "holm", 
                    lmer.df = "satterthwaite",
                     by = "shockRecipient")

# Summary results: one joint test per recipient
summary(cont_int)




# 2. Estimate slopes of CAARS_T_index_centred at each 3-way combination,
#    separately by each timepoint
emm_trends_timewise <- emtrends(
  lmms$prq1b_hr_time_ShockRecipient_WINNER,
  var = "CAARS_T_index_centred",
  specs = ~ shockIntensity * shockRecipient | time,
  adjust = "holm",
  lmer.df = "satterthwaite"
)

# 3. Contrast these slopes: i.e., test the shockIntensity*shockRecipient
#    interaction on the ADHD slope, separately at each timepoint
# This is the explicit test of the three-way ADH trait * S * R interaction at each T
interaction_contrasts <- contrast(
  emm_trends_timewise,
  interaction = c("pairwise", "pairwise"), # pairwise trt.vs.ctrl1 for S and for R
  by = "time", 
  adjust = "holm"
)

# 4. View the results: one interaction contrast per timepoint
summary(interaction_contrasts, infer = TRUE, adjust = "holm")

#>> This tells us there is a significant CAARS * shockIntensity * shockRecipient interaction 
#at timepoint 1 and 2 but not 0 or 3


#6. Prepare data for plotting

#Copy predictions for 4-way interaction
preds_4way_copy <- preds_response_hr_adhd_intens_time_recipient

#Reformat levels of group
preds_4way_copy$group <- factor( # Assign labels
  group_numeric,
  levels = group_levels,
  labels = c("-1SD", "+1SD")
)


# 8. test the ADHD*shockIntensity interaction at each timepoint and recipient
interaction_contrasts_time_recip <- contrast(
  emm_trends_timewise,
  interaction = c("pairwise", "pairwise"), # pairwise trt.vs.ctrl1 for S and for R
  by = c("time", "shockRecipient"), 
  adjust = "holm"
)

# 8. View the results: one interaction contrast per timepoint
summary(interaction_contrasts_time_recip, infer = TRUE, adjust = "holm")





```
###### Unpack 4-way fig

```{r}
#Convert to df
preds_4way_copy <- as.data.frame(preds_4way_copy)

#Calculate difference scores with 95% CI
diff_df <- preds_4way_copy %>%
  dplyr::select(time, group, facet, panel, predicted, conf.low, conf.high) %>%
  pivot_wider(
    names_from = "facet",
    values_from = c("predicted", "conf.low", "conf.high")
  ) %>%
  mutate(
    diff_predicted = predicted_High - predicted_Low,
    diff_conf_low = conf.low_High - conf.high_Low,
    diff_conf_high = conf.high_High - conf.low_Low
  )

#Create figure
p_diff <- ggplot(diff_df, aes(x = time, y = diff_predicted, colour = group)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_ribbon(
    aes(ymin = diff_conf_low, ymax = diff_conf_high, fill = group),
    alpha = 0.2, colour = NA
  ) +
  scale_color_manual(values = c(custom_palette[5], custom_palette[6])) +
  scale_fill_manual(values = c(custom_palette[5], custom_palette[6])) +
  scale_x_continuous(breaks = 0:3, labels = c("BL", "1", "2", "3")) +
  facet_wrap(~panel, nrow = 1) +
  labs(
    x = "Time window",
    y = "Difference in heart rate\n(high shock – low shock)",
    colour = "CAARS-S:S\nADHD index",
    fill = "CAARS-S:S\nADHD index"
  ) +
  theme_classic() + 
  theme_classic(base_size = 12) +
  theme(
    plot.title = element_text(hjust = 0.5, margin = margin(b = 2)),
    panel.spacing = unit(0.1, "lines"),
    strip.background = element_blank(),
    strip.text = element_text(face = "bold"),
    plot.margin = margin(0, 0, 0, 0, "cm"),
    legend.position = "right"
  )

#save figure
save_file_path = paste0(figures_folder,"/", 
                        "HR", "_", 
                        "Response", "_time_intes_recipient.png")
ggsave(save_file_path, p_diff, 
       width = 5, 
       height = 2.6, 
       units = "in", dpi = 300, limitsize = FALSE)


```






### SCL timecourse

##### Prepare model data

```{r}
#Drop safe level from shockIntensity and exclude subjects without scl data
mod_data_prq1b_scl = droplevels(subset(df_all_trials_all_subjs, !is.na(mean_scl_response) 
                                      & shockIntensity != 'safe' 
                                      & faultyShock == 0
                                      & subjectID %in% subjects_with_EDA ) )

#convert shockIntensity to numeric coding (1,0) to stop R fitting random effects separately for low and high
mod_data_prq1b_scl$shockIntensity <- as.numeric(mod_data_prq1b_scl$shockIntensity == "high")

# Calculate mean of each CAARS subscale
mean_CAARS_index <- mean(unlist(df_demographs[df_demographs$subjectID %in% subjects_with_EDA, "CAARS_T_index"]), na.rm = TRUE)
mean_CAARS_inatt <- mean(unlist(df_demographs[df_demographs$subjectID %in% subjects_with_EDA, "CAARS_T_inatt"]), na.rm = TRUE)
mean_CAARS_hyp <- mean(unlist(df_demographs[df_demographs$subjectID %in% subjects_with_EDA, "CAARS_T_hyp"]), na.rm = TRUE)
mean_CAARS_imp <- mean(unlist(df_demographs[df_demographs$subjectID %in% subjects_with_EDA, "CAARS_T_imp"]), na.rm = TRUE)
mean_CAARS_self <- mean(unlist(df_demographs[df_demographs$subjectID %in% subjects_with_EDA, "CAARS_T_self"]), na.rm = TRUE)

#Mean centre CAARS subscales
mod_data_prq1b_scl$CAARS_T_index_centred <- mod_data_prq1b_scl$CAARS_T_index - mean_CAARS_index
mod_data_prq1b_scl$CAARS_T_inatt_centred <- mod_data_prq1b_scl$CAARS_T_inatt - mean_CAARS_inatt
mod_data_prq1b_scl$CAARS_T_hyp_centred <- mod_data_prq1b_scl$CAARS_T_hyp - mean_CAARS_hyp
mod_data_prq1b_scl$CAARS_T_imp_centred <- mod_data_prq1b_scl$CAARS_T_imp - mean_CAARS_imp
mod_data_prq1b_scl$CAARS_T_self_centred <- mod_data_prq1b_scl$CAARS_T_self - mean_CAARS_self

# Mean centre trialNo within subjects
mod_data_prq1b_scl <- mod_data_prq1b_scl %>%
  group_by(subjectID) %>%
  mutate(trialNo_centered = trialNo - mean(trialNo, na.rm = TRUE)) %>%
  ungroup()


#Convert data to long format for time window analyses
mod_data_prq1b_scl_long = mod_data_prq1b_scl %>%
  pivot_longer(
    cols = starts_with("scl_response_bin"),
    names_to = "time",
    names_prefix = "scl_response_bin",
    values_to = "scl_value",
    values_drop_na = TRUE
  )

#Ensure time is in correct format (factor)
mod_data_prq1b_scl_long$time <- factor(mod_data_prq1b_scl_long$time, 
                                      levels = c(0, 1, 2, 3))
```

##### High vs Low shocks

Test whether ADHD-related differences in timecourse of SCL responses split as a function of Shock Intensity (high vs. low) varies significantly based on the Shock Recipient (self vs. other).

> Pre-registered model to aim for:
  
  Variable ~ CAARSADHD index*ShockIntensity*Time*ShockRecipient + shockIntensity*trialNo_centered + (trialNo_centered | Subject) + (shockIntensity + Time | Session / Subject)

```{r}


#Try fitting preregistered model using OLS
lmms$prq1b_scl_time_ShockRecipient <- lmer(scl_value ~ CAARS_T_index_centred*shockIntensity*time*shockRecipient
                                           + shockIntensity*trialNo_centered 
                                           + (trialNo_centered | subjectID) 
                                           + (shockIntensity + time | sessionID / subjectID), 
                                           data = mod_data_prq1b_scl_long,
                                           control = lmerControl(optimizer = "bobyqa") )
#> Model fails to converge with bobyqa or Nelder_Mead optimiser

#drop slope-intercept correlations for shockIntensity and trialNo
lmms$prq1b_scl_time_ShockRecipient_a <- lmer(scl_value ~                                         CAARS_T_index_centred*shockIntensity*time*shockRecipient
                                             + shockIntensity*trialNo_centered 
                                             + (trialNo_centered || subjectID) 
                                             + (shockIntensity + time || sessionID) +  
                                               (shockIntensity + time || subjectID),  
                                             data = mod_data_prq1b_scl_long,
                                             control = lmerControl(optimizer = "bobyqa") )
#> Model fails to converge

#Remove random slopes for trialNo_centered
lmms$prq1b_scl_time_ShockRecipient_b <- lmer(scl_value ~ CAARS_T_index_centred*shockIntensity*time*shockRecipient
                                             + shockIntensity*trialNo_centered 
                                             + (shockIntensity + time || sessionID) +  
                                               (shockIntensity + time || subjectID), 
                                             data = mod_data_prq1b_scl_long,
                                             control = lmerControl(optimizer = "Nelder_Mead") )
#> Model fails to converge


#Remove session-level slope for time
lmms$prq1b_scl_time_ShockRecipient_c <- lmer(scl_value ~ CAARS_T_index_centred*shockIntensity*time*shockRecipient
                                             + shockIntensity*trialNo_centered 
                                             + (shockIntensity || sessionID) +  
                                               (shockIntensity + time || subjectID),  
                                             data = mod_data_prq1b_scl_long,
                                             control = lmerControl(optimizer = "Nelder_Mead") )
#> Model fails to converge


#Remove session-level slope for shockIntensity
lmms$prq1b_scl_time_ShockRecipient_d <- lmer(scl_value ~ CAARS_T_index_centred*shockIntensity*time*shockRecipient 
                                             + shockIntensity*trialNo_centered 
                                             + (1 | sessionID) +
                                               (shockIntensity + time || subjectID),  
                                             data = mod_data_prq1b_scl_long,
                                             control = lmerControl(optimizer = "Nelder_Mead") )
#> Model fails to converge

#Remove subject-level slope for time
lmms$prq1b_scl_time_ShockRecipient_e <- lmer(scl_value ~ CAARS_T_index_centred*shockIntensity*time*shockRecipient 
                                             + shockIntensity*trialNo_centered 
                                             + (1 | sessionID) +
                                               (shockIntensity || subjectID),  
                                             data = mod_data_prq1b_scl_long,
                                             control = lmerControl(optimizer = "bobyqa") )
#> Model converges :D :D
check_predictions(lmms$prq1b_scl_time_ShockRecipient_e)
check_outliers(lmms$prq1b_scl_time_ShockRecipient_e)
check_model(lmms$prq1b_scl_time_ShockRecipient_e)

#define winning model
lmms$prq1b_scl_time_ShockRecipient_WINNER <- lmms$prq1b_scl_time_ShockRecipient_e


```

###### Report results

```{r}

#Save model table
funcs$savelmmTable(lmms$prq1b_scl_time_ShockRecipient_WINNER, 
                   paste0(figures_folder,"/", "prq1b_scl_time_ShockRecipient.doc"))

#Save ANOVA table
anova_prq1b_scl_time_ShockRecipient <- Anova(lmms$prq1b_scl_time_ShockRecipient_WINNER, type = "3")
anova_prq1b_scl_time_ShockRecipient <- as.data.frame(anova_prq1b_scl_time_ShockRecipient) #convert to df
anova_prq1b_scl_time_ShockRecipient <- cbind(rownames(anova_prq1b_scl_time_ShockRecipient), anova_prq1b_scl_time_ShockRecipient) #add rownames
write_xlsx(as.data.frame(anova_prq1b_scl_time_ShockRecipient), 
           paste0(figures_folder,"/", "anova_prq1b_scl_time_ShockRecipient.xlsx"))


```

###### Figs

```{r}
# Calculate mean and SD of CAARS_T_index_centred
mean_caars <- 0 #mean of mean centred is zero!
sd_caars <- sd(subset(df_demographs,subjectID %in% subjects_with_EDA)$CAARS_T_index_centred, na.rm = TRUE)
caars_low <- mean_caars - sd_caars
caars_high <- mean_caars + sd_caars


#------------- Plot 4-way interaction

# Generate predictions for the interaction
preds_response_SCL_adhd_intens_time_recipient <- ggpredict(
  lmms$prq1b_scl_time_ShockRecipient_WINNER,
  terms = c(
    "time", 
    sprintf("CAARS_T_index_centred [%.3f,%.3f]", caars_low, caars_high), 
    "shockIntensity [0,1]", 
    "shockRecipient [0,1]"
  )
)

#label group as ADHD +- 1SD from the mean
group_numeric <- as.numeric(as.character(preds_response_SCL_adhd_intens_time_recipient$group)) # Convert group to numeric for ordering
group_levels <- sort(unique(group_numeric)) # Get unique sorted values
preds_response_SCL_adhd_intens_time_recipient$group <- factor( # Assign labels: lower = "-1 SD", higher = "+1 SD"
  group_numeric,
  levels = group_levels,
  labels = c("CAARS-S:S\nMean -1 SD", "CAARS-S:S\nMean +1 SD")
)

# Label facets for shockIntensity
preds_response_SCL_adhd_intens_time_recipient$facet <- factor(preds_response_SCL_adhd_intens_time_recipient$facet, levels = c("0", "1"), labels = c("Low", "High"))

# Label facets for shockRecipient
preds_response_SCL_adhd_intens_time_recipient$panel <- factor(preds_response_SCL_adhd_intens_time_recipient$panel, levels = c("0", "1"), labels = c("Other", "Self"))

#convert time to numeric
preds_response_SCL_adhd_intens_time_recipient$time <- as.numeric(as.character(preds_response_SCL_adhd_intens_time_recipient$x))

#Make figure + save
p_response_hr_adhd_intens_time_recipient <- funcs$plot_adhd_intens_time_recipient(preds_response_SCL_adhd_intens_time_recipient,                                                                save_destination = figures_folder,                                                               fig_width = 7,                                                              fig_height = 2.6,                                                               phase = "Response",                                                      measure = "SCL", 
shockIntensityConds = c("Low", "High"))


#------intense X time X recipient main effect and interactions

p_response_scl_time_intensity_recipient <- funcs$plot_intens_time_recipient(lmms$prq1b_scl_time_ShockRecipient_WINNER,
                                  save_destination = figures_folder,
                                  fig_width = 5,
                                  fig_height = 2.6,
                                  phase = "Response",
                                  measure = "SCL", 
                                  shockIntensityConds = c("Low", "High"))

#--- Plot CAARS_T_index * shock intensity * shock recipient interaction
p_response_scl_adhd_intens_recip <- funcs$plot_psychophys_adhd_intens_recip(lmms$prq1b_scl_time_ShockRecipient_WINNER, 
                                                         figures_folder,
                                                         fig_width = 4,
                                                         fig_height = 2.6,
                                                         measure = "scl",
                                                         phase = "response")


```

###### Main/simple effects

```{r}

#----Simple effects of shockIntensity × time within each shockRecipient condition

# Define emms for shockIntensity * time within each level of shock recipient
emm_response_SCL_intens_X_time <- emmeans(
  lmms$prq1b_scl_time_ShockRecipient_WINNER,
  ~ shockIntensity * time | shockRecipient ,
  adjust = "holm",
  lmer.df = "satterthwaite"
)

# Define contrast coefficients for interaction (averaged over all timepoints)
# For 2 levels of shockIntensity and 4 levels of time_window,
# the interaction contrast tests if the difference (High - Low)
# differs across timepoints within each recipient.

#Check order of conditions
#emm_int

# This is a "joint" test, not pairwise differences at each timepoint.
custom_contrast <- list(
  "shockIntensity × time_window interaction" = c(-1, 1, -1, 1, -1, 1, -1, 1) / 4
)

# Apply the contrast, with "by = shockRecipient"
cont_int <- contrast(emm_response_SCL_intens_X_time, 
                     custom_contrast, 
                     adjust = "holm", 
                    lmer.df = "satterthwaite",
                     by = "shockRecipient")

# Summary results: one joint test per recipient
summary(cont_int)


# Test interaction contrasts (pairwise comparisons for time) separately for each shockRecipient
contrast_results_emm_response_intens_X_time <- contrast(
  emm_response_SCL_intens_X_time, 
  interaction = "pairwise", 
  adjust = "holm",
  lmer.df = "satterthwaite"   # Use Satterthwaite's df
)
# View results
print(contrast_results_emm_response_intens_X_time)

# save emmeans
write_xlsx(as.data.frame(emm_response_SCL_intens_X_time), 
           paste0(figures_folder,"/", "emm_response_SCL_intens_X_time.xlsx"))

# Save contrasts
write_xlsx(as.data.frame(contrast_results_emm_response_intens_X_time), 
           paste0(figures_folder,"/", "contrast_results_response_emm_intens_X_time.xlsx"))

```




### fisys timecourse

##### Prepare model data

```{r}
#Drop safe level from shockIntensity and exlude subjects without fisys data
mod_data_prq1b_fisys = droplevels(subset(df_all_trials_all_subjs, !is.na(mean_fisys_response) & shockIntensity != 'safe' & subjectID %in% subjects_with_B2B ) )

#convert shockIntensity to numeric coding (1,0) to stop R fitting random effects separately for low and high
mod_data_prq1b_fisys$shockIntensity <- as.numeric(mod_data_prq1b_fisys$shockIntensity == "high")

# Calculate mean of each CAARS subscale
mean_CAARS_index <- mean(unlist(df_demographs[df_demographs$subjectID %in% subjects_with_B2B, "CAARS_T_index"]), na.rm = TRUE)
mean_CAARS_inatt <- mean(unlist(df_demographs[df_demographs$subjectID %in% subjects_with_B2B, "CAARS_T_inatt"]), na.rm = TRUE)
mean_CAARS_hyp <- mean(unlist(df_demographs[df_demographs$subjectID %in% subjects_with_B2B, "CAARS_T_hyp"]), na.rm = TRUE)
mean_CAARS_imp <- mean(unlist(df_demographs[df_demographs$subjectID %in% subjects_with_B2B, "CAARS_T_imp"]), na.rm = TRUE)

#Mean centre CAARS subscales
mod_data_prq1b_fisys$CAARS_T_index_centred <- mod_data_prq1b_fisys$CAARS_T_index - mean_CAARS_index
mod_data_prq1b_fisys$CAARS_T_inatt_centred <- mod_data_prq1b_fisys$CAARS_T_inatt - mean_CAARS_inatt
mod_data_prq1b_fisys$CAARS_T_hyp_centred <- mod_data_prq1b_fisys$CAARS_T_hyp - mean_CAARS_hyp
mod_data_prq1b_fisys$CAARS_T_imp_centred <- mod_data_prq1b_fisys$CAARS_T_imp - mean_CAARS_imp

# Mean centre trialNo within subjects
mod_data_prq1b_fisys <- mod_data_prq1b_fisys %>%
  group_by(subjectID) %>%
  mutate(trialNo_centered = trialNo - mean(trialNo, na.rm = TRUE)) %>%
  ungroup()


#Convert data to long format for time window analyses
mod_data_prq1b_fisys_long = mod_data_prq1b_fisys %>%
  pivot_longer(
    cols = starts_with("fisys_response_bin"),
    names_to = "time",
    names_prefix = "fisys_response_bin",
    values_to = "fisys_value",
    values_drop_na = TRUE
  )

#Ensure time is in correct format (factor)
mod_data_prq1b_fisys_long$time <- factor(mod_data_prq1b_fisys_long$time, 
                                       levels = c(0, 1, 2, 3))
```

##### High vs Low shocks

Test whether ADHD-related differences in timecourse of fisys responses split as a function of Shock Intensity (high vs. low) varies significantly based on the Shock Recipient (self vs. other).

> Pre-registered model to aim for:
  
  Variable ~ CAARSADHD index*ShockIntensity*Time*ShockRecipient + shockIntensity*trialNo_centered + (trialNo_centered | Subject) + (shockIntensity + Time | Session / Subject)

```{r}

#Try fitting preregistered model using OLS
lmms$prq1b_fisys_time_ShockRecipient <- lmer(fisys_value ~ CAARS_T_index_centred*shockIntensity*time*shockRecipient
                                             + shockIntensity*trialNo_centered 
                                             + (trialNo_centered | subjectID) 
                                             + (shockIntensity + time | sessionID / subjectID), 
                                             data = mod_data_prq1b_fisys_long,
                                             control = lmerControl(optimizer = "bobyqa") )
#> Model fails to converge with bobyqa or Nelder_Mead optimiser

#drop slope-intercept correlations for shockIntensity and trialNo
lmms$prq1b_fisys_time_ShockRecipient_a <- lmer(fisys_value ~                                         CAARS_T_index_centred*shockIntensity*time*shockRecipient
                                               + shockIntensity*trialNo_centered 
                                               + (trialNo_centered || subjectID) 
                                               + (shockIntensity + time || sessionID) +  
                                                 (shockIntensity + time || subjectID),  
                                               data = mod_data_prq1b_fisys_long,
                                               control = lmerControl(optimizer = "Nelder_Mead") )
#> Model fails to converge

#Remove random slopes for trialNo_centered
lmms$prq1b_fisys_time_ShockRecipient_b <- lmer(fisys_value ~ CAARS_T_index_centred*shockIntensity*time*shockRecipient
                                               + shockIntensity*trialNo_centered 
                                               + (shockIntensity + time || sessionID) +  
                                                 (shockIntensity + time || subjectID), 
                                               data = mod_data_prq1b_fisys_long,
                                               control = lmerControl(optimizer = "Nelder_Mead") )
#> Model fails to converge


#Remove session-level slope for time
lmms$prq1b_fisys_time_ShockRecipient_c <- lmer(fisys_value ~ CAARS_T_index_centred*shockIntensity*time*shockRecipient
                                               + shockIntensity*trialNo_centered 
                                               + (shockIntensity || sessionID) +  
                                                 (shockIntensity + time || subjectID),  
                                               data = mod_data_prq1b_fisys_long,
                                               control = lmerControl(optimizer = "Nelder_Mead") )
#> Model fails to converge


#Remove session-level slope for shockIntensity
lmms$prq1b_fisys_time_ShockRecipient_d <- lmer(fisys_value ~ CAARS_T_index_centred*shockIntensity*time*shockRecipient 
                                               + shockIntensity*trialNo_centered 
                                               + (1 | sessionID) +
                                                 (shockIntensity + time || subjectID),  
                                               data = mod_data_prq1b_fisys_long,
                                               control = lmerControl(optimizer = "Nelder_Mead") )
#> Model fails to converge

#Remove subject-level slope for time
lmms$prq1b_fisys_time_ShockRecipient_e <- lmer(fisys_value ~ CAARS_T_index_centred*shockIntensity*time*shockRecipient 
                                               + shockIntensity*trialNo_centered 
                                               + (1 | sessionID) +
                                                 (shockIntensity || subjectID),  
                                               data = mod_data_prq1b_fisys_long,
                                               control = lmerControl(optimizer = "Nelder_Mead") )
#> Model converges with Nelder-Mead optimiser :D :D
check_predictions(lmms$prq1b_fisys_time_ShockRecipient_e)
check_outliers(lmms$prq1b_fisys_time_ShockRecipient_e)
check_model(lmms$prq1b_fisys_time_ShockRecipient_e)

#define winning model
lmms$prq1b_fisys_time_ShockRecipient_WINNER <- lmms$prq1b_fisys_time_ShockRecipient_e

```

###### Report results

```{r}

#Save model table
funcs$savelmmTable(lmms$prq1b_fisys_time_ShockRecipient_WINNER, 
                   paste0(figures_folder,"/", "prq1b_fisys_time_ShockRecipient.doc"))

#Save ANOVA table
anova_prq1b_fisys_time_ShockRecipient <- Anova(lmms$prq1b_fisys_time_ShockRecipient_WINNER, type = "3")
anova_prq1b_fisys_time_ShockRecipient <- as.data.frame(anova_prq1b_fisys_time_ShockRecipient) #convert to df
anova_prq1b_fisys_time_ShockRecipient <- cbind(rownames(anova_prq1b_fisys_time_ShockRecipient), anova_prq1b_fisys_time_ShockRecipient) #add rownames
write_xlsx(as.data.frame(anova_prq1b_fisys_time_ShockRecipient), 
           paste0(figures_folder,"/", "anova_prq1b_fisys_time_ShockRecipient.xlsx"))


```

###### Figs

```{r}
# Calculate mean and SD of CAARS_T_index_centred
mean_caars <- 0 #mean of mean centred is zero!
sd_caars <- sd(subset(df_demographs,subjectID %in% subjects_with_B2B)$CAARS_T_index_centred, na.rm = TRUE)
caars_low <- mean_caars - sd_caars
caars_high <- mean_caars + sd_caars


#------------- Plot 4-way interaction

# Generate predictions for the interaction
preds_response_fisys_adhd_intens_time_recipient <- ggpredict(
  lmms$prq1b_fisys_time_ShockRecipient_WINNER,
  terms = c(
    "time", 
    sprintf("CAARS_T_index_centred [%.3f,%.3f]", caars_low, caars_high), 
    "shockIntensity [0,1]", 
    "shockRecipient [0,1]"
  )
)

#label group as ADHD +- 1SD from the mean
group_numeric <- as.numeric(as.character(preds_response_fisys_adhd_intens_time_recipient$group)) # Convert group to numeric for ordering
group_levels <- sort(unique(group_numeric)) # Get unique sorted values
preds_response_fisys_adhd_intens_time_recipient$group <- factor( # Assign labels: lower = "-1 SD", higher = "+1 SD"
  group_numeric,
  levels = group_levels,
  labels = c("CAARS-S:S\nMean -1 SD", "CAARS-S:S\nMean +1 SD")
)

# Label facets for shockIntensity
preds_response_fisys_adhd_intens_time_recipient$facet <- factor(preds_response_fisys_adhd_intens_time_recipient$facet, levels = c("0", "1"), labels = c("Low", "High"))

# Label facets for shockRecipient
preds_response_fisys_adhd_intens_time_recipient$panel <- factor(preds_response_fisys_adhd_intens_time_recipient$panel, levels = c("0", "1"), labels = c("Other", "Self"))

#convert time to numeric
preds_response_fisys_adhd_intens_time_recipient$time <- as.numeric(as.character(preds_response_fisys_adhd_intens_time_recipient$x))

#Make figure + save
p_response_fisys_adhd_intens_time_recipient <- funcs$plot_adhd_intens_time_recipient(preds_response_fisys_adhd_intens_time_recipient,
save_destination = figures_folder,
fig_width = 7,
fig_height = 2.6,
phase = "Response",
measure = "fisys", 
shockIntensityConds = c("Low", "High"))

#------ intense X time X recipient interactions

p_response_fisys_time_intensity_recipient <- funcs$plot_intens_time_recipient(lmms$prq1b_fisys_time_ShockRecipient_WINNER,
                                  save_destination = figures_folder,
                                  fig_width = 5,
                                  fig_height = 2.6,
                                  phase = "Response",
                                  measure = "fisys", 
                                  shockIntensityConds = c("Low", "High"))


#----- intens X recipient interaction

#"F:/ADHD emotion/Empathy study/Analysis/Figures/fisys_response_intes_recipient.png"

#---- Intes x time interaction

p_response_fisys_intensity_time <- funcs$plot_intens_time_two_way(lmms$prq1b_fisys_time_ShockRecipient_WINNER,
                                  save_destination = figures_folder,
                                  fig_width = 2.2,
                                  fig_height = 2.6,
                                  phase = "Response",
                                  measure = "fisys")

#---- Recipient x time interaction

p_response_fisys_recipient_time <- funcs$plot_recipient_time_two_way(lmms$prq1b_fisys_time_ShockRecipient_WINNER,
                                  save_destination = figures_folder,
                                  fig_width = 2.6,
                                  fig_height = 2.6,
                                  phase = "Response",
                                  measure = "fisys")
```

###### Main/simple effects

```{r}

#---- Shock intensity x shock recipient interaction

#calculate emmeans
emm_response_fisys_intensity_X_recipient <- emmeans(
  lmms$prq1b_fisys_time_ShockRecipient_WINNER, 
  ~  shockIntensity | shockRecipient,
  
)

#calculate paired contrasts
contrast_emm_response_fisys_intensity_X_recipient <- contrast(emm_response_fisys_intensity_X_recipient, 
interaction = "pairwise", 
  adjust = "holm",
  lmer.df = "satterthwaite"   # Use Satterthwaite's df
  )
  
# View results
print(contrast_emm_response_fisys_intensity_X_recipient)

# Save emmeans
write_xlsx(as.data.frame(emm_response_fisys_intensity_X_recipient), 
           paste0(figures_folder,"/", "emm_response_fisys_intensity_X_recipient.xlsx"))

# Save contrasts
write_xlsx(as.data.frame(contrast_emm_response_fisys_intensity_X_recipient), 
           paste0(figures_folder,"/", "contrast_emm_response_fisys_intensity_X_recipient.xlsx"))



#---- Time x shock intensity interaction

#calculate emmeans
emm_response_fisys_time_X_intensity <- emmeans(
  lmms$prq1b_fisys_time_ShockRecipient_WINNER, 
  ~  time * shockIntensity,
  
)


#calculate paired contrasts
contrasts_emm_response_fisys_time_X_intensity <- contrast(emm_response_fisys_time_X_intensity, 
interaction = "pairwise", 
  adjust = "holm",
  lmer.df = "satterthwaite"   # Use Satterthwaite's df
  )
  
# View results
print(contrasts_emm_response_fisys_time_X_intensity)

# Save emmeans
write_xlsx(as.data.frame(emm_response_fisys_time_X_intensity), 
           paste0(figures_folder,"/", "emm_response_fisys_time_X_intensity.xlsx"))

# Save contrasts
write_xlsx(as.data.frame(contrasts_emm_response_fisys_time_X_intensity), 
           paste0(figures_folder,"/", "contrasts_emm_response_fisys_time_X_intensity.xlsx"))


#---- Time x shock recipient interaction

#calculate emmeans
emm_response_fisys_time_X_recipient <- emmeans(
  lmms$prq1b_fisys_time_ShockRecipient_WINNER, 
  ~  time * shockRecipient,
  
)


#calculate paired contrasts
contrast_results_emm_response_fisys_time_X_recipient<- contrast(emm_response_fisys_time_X_recipient, 
interaction = "pairwise", 
  adjust = "holm",
  lmer.df = "satterthwaite"   # Use Satterthwaite's df
  )
  
# View results
print(contrast_results_emm_response_fisys_time_X_recipient)


# Save emmeans
write_xlsx(as.data.frame(emm_response_fisys_time_X_recipient), 
           paste0(figures_folder,"/", "emms_emm_time_X_recipient.xlsx"))

# Save contrasts
write_xlsx(as.data.frame(contrast_results_emm_response_fisys_time_X_recipient), 
           paste0(figures_folder,"/", "contrast_results_emm_time_X_recipient.xlsx"))
          

```



### fidia timecourse

##### Prepare model data

```{r}
#Drop safe level from shockIntensity and exlude subjects without fisys data
mod_data_prq1b_fidia = droplevels(subset(df_all_trials_all_subjs, !is.na(mean_fidia_response) & shockIntensity != 'safe' & subjectID %in% subjects_with_B2B ) )

#convert shockIntensity to numeric coding (1,0) to stop R fitting random effects separately for low and high
mod_data_prq1b_fidia$shockIntensity <- as.numeric(mod_data_prq1b_fidia$shockIntensity == "high")

# Calculate mean of each CAARS subscale
mean_CAARS_index <- mean(unlist(df_demographs[df_demographs$subjectID %in% subjects_with_B2B, "CAARS_T_index"]), na.rm = TRUE)
mean_CAARS_inatt <- mean(unlist(df_demographs[df_demographs$subjectID %in% subjects_with_B2B, "CAARS_T_inatt"]), na.rm = TRUE)
mean_CAARS_hyp <- mean(unlist(df_demographs[df_demographs$subjectID %in% subjects_with_B2B, "CAARS_T_hyp"]), na.rm = TRUE)
mean_CAARS_imp <- mean(unlist(df_demographs[df_demographs$subjectID %in% subjects_with_B2B, "CAARS_T_imp"]), na.rm = TRUE)

#Mean centre CAARS subscales
mod_data_prq1b_fidia$CAARS_T_index_centred <- mod_data_prq1b_fidia$CAARS_T_index - mean_CAARS_index
mod_data_prq1b_fidia$CAARS_T_inatt_centred <- mod_data_prq1b_fidia$CAARS_T_inatt - mean_CAARS_inatt
mod_data_prq1b_fidia$CAARS_T_hyp_centred <- mod_data_prq1b_fidia$CAARS_T_hyp - mean_CAARS_hyp
mod_data_prq1b_fidia$CAARS_T_imp_centred <- mod_data_prq1b_fidia$CAARS_T_imp - mean_CAARS_imp

# Mean centre trialNo within subjects
mod_data_prq1b_fidia <- mod_data_prq1b_fidia %>%
  group_by(subjectID) %>%
  mutate(trialNo_centered = trialNo - mean(trialNo, na.rm = TRUE)) %>%
  ungroup()


#Convert data to long format for time window analyses
mod_data_prq1b_fidia_long = mod_data_prq1b_fidia %>%
  pivot_longer(
    cols = starts_with("fidia_response_bin"),
    names_to = "time",
    names_prefix = "fidia_response_bin",
    values_to = "fidia_value",
    values_drop_na = TRUE
  )

#Ensure time is in correct format (factor)
mod_data_prq1b_fidia_long$time <- factor(mod_data_prq1b_fidia_long$time, 
                                         levels = c(0, 1, 2, 3))
```


##### High vs Low shocks

Test whether ADHD-related differences in timecourse of fidia responses split as a function of Shock Intensity (high vs. low) varies significantly based on the Shock Recipient (self vs. other).

> Pre-registered model to aim for:
  
  Variable ~ CAARSADHD index*ShockIntensity*Time*ShockRecipient + shockIntensity*trialNo_centered + (trialNo_centered | Subject) + (shockIntensity + Time | Session / Subject)

```{r}

#Try fitting preregistered model using OLS
lmms$prq1b_fidia_time_ShockRecipient <- lmer(fidia_value ~ CAARS_T_index_centred*shockIntensity*time*shockRecipient
                                             + shockIntensity*trialNo_centered 
                                             + (trialNo_centered | subjectID) 
                                             + (shockIntensity + time | sessionID / subjectID), 
                                             data = mod_data_prq1b_fidia_long,
                                             control = lmerControl(optimizer = "bobyqa") )
#> Model fails to converge with bobyqa or Nelder_Mead optimiser

#drop slope-intercept correlations for shockIntensity and trialNo
lmms$prq1b_fidia_time_ShockRecipient_a <- lmer(fidia_value ~ CAARS_T_index_centred*shockIntensity*time*shockRecipient
                                               + shockIntensity*trialNo_centered 
                                               + (trialNo_centered || subjectID) 
                                               + (shockIntensity + time || sessionID) +  
                                                 (shockIntensity + time || subjectID),  
                                               data = mod_data_prq1b_fidia_long,
                                               control = lmerControl(optimizer = "Nelder_Mead") )
#> Model fails to converge

#Remove random slopes for trialNo_centered
lmms$prq1b_fidia_time_ShockRecipient_b <- lmer(fidia_value ~ CAARS_T_index_centred*shockIntensity*time*shockRecipient
                                               + shockIntensity*trialNo_centered 
                                               + (shockIntensity + time || sessionID) +  
                                                 (shockIntensity + time || subjectID), 
                                               data = mod_data_prq1b_fidia_long,
                                               control = lmerControl(optimizer = "Nelder_Mead") )
#> Model fails to converge


#Remove session-level slope for time
lmms$prq1b_fidia_time_ShockRecipient_c <- lmer(fidia_value ~ CAARS_T_index_centred*shockIntensity*time*shockRecipient
                                               + shockIntensity*trialNo_centered 
                                               + (shockIntensity || sessionID) +  
                                                 (shockIntensity + time || subjectID),  
                                               data = mod_data_prq1b_fidia_long,
                                               control = lmerControl(optimizer = "Nelder_Mead") )
#> Model fails to converge


#Remove session-level slope for shockIntensity
lmms$prq1b_fidia_time_ShockRecipient_d <- lmer(fidia_value ~ CAARS_T_index_centred*shockIntensity*time*shockRecipient 
                                               + shockIntensity*trialNo_centered 
                                               + (1 | sessionID) +
                                                 (shockIntensity + time || subjectID),  
                                               data = mod_data_prq1b_fidia_long,
                                               control = lmerControl(optimizer = "Nelder_Mead") )
#> Model fails to converge

#Remove subject-level slope for time
lmms$prq1b_fidia_time_ShockRecipient_e <- lmer(fidia_value ~ CAARS_T_index_centred*shockIntensity*time*shockRecipient 
                                               + shockIntensity*trialNo_centered 
                                               + (1 | sessionID) +
                                                 (shockIntensity || subjectID),  
                                               data = mod_data_prq1b_fidia_long,
                                               control = lmerControl(optimizer = "Nelder_Mead") )
#> Model fails to converge

#Remove random slope of (shockIntensity | subjectID)
lmms$prq1b_fidia_time_ShockRecipient_f <- lmer(fidia_value ~ CAARS_T_index_centred*shockIntensity*time*shockRecipient 
                                               + shockIntensity*trialNo_centered 
                                               + (1 | sessionID) +
                                                 (1 | subjectID),  
                                               data = mod_data_prq1b_fidia_long,
                                               control = lmerControl(optimizer = "bobyqa") )
#> Model converges with bobyqa optimiser :D :D
check_predictions(lmms$prq1b_fidia_time_ShockRecipient_f)
check_outliers(lmms$prq1b_fidia_time_ShockRecipient_f)

#Try removing (1 | sessionID) instead
lmms$prq1b_fidia_time_ShockRecipient_g <- lmer(fidia_value ~ CAARS_T_index_centred*shockIntensity*time*shockRecipient 
                                               + shockIntensity*trialNo_centered 
                                                + (shockIntensity || subjectID),  
                                               data = mod_data_prq1b_fidia_long,
                                               control = lmerControl(optimizer = "bobyqa") )
#> Model converges with bobyqa optimiser :D :D
check_predictions(lmms$prq1b_fidia_time_ShockRecipient_g)
check_outliers(lmms$prq1b_fidia_time_ShockRecipient_g)
check_model(lmms$prq1b_fidia_time_ShockRecipient_g)

#compare models
MuMIn::r.squaredGLMM(lmms$prq1b_fidia_time_ShockRecipient_f)
MuMIn::r.squaredGLMM(lmms$prq1b_fidia_time_ShockRecipient_g)
AIC(lmms$prq1b_fidia_time_ShockRecipient_f)
AIC(lmms$prq1b_fidia_time_ShockRecipient_g)
#> model _g is slightly better

#define winning model
lmms$prq1b_fidia_time_ShockRecipient_WINNER <- lmms$prq1b_fidia_time_ShockRecipient_g


```

###### Report results

```{r}

#Save model table
funcs$savelmmTable(lmms$prq1b_fidia_time_ShockRecipient_WINNER, 
                   paste0(figures_folder,"/", "prq1b_fidia_time_ShockRecipient.doc"))

#Save ANOVA table
anova_prq1b_fidia_time_ShockRecipient <- Anova(lmms$prq1b_fidia_time_ShockRecipient_WINNER, type = "3")
anova_prq1b_fidia_time_ShockRecipient <- as.data.frame(anova_prq1b_fidia_time_ShockRecipient) #convert to df
anova_prq1b_fidia_time_ShockRecipient <- cbind(rownames(anova_prq1b_fidia_time_ShockRecipient), anova_prq1b_fidia_time_ShockRecipient) #add rownames
write_xlsx(as.data.frame(anova_prq1b_fidia_time_ShockRecipient), 
           paste0(figures_folder,"/", "anova_prq1b_fidia_time_ShockRecipient.xlsx"))


```

###### Figs

```{r}
# Calculate mean and SD of CAARS_T_index_centred
mean_caars <- 0 #mean of mean centred is zero!
sd_caars <- sd(subset(df_demographs,subjectID %in% subjects_with_B2B)$CAARS_T_index_centred, na.rm = TRUE)
caars_low <- mean_caars - sd_caars
caars_high <- mean_caars + sd_caars


#------------- Plot 4-way interaction

# Generate predictions for the interaction
preds_response_fidia_adhd_intens_time_recipient <- ggpredict(
  lmms$prq1b_fidia_time_ShockRecipient_WINNER,
  terms = c(
    "time", 
    sprintf("CAARS_T_index_centred [%.3f,%.3f]", caars_low, caars_high), 
    "shockIntensity [0,1]", 
    "shockRecipient [0,1]"
  )
)

#label group as ADHD +- 1SD from the mean
group_numeric <- as.numeric(as.character(preds_response_fidia_adhd_intens_time_recipient$group)) # Convert group to numeric for ordering
group_levels <- sort(unique(group_numeric)) # Get unique sorted values
preds_response_fidia_adhd_intens_time_recipient$group <- factor( # Assign labels: lower = "-1 SD", higher = "+1 SD"
  group_numeric,
  levels = group_levels,
  labels = c("CAARS-S:S\nMean -1 SD", "CAARS-S:S\nMean +1 SD")
)

# Label facets for shockIntensity
preds_response_fidia_adhd_intens_time_recipient$facet <- factor(preds_response_fidia_adhd_intens_time_recipient$facet, levels = c("0", "1"), labels = c("Low", "High"))

# Label facets for shockRecipient
preds_response_fidia_adhd_intens_time_recipient$panel <- factor(preds_response_fidia_adhd_intens_time_recipient$panel, levels = c("0", "1"), labels = c("Other", "Self"))

#convert time to numeric
preds_response_fidia_adhd_intens_time_recipient$time <- as.numeric(as.character(preds_response_fidia_adhd_intens_time_recipient$x))

#Make figure + save
p_response_fidia_adhd_intens_time_recipient <- funcs$plot_adhd_intens_time_recipient(preds_response_fidia_adhd_intens_time_recipient,
save_destination = figures_folder,
fig_width = 7,
fig_height = 2.6,
phase = "Response",
measure = "fidia", 
shockIntensityConds = c("Low", "High"))


#------- intense X time X recipient main effect and interactions

p_response_fidia_time_intensity_recipient <- funcs$plot_intens_time_recipient(lmms$prq1b_fidia_time_ShockRecipient_WINNER,
                                  save_destination = figures_folder,
                                  fig_width = 5,
                                  fig_height = 2.6,
                                  phase = "Response",
                                  measure = "fidia", 
                                  shockIntensityConds = c("Low", "High"))


#----- intens X recipient interaction

p_response_fidia_intensity_recipient <- funcs$plot_intens_recipient(lmms$prq1b_fidia_time_ShockRecipient_WINNER,
                                  save_destination = figures_folder,
                                  fig_width = 2.6,
                                  fig_height = 2.6,
                                  phase = "Response",
                                  measure = "fidia")

#---- Recipient x time interaction

p_response_fidia_recipient_time <- funcs$plot_recipient_time_two_way(lmms$prq1b_fidia_time_ShockRecipient_WINNER,
                                  save_destination = figures_folder,
                                  fig_width = 2.6,
                                  fig_height = 2.6,
                                  phase = "Response",
                                  measure = "fidia")

```

###### Main/simple effects

```{r}

#---- shockIntensity × time interaction within each shockRecipient condition

# Get estimated marginal means for shockIntensity × time within each shockRecipient

emm_response_fidia_intens_X_time <- emmeans(
  lmms$prq1b_fidia_time_ShockRecipient_WINNER, 
  specs = ~ shockIntensity * time | shockRecipient  # Split by shockRecipient
)

# Test interaction contrasts (pairwise comparisons) separately for each shockRecipient
contrast_results_emm_response_fidia_intens_X_time <- contrast(
  emm_response_fidia_intens_X_time, 
  interaction = "pairwise", 
  adjust = "holm",
  lmer.df = "satterthwaite"   # Use Satterthwaite's df
)
# View results
print(contrast_results_emm_response_fidia_intens_X_time)


# Save emmeans
write_xlsx(as.data.frame(emm_response_fidia_intens_X_time), 
           paste0(figures_folder,"/", "response_fidia_emm_intens_X_time.xlsx"))

# Save contrasts
write_xlsx(as.data.frame(contrast_results_emm_response_fidia_intens_X_time), 
           paste0(figures_folder,"/", "contrast_results_response_fidia_emm_intens_X_time.xlsx"))


# #---- Time x shock recipient interaction
# 
# #calculate emmeans
# emm_response_fidia_time_X_recipient <- emmeans(
#   lmms$prq1b_fidia_time_ShockRecipient_WINNER, 
#   ~  time * shockRecipient,
#   
# )
# 
# 
# #calculate paired contrasts
# contrast_results_emm_response_fidia_time_X_recipient <- contrast(emm_response_fidia_time_X_recipient, 
# interaction = "pairwise", 
#   adjust = "holm",
#   lmer.df = "satterthwaite"   # Use Satterthwaite's df
#   )
#   
# # View results
# print(contrast_results_emm_response_fidia_time_X_recipient)
# 
# 
# # Save emmeans
# write_xlsx(as.data.frame(emm_response_fidia_time_X_recipient), 
#            paste0(figures_folder,"/", "emm_response_fidia_time_X_recipient.xlsx"))
# 
# # Save contrasts
# write_xlsx(as.data.frame(contrast_results_emm_response_fidia_time_X_recipient), 
#            paste0(figures_folder,"/", "contrast_results_emm_response_fidia_time_X_recipient.xlsx"))
#           
# 
# #---- Shock intensity x shock recipient interaction
# 
# #calculate emmeans
# emm_response_fidia_intensity_X_recipient <- emmeans(
#   lmms$prq1b_fidia_time_ShockRecipient_WINNER, 
#   ~  shockIntensity | shockRecipient,
#   
# )
# 
# #calculate paired contrasts
# contrast_emm_response_fidia_intensity_X_recipient <- contrast(emm_response_fidia_intensity_X_recipient, 
# interaction = "pairwise", 
#   adjust = "holm",
#   lmer.df = "satterthwaite"   # Use Satterthwaite's df
#   )
#   
# # View results
# print(contrast_emm_response_fidia_intensity_X_recipient)
# 
# # Save emmeans
# write_xlsx(as.data.frame(emm_response_fidia_intensity_X_recipient), 
#            paste0(figures_folder,"/", "emm_response_fidia_intensity_X_recipient.xlsx"))
# 
# # Save contrasts
# write_xlsx(as.data.frame(contrast_emm_response_fidia_intensity_X_recipient), 
#            paste0(figures_folder,"/", "contrast_emm_response_fidia_intensity_X_recipient.xlsx"))


```



#----

# PRQ 3+4 - trial-by-trial ratings analyses

## Prepare data

```{r}
#Drop safe level from shockIntensity, exclude faulty shock trials, exclude missed ratings (nan)
mod_data_prq3 = droplevels(subset(df_all_trials_all_subjs, !is.na(ratingArousal) 
                                      & shockIntensity != 'safe' 
                                      & faultyShock == 0 ) )

#convert shockIntensity to numeric coding (1,0) to stop R fitting random effects separately for low and high
mod_data_prq3$shockIntensity <- as.numeric(mod_data_prq3$shockIntensity == "high")

# Calculate mean CAARS
meanCAARS_index <- mean(unlist(df_demographs$CAARS_T_index), na.rm = TRUE)
meanCAARS_inatt <- mean(unlist(df_demographs$CAARS_T_inatt), na.rm = TRUE)
meanCAARS_hyp <- mean(unlist(df_demographs$CAARS_T_hyp), na.rm = TRUE)
meanCAARS_imp <- mean(unlist(df_demographs$CAARS_T_imp), na.rm = TRUE)
meanCAARS_self <- mean(unlist(df_demographs$CAARS_T_self), na.rm = TRUE)

# Mean centre CAARS
mod_data_prq3$CAARS_T_index_centred <- mod_data_prq3$CAARS_T_index - meanCAARS_index
mod_data_prq3$CAARS_T_inatt_centred <- mod_data_prq3$CAARS_T_inatt - meanCAARS_inatt
mod_data_prq3$CAARS_T_hyp_centred <- mod_data_prq3$CAARS_T_hyp - meanCAARS_hyp
mod_data_prq3$CAARS_T_imp_centred <- mod_data_prq3$CAARS_T_imp - meanCAARS_imp
mod_data_prq3$CAARS_T_self_centred <- mod_data_prq3$CAARS_T_self - meanCAARS_self

# Mean centre trialNo within subjects
mod_data_prq3 <- mod_data_prq3 %>%
  group_by(subjectID) %>%
  mutate(
    trialNo_centered = trialNo - mean(trialNo, na.rm = TRUE)) %>%
  ungroup()

```

## Arousal


Test whether ADHD-related differences in ratings to high vs low intensity shock differ as a function of shock recipient

> Pre-registered model to aim for:
  
  rating ~ CAARS_T_index*ShockIntensity*shockRecipient 
+ ShockIntensity*trialNo_centered 
+ (trialNo_centered | subjectID) 
+ (ShockIntensity | sessionID / subjectID)


### High vs Low shocks

```{r}
#Try fitting preregistered model using OLS
lmms$prq3_arousal_ShockRecipient <- glmmTMB(ratingArousal_beta ~ CAARS_T_index_centred*shockIntensity*shockRecipient 
                                        + shockIntensity*trialNo_centered 
                                        + (trialNo_centered | subjectID) 
                                        + (shockIntensity | sessionID / subjectID), 
                                        data = mod_data_prq3,
                                        family = beta_family())
#summary(lmms$prq3_arousal_ShockRecipient)
#> Model fails to converge with bobyqa (default) or Nelder_Mead optimiser (check warnings during model fit not summary())

#drop slope-intercept correlations for shockIntensity and trialNo
lmms$prq3_arousal_ShockRecipient_a <- glmmTMB(ratingArousal_beta ~ CAARS_T_index_centred*shockIntensity*shockRecipient 
                                          + shockIntensity*trialNo_centered 
                                          + (trialNo_centered || subjectID) 
                                          + (shockIntensity || sessionID) +  # Uncorrelated slopes/intercepts for sessions
                                            (shockIntensity || subjectID),  # Uncorrelated for subjects within sessions
                                          data = mod_data_prq3,
                                          family = beta_family())
#summary(lmms$prq3_arousal_ShockRecipient_a)
#> Model _a does not converge with bobyqa (default) or Nelder_Mead optimiser

#drop session-level slopes
lmms$prq3_arousal_ShockRecipient_b <- glmmTMB(ratingArousal_beta ~ CAARS_T_index_centred*shockIntensity*shockRecipient
                                          + shockIntensity*trialNo_centered
                                          + (trialNo_centered || subjectID) +
                                            (shockIntensity || subjectID) +  # Random intercept and slope for shockIntensity for subjects nested within sessions
                                            (1 | sessionID),  # random intercept (but no random slopes) for session
                                          data = mod_data_prq3,
                                          family = beta_family())
# #> Model failed to converge

#Drop random slope of trialNo | subjectID
lmms$prq3_arousal_ShockRecipient_c <- glmmTMB(ratingArousal_beta ~ CAARS_T_index_centred*shockIntensity*shockRecipient 
                                          + shockIntensity*trialNo_centered 
                                          + (shockIntensity || sessionID) +  # Uncorrelated slopes/intercepts for sessions
                                            (shockIntensity || subjectID),  # Uncorrelated for subjects within sessions
                                          data = mod_data_prq3,
                                          family = beta_family())
# #> Model converged :D :D
check_predictions(lmms$prq3_arousal_ShockRecipient_c)

#Define winning model
lmms$prq3_arousal_ShockRecipient_WINNER <- lmms$prq3_arousal_ShockRecipient_c


```


#### Report results

```{r}

#Save model table
funcs$saveglmmTMBbetaTable(lmms$prq3_arousal_ShockRecipient_WINNER, 
                   paste0(figures_folder,"/", "prq3_arousal_time_ShockRecipient.doc"))

#Save model table using scienfitic notation for numbers
funcs$saveglmmTMBbetaTable_scientific(lmms$prq3_arousal_ShockRecipient_WINNER, 
                   paste0(figures_folder,"/", "prq3_arousal_time_ShockRecipient_SCIENTIFIC.docx"))

#> Combine the two tables in MS word (estimate, SE, CI using scientific notation)

#Save ANOVA table
anova_prq3_arousal_ShockRecipient <- Anova(lmms$prq3_arousal_ShockRecipient_WINNER, type = "3")
df_anova_prq3_arousal_ShockRecipient <- as.data.frame(anova_prq3_arousal_ShockRecipient) #convert to df
df_anova_prq3_arousal_ShockRecipient <- cbind(rownames(anova_prq3_arousal_ShockRecipient), df_anova_prq3_arousal_ShockRecipient) #add rownames
write_xlsx(df_anova_prq3_arousal_ShockRecipient, 
           paste0(figures_folder,"/", "anova_prq3_arousal_ShockRecipient.xlsx")) #save


```

#### Figs


```{r}

#--- Plot CAARS_T_index * shock intensity * shock recipient interaction
p_arousal_adhd_intens_recip <- funcs$plot_rating_adhd_intens_recip(lmms$prq3_arousal_ShockRecipient_WINNER, 
                                                         figures_folder,
                                                         fig_width = 4,
                                                         fig_height = 2.6,
                                                         measure = "arousal", 
                                                         shockIntensityConds = c("Low", "High"))


#----Plot CAARS_T_index*shockRecipient interaction

# Get predicted values for the interaction
preds_arousal_index_recip_response <- ggpredict(
  lmms$prq3_arousal_ShockRecipient_WINNER, 
  terms = c("CAARS_T_index_centred [all]", "shockRecipient"),
  bias_correction = TRUE #use bias correction for glmer models
)

# Plot using ggplot2
preds_arousal_index_recip_response$group <- factor(preds_arousal_index_recip_response$group, levels = c("0", "1"), labels = c("Other", "Self"))

p_arousal_index_recip_response <- ggplot(preds_arousal_index_recip_response, aes(x = x, y = predicted*100, color = group, fill = group)) +
  geom_line(size = 1.2) +
  geom_ribbon(aes(ymin = conf.low*100, ymax = conf.high*100), alpha = 0.15, color = NA) +
  labs(
    x = "CAARS-S:S index (centred)",
    y = "Arousal rating",
    color = "Shock\nRecipient",
    fill = "Shock\nRecipient"
    #title = "Main effect of CAARS ADHD index\non arousal, response phase"
  ) +
  coord_cartesian(ylim = c(30, 61)) + #y axis limits
  scale_color_manual(values = c(custom_palette[3], custom_palette[4]), labels = c("Other", "Self")) +
  scale_fill_manual(values = c(custom_palette[3], custom_palette[4]), labels = c("Other", "Self")) +
  theme_classic() + 
  theme(plot.title = element_text(hjust = 0.5, margin = margin(b = 6)),
      panel.spacing = unit(0.5, "lines"),
      strip.background = element_blank(),
      strip.text = element_text(face = "bold"),
      plot.margin = margin(0, 0, 0, 0),
      legend.position = "right",
      legend.box.margin = margin(0, 0, 0, 0),
      legend.margin = margin(0, 0, 0, 0))

#show figure
p_arousal_index_recip_response

#save figure
ggsave(paste0(figures_folder,"/", "arousal_response_index_intens.png"), p_arousal_index_recip_response, width = 2.6, height = 2.6, units = "in", dpi = 300, limitsize = FALSE)


#------Plot shock intensity x shock recipient interaction

p_arousal_intens_recip <- funcs$plot_rating_intens_recip(lmms$prq3_arousal_ShockRecipient_WINNER, 
                                                         figures_folder,
                                                         fig_width = 2.6,
                                                         fig_height = 2.6,
                                                         measure = "arousal", 
                                                         shockIntensityConds = c("Low", "High"))

```

#### Main/simple effects

```{r}

#----Simple effects of CAARS index within each shockRecipient condition

# Get the estimated marginal trends (slopes) of CAARS_T_index_centred
emm_trends_arousal_index_recipient <- emtrends(
  lmms$prq3_arousal_ShockRecipient_WINNER,
  var = "CAARS_T_index_centred", 
  specs = ~ shockRecipient,
  adjust = "holm",
  lmer.df = "satterthwaite"
)

#show simple effects
summary(emm_trends_arousal_index_recipient, type = "response", infer = TRUE)

#Save simple effects
write_xlsx(as.data.frame(summary(emm_trends_arousal_index_recipient, type = "response", infer = TRUE)), 
            paste0(figures_folder,"/", "emm_trends_arousal_index_recipient.xlsx"))

#Save emtrend estimates (type = response to keep on response scale)
write_xlsx(as.data.frame(summary(emm_trends_arousal_index_recipient, type = "response")), 
            paste0(figures_folder,"/", "emm_trends_arousal_index_recipient.xlsx"))

#show interaction contrast
pairs(emm_trends_arousal_index_recipient)

#Save interaction contrast
write_xlsx(as.data.frame(pairs(emm_trends_arousal_index_recipient)), 
            paste0(figures_folder,"/", "contrasts_emm_trends_arousal_index_recipient.xlsx"))


#--- ShockRecipient*shockIntensity interaction, averaging over other variables
emm_arousal_shock_recip <- emmeans(
  lmms$prq3_arousal_ShockRecipient_WINNER,
  specs = ~ shockIntensity * shockRecipient, 
  adjust = "holm",
  lmer.df = "satterthwaite"
)

#Save (type = response to keep on response scale)
write_xlsx(as.data.frame(summary(emm_arousal_shock_recip, type = "response")), 
            paste0(figures_folder,"/", "emm_arousal_shock_recip.xlsx"))

# Test the interaction
contrast(emm_arousal_shock_recip, 
         interaction = "pairwise")

#Save interaction contrast
write_xlsx(as.data.frame(contrast(emm_arousal_shock_recip, 
         interaction = "pairwise")), 
            paste0(figures_folder,"/", "emm_contrasts_arousal_shock_recip.xlsx"))


#--- Simple effect of ShockIntensity at each level of shockRecipient

emm_arousal_intens_recip_SE <- emmeans(lmms$prq3_arousal_ShockRecipient_WINNER, 
                                      specs = ~ shockIntensity | shockRecipient, type = 'response',
                                      adjust = "holm",
                                      lmer.df = "satterthwaite")
pairs(emm_arousal_intens_recip_SE)

#Save
write_xlsx(as.data.frame(pairs(emm_arousal_intens_recip_SE)), 
            paste0(figures_folder,"/", "contrasts_emm_arousal_intens_recip_SE.xlsx"))


```



## Valence

### High vs Low shocks

Test whether ADHD-related differences in ratings to high vs low intensity shock differ as a function of shock recipient

> Pre-registered model to aim for:
  
  rating ~ CAARS_T_index*ShockIntensity*shockRecipient 
+ ShockIntensity*trialNo_centered 
+ (trialNo_centered | subjectID) 
+ (ShockIntensity | sessionID / subjectID)

```{r}
#Try fitting preregistered model using OLS
lmms$prq3_valence_ShockRecipient <- glmmTMB(ratingValence_beta ~ CAARS_T_index_centred*shockIntensity*shockRecipient 
                                        + shockIntensity*trialNo_centered 
                                        + (trialNo_centered | subjectID) 
                                        + (shockIntensity | sessionID / subjectID), 
                                        data = mod_data_prq3,
                                        family = beta_family())
#summary(lmms$prq3_valence_ShockRecipient)
#> Model fails to converge with bobyqa (default) or Nelder_Mead optimiser (check warnings during model fit not summary())

#drop slope-intercept correlations for shockIntensity and trialNo
lmms$prq3_valence_ShockRecipient_a <- glmmTMB(ratingValence_beta ~ CAARS_T_index_centred*shockIntensity*shockRecipient 
                                          + shockIntensity*trialNo_centered 
                                          + (trialNo_centered || subjectID) 
                                          + (shockIntensity || sessionID) +  # Uncorrelated slopes/intercepts for sessions
                                            (shockIntensity || subjectID),  # Uncorrelated for subjects within sessions
                                          data = mod_data_prq3,
                                          family = beta_family())
#summary(lmms$prq3_valence_ShockRecipient_a)
#> Model _a does not converge with bobyqa (default) or Nelder_Mead optimiser

#drop session-level slopes
lmms$prq3_valence_ShockRecipient_b <- glmmTMB(ratingValence_beta ~ CAARS_T_index_centred*shockIntensity*shockRecipient
                                          + shockIntensity*trialNo_centered
                                          + (trialNo_centered || subjectID) +
                                            (shockIntensity || subjectID) +  # Random intercept and slope for shockIntensity for subjects nested within sessions
                                            (1 | sessionID),  # random intercept (but no random slopes) for session
                                          data = mod_data_prq3,
                                          family = beta_family())
# #> Model failed to converge

#Drop random slope of trialNo | subjectID
lmms$prq3_valence_ShockRecipient_c <- glmmTMB(ratingValence_beta ~ CAARS_T_index_centred*shockIntensity*shockRecipient 
                                          + shockIntensity*trialNo_centered 
                                          + (shockIntensity || sessionID) +  
                                            (shockIntensity || subjectID),  
                                          data = mod_data_prq3,
                                          family = beta_family())
##>> Model converged :D :D
check_predictions(lmms$prq3_valence_ShockRecipient_c)


#Check for outliers and refit
lmms$prq3_valence_ShockRecipient_c_clean = funcs$refit_model_minus_outliers(lmms$prq3_valence_ShockRecipient_c)

#summary with adj. pvals after excluding outliers
summary_p_adj_clean = funcs$adjust_glmmTMB_p_vals(lmms$prq3_valence_ShockRecipient_c_clean, 
                                      "summary", "z", "holm", NA)
print(summary_p_adj_clean)

#define winning model
lmms$prq3_valence_ShockRecipient_WINNER <- lmms$prq3_valence_ShockRecipient_c

```

#### Report results

```{r}

#Save model table
funcs$saveglmmTMBbetaTable(lmms$prq3_valence_ShockRecipient_WINNER, 
                   paste0(figures_folder,"/", "prq3_valence_time_ShockRecipient.doc"))

#Save model table using scienfitic notation for numbers
funcs$saveglmmTMBbetaTable_scientific(lmms$prq3_valence_ShockRecipient_WINNER, 
                   paste0(figures_folder,"/", "prq3_valence_time_ShockRecipient_SCIENTIFIC.docx"))

#> Combined the two tables in MS word (estimate, SE, CI using scientific notation)

#Save ANOVA table
anova_prq3_valence_ShockRecipient <- Anova(lmms$prq3_valence_ShockRecipient_WINNER, type = "3")
df_anova_prq3_valence_ShockRecipient <- as.data.frame(anova_prq3_valence_ShockRecipient) #convert to df
anova_prq3_valence_ShockRecipient <- cbind(rownames(anova_prq3_valence_ShockRecipient), anova_prq3_valence_ShockRecipient) #add rownames
write_xlsx(anova_prq3_valence_ShockRecipient, 
           paste0(figures_folder,"/", "anova_prq3_valence_ShockRecipient.xlsx")) #save


```


#### Figs


```{r}
#--- Plot CAARS_T_index * shock intensity * shock recipient interaction
p_valence_adhd_intens_recip <- funcs$plot_rating_adhd_intens_recip(lmms$prq3_valence_ShockRecipient_WINNER, 
                                                         figures_folder,
                                                         fig_width = 4,
                                                         fig_height = 2.6,
                                                         measure = "valence", 
                                                         shockIntensityConds = c("Low", "High"))

#------Plot shock intensity x shock recipient interaction

p_valence_intens_recip <- funcs$plot_rating_intens_recip(lmms$prq3_valence_ShockRecipient_WINNER, 
                                                         figures_folder,
                                                         fig_width = 2.6,
                                                         fig_height = 2.6,
                                                         measure = "valence", 
                                                         y_limits = c(41, 56), 
                                                         shockIntensityConds = c("Low", "High"))

```

#### Main/simple effects

```{r}

#--- ShockRecipient*shockIntensity interaction, averaging over other variables
emm_valence_shock_recip <- emmeans(
  lmms$prq3_valence_ShockRecipient_WINNER,
  specs = ~ shockIntensity * shockRecipient, 
  adjust = "holm",
  lmer.df = "satterthwaite"
)

#Save (type = response to keep on response scale)
write_xlsx(as.data.frame(summary(emm_valence_shock_recip, type = "response")), 
            paste0(figures_folder,"/", "emm_valence_shock_recip.xlsx"))

# Test the interaction
contrast(emm_valence_shock_recip, 
         interaction = "pairwise")

#Save interaction contrast
write_xlsx(as.data.frame(contrast(emm_valence_shock_recip, 
         interaction = "pairwise")), 
            paste0(figures_folder,"/", "emm_contrasts_valence_shock_recip.xlsx"))

#--- Simple effect of ShockIntensity at each level of shockRecipient

emm_valence_intens_recip_SE <- emmeans(lmms$prq3_valence_ShockRecipient_WINNER, 
                                      specs = ~ shockIntensity | shockRecipient, type = 'response',
                                      adjust = "holm",
                                      lmer.df = "satterthwaite")
pairs(emm_valence_intens_recip_SE)

#Save
write_xlsx(as.data.frame(pairs(emm_valence_intens_recip_SE)), 
            paste0(figures_folder,"/", "contrasts_emm_valence_intens_recip_SE.xlsx"))


```





## Emotion intensity

### High vs Low shocks

Test whether ADHD-related differences in ratings to high vs low intensity shock differ as a function of shock recipient

> Pre-registered model to aim for:
  
  rating ~ CAARS_T_index*ShockIntensity*shockRecipient 
+ ShockIntensity*trialNo_centered 
+ (trialNo_centered | subjectID) 
+ (ShockIntensity | sessionID / subjectID)


```{r}
#Try fitting preregistered model using OLS
lmms$prq3_Intensity_ShockRecipient <- lmer(emotionIntensity ~ CAARS_T_index_centred*shockIntensity*shockRecipient 
                                        + shockIntensity*trialNo_centered 
                                        + (trialNo_centered | subjectID) 
                                        + (shockIntensity | sessionID / subjectID), 
                                        data = mod_data_prq3,
                                        control = lmerControl(optimizer = "bobyqa"))

#summary(lmms$prq3_Intensity_ShockRecipient)
#> Model fails to converge with bobyqa (default) or Nelder_Mead optimiser (check warnings during model fit not summary())

#drop slope-intercept correlations for shockIntensity and trialNo
lmms$prq3_Intensity_ShockRecipient_a <- lmer(emotionIntensity ~ CAARS_T_index_centred*shockIntensity*shockRecipient 
                                          + shockIntensity*trialNo_centered 
                                          + (trialNo_centered || subjectID) 
                                          + (shockIntensity || sessionID) +  # Uncorrelated slopes/intercepts for sessions
                                            (shockIntensity || subjectID),  # Uncorrelated for subjects within sessions
                                          data = mod_data_prq3,
                                          control = lmerControl(optimizer = "bobyqa"))
#summary(lmms$prq3_Intensity_ShockRecipient_a)
#> Model _a does not converge with bobyqa (default) or Nelder_Mead optimiser

#drop session-level slopes
lmms$prq3_Intensity_ShockRecipient_b <- lmer(emotionIntensity ~ CAARS_T_index_centred*shockIntensity*shockRecipient
                                          + shockIntensity*trialNo_centered
                                          + (trialNo_centered || subjectID) +
                                            (shockIntensity || subjectID) +  # Random intercept and slope for shockIntensity for subjects nested within sessions
                                            (1 | sessionID),  # random intercept (but no random slopes) for session
                                          data = mod_data_prq3,
                                          control = lmerControl(optimizer = "bobyqa"))
# #> Model failed to converge

#Drop random slope of trialNo | subjectID
lmms$prq3_Intensity_ShockRecipient_c <- lmer(emotionIntensity ~ CAARS_T_index_centred*shockIntensity*shockRecipient 
                                          + shockIntensity*trialNo_centered 
                                          + (1 | sessionID) +  # Uncorrelated slopes/intercepts for sessions
                                            (shockIntensity || subjectID),  # Uncorrelated for subjects within sessions
                                          data = mod_data_prq3,
                                          control = lmerControl(optimizer = "bobyqa"))
# #> Model converged :D :D
check_predictions(lmms$prq3_Intensity_ShockRecipient_c)
check_outliers(lmms$prq3_Intensity_ShockRecipient_c)

#Alternatively, keep shockIntensity || session
lmms$prq3_Intensity_ShockRecipient_d <- lmer(emotionIntensity ~ CAARS_T_index_centred*shockIntensity*shockRecipient 
                                          + shockIntensity*trialNo_centered 
                                          + (shockIntensity || sessionID) + 
                                            (shockIntensity || subjectID),
                                          data = mod_data_prq3,
                                          control = lmerControl(optimizer = "bobyqa"))
# #> Model converged :D :D
check_predictions(lmms$prq3_Intensity_ShockRecipient_d)
check_outliers(lmms$prq3_Intensity_ShockRecipient_d)

#Define winning model
lmms$prq3_Intensity_ShockRecipient_WINNER <- lmms$prq3_Intensity_ShockRecipient_d

#summary with adj. pvals
# summary_p_adj = funcs$adjust_lmm_p_vals(lmms$prq3_Intensity_ShockRecipient_WINNER, 
#                                       "summary", "t", "holm", NA)
# print(summary_p_adj)

```


#### Report results

```{r}

#Save model table
funcs$savelmmTable(lmms$prq3_Intensity_ShockRecipient_WINNER, 
                   paste0(figures_folder,"/", "prq3_intensity_time_ShockRecipient.doc"))

#Save model table using scienfitic notation for numbers
funcs$saveglmmTMBbetaTable_scientific(lmms$prq3_Intensity_ShockRecipient_WINNER, 
                   paste0(figures_folder,"/", "prq3_intensity_time_ShockRecipient_SCIENTIFIC.docx"))

#> Combined the two tables in MS word (estimate, SE, CI using scientific notation)

#Save ANOVA table
anova_prq3_intensity_ShockRecipient <- Anova(lmms$prq3_Intensity_ShockRecipient_WINNER, type = "3")
df_anova_prq3_intensity_ShockRecipient <- as.data.frame(anova_prq3_intensity_ShockRecipient) #convert to df
anova_prq3_intensity_ShockRecipient <- cbind(rownames(anova_prq3_intensity_ShockRecipient), anova_prq3_intensity_ShockRecipient) #add rownames
write_xlsx(anova_prq3_intensity_ShockRecipient, 
           paste0(figures_folder,"/", "anova_prq3_intensity_ShockRecipient.xlsx")) #save

```

#### Figs


```{r}

#--- Plot CAARS_T_index * shock intensity * shock recipient interaction
p_intensity_adhd_intens_recip <- funcs$plot_rating_adhd_intens_recip(lmms$prq3_Intensity_ShockRecipient_WINNER, 
                                                         figures_folder,
                                                         fig_width = 4,
                                                         fig_height = 2.6,
                                                         measure = "emotion intensity", 
                                                         shockIntensityConds = c("Low", "High"))


#------ Shock Intensity x recipient interaction

emm_interaction_intens_recipient <- emmeans(lmms$prq3_Intensity_ShockRecipient_WINNER, ~ shockIntensity * shockRecipient)
contrast(emm_interaction_intens_recipient, interaction = "pairwise") # Get interaction contrasts (pairwise comparisons between combinations)
emm_df_intes_recipient <- as.data.frame(emm_interaction_intens_recipient)

# Convert both variables to factors with meaningful labels
emm_df_intes_recipient$shockIntensity <- factor(emm_df_intes_recipient$shockIntensity, levels = c(0, 1), labels = c("Low", "High"))
emm_df_intes_recipient$shockRecipient <- factor(emm_df_intes_recipient$shockRecipient, levels = c(0, 1), labels = c("Other", "Self"))

# Plot Interaction
p_intes_recipient <- ggplot(emm_df_intes_recipient, aes(x = shockRecipient, y = emmean, 
                                                        color = shockIntensity, 
                                                        shape = shockIntensity, 
                                                        group = shockIntensity)) +
  geom_point(size = 3, position = position_dodge(width = 0.2)) +
  geom_line(position = position_dodge(width = 0.2)) +
  
  # If plotting SE then use the following
    # geom_errorbar(aes(ymin = emmean - SE, ymax = emmean + SE),
    #               width = 0.1, position = position_dodge(width = 0.2)) +
    
    #If plotting CI then use the following
    geom_errorbar(aes(ymin = lower.CL , ymax = upper.CL),
                  width = 0.1, position = position_dodge(width = 0.2)) +
  
  labs(
    y = "Emotional intensity rating",
    x = "Shock Recipient",
    color = "Shock\nIntensity",
    shape = "Shock\nIntensity"
    #title = "Shock Intensity × Shock Recipient,\nresponse phase"
  ) +
  #add custom colours (swap order of first 2 to make high shock blue)
  scale_color_manual(values = c(custom_palette[2], custom_palette[1])) +  
  theme_classic() +
  theme(
    plot.title = element_text(hjust = 0.5, margin = margin(b = 6)),
      panel.spacing = unit(0.5, "lines"),
      strip.background = element_blank(),
      strip.text = element_text(face = "bold"),
      plot.margin = margin(0, 0, 0, 0),
      legend.position = "right",
      legend.box.margin = margin(0, 0, 0, 0),
      legend.margin = margin(0, 0, 0, 0)
  )

#Show figure
p_intes_recipient

#save figure
ggsave(paste0(figures_folder,"/", "Intensity_response_intes_X_recipient.png"), p_intes_recipient, width = 2.6, height = 2.6, units = "in", dpi = 300, limitsize = FALSE)

```

#### Main/simple effects

```{r}
#--- ShockRecipient*shockIntensity interaction, averaging over other variables
emm_intensity_shock_recip <- emmeans(
  lmms$prq3_Intensity_ShockRecipient_WINNER,
  specs = ~ shockIntensity * shockRecipient, 
  adjust = "holm",
  lmer.df = "satterthwaite"
)

#Save emmeans (type = response to keep on response scale)
write_xlsx(as.data.frame(summary(emm_intensity_shock_recip, type = "response")), 
            paste0(figures_folder,"/", "emm_EmoIntensity_shock_recip.xlsx"))

# Test the interaction
contrast(emm_intensity_shock_recip, 
         interaction = "pairwise")

#Save interaction contrast
write_xlsx(as.data.frame(contrast(emm_intensity_shock_recip, 
         interaction = "pairwise")), 
            paste0(figures_folder,"/", "emm_contrasts_EmoIntensity_shock_recip.xlsx"))

#--- Simple effect of ShockIntensity at each level of shockRecipient

emm_intensity_intens_recip_SE <- emmeans(lmms$prq3_Intensity_ShockRecipient_WINNER, 
                                      specs = ~ shockIntensity | shockRecipient, type = 'response',
                                      adjust = "holm",
                                      lmer.df = "satterthwaite")
pairs(emm_intensity_intens_recip_SE)

#Save
write_xlsx(as.data.frame(pairs(emm_intensity_intens_recip_SE)), 
            paste0(figures_folder,"/", "contrasts_emm_EmoIntensity_intens_recip_SE.xlsx"))
```




## Physical sensation intensity ratings

#### Prepare data

```{r}
mod_data_prq3$sensationIntensity_beta <- mod_data_prq3$sensationIntensity / 100
mod_data_prq3$sensationIntensity_beta[mod_data_prq3$sensationIntensity_beta == 0] <- 0.01
mod_data_prq3$sensationIntensity_beta[mod_data_prq3$sensationIntensity_beta == 1] <- 0.99

```


### High vs Low shocks

```{r}
#Try same winning model as valence/arousal ratings
lmms$prq3_sensationIntens_ShockRecipient_a <- glmmTMB(sensationIntensity_beta ~ CAARS_T_index_centred*shockIntensity*shockRecipient +
                                            shockIntensity*trialNo_centered +
                                              (shockIntensity || sessionID) +
                                            (shockIntensity || subjectID),
                                        data = mod_data_prq3,
                                        family = beta_family())
#> Model does not converge (gradient and hessian=null)

#Remove random slope for session
lmms$prq3_sensationIntens_ShockRecipient_b <- glmmTMB(sensationIntensity_beta ~ CAARS_T_index_centred*shockIntensity*shockRecipient +
                                            shockIntensity*trialNo_centered +
                                              (1 | sessionID) +
                                            (shockIntensity || subjectID),
                                        data = mod_data_prq3,
                                        family = beta_family())

#Remove random intercept for session
lmms$prq3_sensationIntens_ShockRecipient_c <- glmmTMB(sensationIntensity_beta ~ CAARS_T_index_centred*shockIntensity*shockRecipient +
                                            shockIntensity*trialNo_centered +
                                            (shockIntensity || subjectID),
                                        data = mod_data_prq3,
                                        family = beta_family())

#Try removing shockIntensity*trialNo_Centred
lmms$prq3_sensationIntens_ShockRecipient_d <- glmmTMB(sensationIntensity_beta ~ CAARS_T_index_centred*shockIntensity*shockRecipient +
                                              (shockIntensity || sessionID) +
                                            (shockIntensity || subjectID),
                                        data = mod_data_prq3,
                                        family = beta_family())

check_predictions(lmms$prq3_sensationIntens_ShockRecipient_d)

#Define winning model
lmms$prq3_sensationIntens_ShockRecipient_WINNER <- lmms$prq3_sensationIntens_ShockRecipient_d

Anova(lmms$prq3_sensationIntens_ShockRecipient_WINNER, type = "3")
#>> ADHD traits associated with greater increase in sensation intensity for high shocks (vs low shocks),
#across both shock recipient conditions

```

##### Report results

```{r}

#Save model table
funcs$saveglmmTMBbetaTable(lmms$prq3_sensationIntens_ShockRecipient_WINNER, 
                   paste0(figures_folder,"/", "prq3_sensationIntens_ShockRecipient.doc"))

#Save model table using scienfitic notation for numbers
funcs$saveglmmTMBbetaTable_scientific(lmms$prq3_sensationIntens_ShockRecipient_WINNER, 
                   paste0(figures_folder,"/", "prq3_sensationIntens_ShockRecipient_SCIENTIFIC.docx"))

#> Combined the two tables in MS word (estimate, SE, CI using scientific notation)

#Save ANOVA table
anova_prq3_sensationIntens_ShockRecipient <- Anova(lmms$prq3_sensationIntens_ShockRecipient_WINNER, type = "3")
anova_prq3_sensationIntens_ShockRecipient <- as.data.frame(anova_prq3_sensationIntens_ShockRecipient) #convert to df
anova_prq3_sensationIntens_ShockRecipient <- cbind(rownames(anova_prq3_sensationIntens_ShockRecipient), anova_prq3_sensationIntens_ShockRecipient) #add rownames
write_xlsx(anova_prq3_sensationIntens_ShockRecipient, 
           paste0(figures_folder,"/", "anova_prq3_sensationIntens_ShockRecipient.xlsx")) #save


```

##### Figs

```{r}
#--- Plot CAARS_T_index * shock intensity * shock recipient interaction
p_intensity_adhd_intens_recip <- funcs$plot_rating_adhd_intens_recip(lmms$prq3_sensationIntens_ShockRecipient_WINNER, 
                                                         figures_folder,
                                                         fig_width = 4,
                                                         fig_height = 2.6,
                                                         measure = "sensation intensity", 
                                                         shockIntensityConds = c("Low", "High"))


#----Plot CAARS_T_index*shockIntensity interaction
# Get predicted values for the interaction
preds_index_sensation_response <- ggpredict(
  lmms$prq3_sensationIntens_ShockRecipient_WINNER, 
  terms = c("CAARS_T_index_centred [all]", "shockIntensity"),
  bias_correction = TRUE #use bias correction for glmer models
)

# Plot using ggplot2
preds_index_sensation_response$group <- factor(preds_index_sensation_response$group, levels = c("0", "1"), labels = c("Low", "High"))

p_index_sensation_response <- ggplot(preds_index_sensation_response, aes(x = x, y = predicted*100, color = group, fill = group)) +
  geom_line(size = 1.2) +
  geom_ribbon(aes(ymin = conf.low*100, ymax = conf.high*100), alpha = 0.15, color = NA) +
  labs(
    x = "CAARS-S:S index (centred)",
    y = "Sensation Intensity rating",
    color = "Shock\nIntensity",
    fill = "Shock\nIntensity"
    #title = "Main effect of CAARS ADHD index\non Intensity, response phase"
  ) +
  scale_color_manual(values = c(custom_palette[2], custom_palette[1]), labels = c("Low", "High")) +
  scale_fill_manual(values = c(custom_palette[2], custom_palette[1]), labels = c("Low", "High")) +
  theme_classic() 

#show figure
p_index_sensation_response

#save figure
ggsave(paste0(figures_folder,"/", "preds_index_sensation_response.png"), p_index_sensation_response, width = 2.6, height = 2.6, units = "in", dpi = 300, limitsize = FALSE)


#---- Plot shockIntensity main effect

#calculate emmeans for each level
emm_rating_intens <- emmeans(lmms$prq3_sensationIntens_ShockRecipient_WINNER, ~ shockIntensity ,  type = "response")
emm_df_rating_intes <- as.data.frame(emm_rating_intens)

# Convert both variables to factors with meaningful labels
emm_df_rating_intes$shockIntensity <- factor(emm_df_rating_intes$shockIntensity, levels = c(0, 1), labels = c("Low", "High"))

p_intens <- ggplot(emm_df_rating_intes, 
                   aes(x = shockIntensity, y = response*100,
                       color = shockIntensity,
                       shape = shockIntensity,
                       group = shockIntensity)) +
  geom_point(size = 3, position = position_dodge(width = 0.2)) +
  geom_line(position = position_dodge(width = 0.2)) +
  
  # If plotting SE then use the following
    # geom_errorbar(aes(ymin = response*100 - SE*100, ymax = response*100 + SE*100),
    #               width = 0.1, position = position_dodge(width = 0.2)) +
    
    #If plotting CI then use the following
    geom_errorbar(aes(ymin = asymp.LCL*100 , ymax = asymp.UCL*100),
                  width = 0.1, position = position_dodge(width = 0.2)) +
  
  labs(
    y = "Sensation intensity rating",
    x = "Shock Intensity",
    color = "Shock\nIntensity",
    shape = "Shock\nIntensity"
    #title = "Shock Intensity × Shock Recipient,\nresponse phase"
  ) +
  #specify y limits
  #coord_cartesian(ylim = y_limits) +
  #add custom colours (swap order of first 2 to make high shock blue)
  scale_color_manual(values = c(custom_palette[2], custom_palette[1])) +
  theme_classic() +
  theme(
    plot.title = element_text(hjust = 0.5, margin = margin(b = 6)),
    panel.spacing = unit(0.5, "lines"),
    strip.background = element_blank(),
    strip.text = element_text(face = "bold"),
    plot.margin = margin(0, 0, 0, 0),
    legend.position = "right",
    legend.box.margin = margin(0, 0, 0, 0),
    legend.margin = margin(0, 0, 0, 0)
  ) + 
  coord_cartesian(ylim = c(25, 38))

#Show figure
p_intens

#save figure
save_filepath = paste0(figures_folder,"/", "sensation", "_intes.png")

ggsave(save_filepath, p_intens, 
       height = 2.6, 
       width = 2, 
       units = "in", dpi = 300, limitsize = FALSE)


#---- Plot shockRecipient main effect

#calculate emmeans for each level
emm_rating_recipient <- emmeans(lmms$prq3_sensationIntens_ShockRecipient_WINNER, ~ shockRecipient ,  type = "response")

emm_df_rating_recip <- as.data.frame(emm_rating_recipient)

# Convert both variables to factors with meaningful labels
emm_df_rating_recip$shockRecipient <- factor(emm_df_rating_recip$shockRecipient, levels = c(0, 1), labels = c("Other", "Self"))

p_recipient <- ggplot(emm_df_rating_recip, 
                   aes(x = shockRecipient, y = response*100,
                       color = shockRecipient,
                       shape = shockRecipient,
                       group = shockRecipient)) +
  geom_point(size = 3, position = position_dodge(width = 0.2)) +
  geom_line(position = position_dodge(width = 0.2)) +
    
  # If plotting SE then use the following
    # geom_errorbar(aes(ymin = response*100 - SE*100, ymax = response*100 + SE*100),
    #               width = 0.1, position = position_dodge(width = 0.2)) +
    
    #If plotting CI then use the following
    geom_errorbar(aes(ymin = asymp.LCL*100 , ymax = asymp.UCL*100),
                  width = 0.1, position = position_dodge(width = 0.2)) +

  labs(
    y = "Sensation intensity rating",
    x = "Shock Recipient",
    color = "Shock\nRecipient",
    shape = "Shock\nRecipient"
    #title = "Shock Intensity × Shock Recipient,\nresponse phase"
  ) +
  #specify y limits
  #coord_cartesian(ylim = y_limits) +
  #add custom colours (swap order of first 2 to make high shock blue)
  scale_color_manual(values = c(custom_palette[4], custom_palette[3])) +
  theme_classic() +
  theme(
    plot.title = element_text(hjust = 0.5, margin = margin(b = 6)),
    panel.spacing = unit(0.5, "lines"),
    strip.background = element_blank(),
    strip.text = element_text(face = "bold"),
    plot.margin = margin(0, 0, 0, 0),
    legend.position = "right",
    legend.box.margin = margin(0, 0, 0, 0),
    legend.margin = margin(0, 0, 0, 0)
    
  ) + 
  coord_cartesian(ylim = c(19,55))

#Show figure
p_recipient

#save figure
save_filepath = paste0(figures_folder,"/", "sensation", "_recipient.png")

ggsave(save_filepath, p_recipient, 
       height = 2.6, 
       width = 2, 
       units = "in", dpi = 300, limitsize = FALSE)

#------ Shock Intensity x recipient interaction

# emm_interaction_intens_recipient <- emmeans(lmms$prq3_sensationIntens_ShockRecipient_WINNER, ~ shockIntensity * shockRecipient,  type = "response")
# contrast(emm_interaction_intens_recipient, interaction = "pairwise") # Get interaction contrasts (pairwise comparisons between combinations)
# emm_df_intes_recipient <- as.data.frame(emm_interaction_intens_recipient)
# 
# # Convert both variables to factors with meaningful labels
# emm_df_intes_recipient$shockIntensity <- factor(emm_df_intes_recipient$shockIntensity, levels = c(0, 1), labels = c("Low", "High"))
# emm_df_intes_recipient$shockRecipient <- factor(emm_df_intes_recipient$shockRecipient, levels = c(0, 1), labels = c("Other", "Self"))
# 
# # Plot Interaction
# p_intes_recipient <- ggplot(emm_df_intes_recipient, aes(x = shockRecipient, y = emmean, 
#                                                         color = shockIntensity, 
#                                                         shape = shockIntensity, 
#                                                         group = shockIntensity)) +
#   geom_point(size = 3, position = position_dodge(width = 0.2)) +
#   geom_line(position = position_dodge(width = 0.2)) +
#   # If plotting SE then use the following
#     # geom_errorbar(aes(ymin = emmean - SE, ymax = emmean + SE),
#     #               width = 0.1, position = position_dodge(width = 0.2)) +
#     
#     #If plotting CI then use the following
#     geom_errorbar(aes(ymin = asymp.LCL , ymax = asymp.UCL),
#                   width = 0.1, position = position_dodge(width = 0.2)) +
#   labs(
#     y = "Sensation intensity rating",
#     x = "Shock Recipient",
#     color = "Shock Intensity",
#     shape = "Shock Intensity"
#     #title = "Shock Intensity × Shock Recipient,\nresponse phase"
#   ) +
#   #add custom colours (swap order of first 2 to make high shock blue)
#   scale_color_manual(values = c(custom_palette[2], custom_palette[1])) +  
#   theme_classic() +
#   theme(
#     plot.title = element_text(hjust = 0.5, margin = margin(b = 6)),
#     panel.spacing = unit(0.5, "lines"),
#     strip.background = element_blank(),
#     strip.text = element_text(face = "bold"),
#     plot.margin = margin(0, 0, 0, 0),
#     legend.position = "right",
#     legend.box.margin = margin(0, 0, 0, 0),
#     legend.margin = margin(0, 0, 0, 0)
#   )
# 
# #Show figure
# p_intes_recipient
# 
# #save figure
# ggsave(paste0(figures_folder,"/", "Sensation_intes_X_recipient.png"), p_intes_recipient, width = 2.6, height = 2.6, units = "in", dpi = 300, limitsize = FALSE)
```

##### Main/simple effects

```{r}

#---- CAARS index * shock intensity interaction

# Get the estimated marginal trends (slopes) of CAARS_T_index_centred
emm_trends_sensation_index_intensity <- emtrends(
  lmms$prq3_sensationIntens_ShockRecipient_WINNER,
  var = "CAARS_T_index_centred", 
  specs = ~ shockIntensity,
  adjust = "holm",
  lmer.df = "satterthwaite"
)

#show simple effects
summary(emm_trends_sensation_index_intensity, type = "response", infer = TRUE)

#Save simple effects
write_xlsx(as.data.frame(summary(emm_trends_sensation_index_intensity, type = "response", infer = TRUE)), 
           paste0(figures_folder,"/", "emm_trends_sensation_index_intensity.xlsx"))

#Save emtrend estimates (type = response to keep on response scale)
write_xlsx(as.data.frame(summary(emm_trends_sensation_index_intensity, type = "response")), 
           paste0(figures_folder,"/", "emm_trends_sensation_index_intensity.xlsx"))

#show interaction contrast
pairs(emm_trends_sensation_index_intensity)

#Save interaction contrast
write_xlsx(as.data.frame(pairs(emm_trends_sensation_index_intensity)), 
           paste0(figures_folder,"/", "contrasts_emm_trends_sensation_index_intensity.xlsx"))




#---- shock intensity main effect

emm_trends_sensation_intensity <- emmeans(
  lmms$prq3_sensationIntens_ShockRecipient_WINNER,
  specs  = "shockIntensity", 
  adjust = "holm",
  lmer.df = "satterthwaite"
)

#Save (type = response to keep on response scale)
write_xlsx(as.data.frame(summary(emm_trends_sensation_intensity, type = "response")), 
            paste0(figures_folder,"/", "emm_trends_sensation_intensity.xlsx"))

#show pairwise comparisons
pairs(emm_trends_sensation_intensity)

#Save
write_xlsx(as.data.frame(pairs(emm_trends_sensation_intensity)), 
            paste0(figures_folder,"/", "contrasts_emm_trends_sensation_intensity.xlsx"))


#---- shock recipient main effect

emm_trends_sensation_recipient <- emmeans(
  lmms$prq3_sensationIntens_ShockRecipient_WINNER,
  specs  = "shockRecipient", 
  adjust = "holm",
  lmer.df = "satterthwaite"
)

#Save (type = response to keep on response scale)
write_xlsx(as.data.frame(summary(emm_trends_sensation_recipient, type = "response")), 
            paste0(figures_folder,"/", "emm_trends_sensation_recipient.xlsx"))

#show pairwise comparisons
pairs(emm_trends_sensation_recipient)

#Save
write_xlsx(as.data.frame(pairs(emm_trends_sensation_recipient)), 
            paste0(figures_folder,"/", "contrasts_emm_trends_sensation_recipient.xlsx"))



```




#----
# SRQ 1 - shock thresholds analyses

## SRQ 1a High shock threshold

### Figs

```{r}

#ADHD index vs high shock threshold
p_highthresh_ADHD <- ggplot(df_demographs, aes(x = CAARS_T_index, y = log(highIntensitySelf))) +
  geom_point(color = custom_palette[1]) +
  geom_smooth(method = "lm", color = "black", fill = custom_palette[1], se = TRUE) +
  labs(
    x = "CAARS-S:S ADHD Index",
    y = "Shock Threshold (log(mA))",
    title = "Scatter Plot of CAARS T Index vs High Intensity Shock Threshold"
  ) +
  theme_classic()

#show figure
p_highthresh_ADHD

#save figure
ggsave(paste0(figures_folder,"/", "p_highthresh_ADHD.png"), p_highthresh_ADHD, width = 3, height = 3, units = "in", dpi = 300)


#ADHD index vs high shock threshold, split by sex
p_highthresh_ADHD_sex <- ggplot(df_demographs, aes(x = CAARS_T_index, y = highIntensitySelf, color = sex)) +
  geom_point() +
  scale_color_manual(values = custom_palette) +
  labs(
    x = "CAARS T Index",
    y = "Shock Threshold (mA)",
    title = "Scatter Plot of CAARS T Index vs High Intensity Shock Threshold"
  ) +
  theme_classic()

#show figure
p_highthresh_ADHD_sex

#save figure
ggsave(paste0(figures_folder,"/", "p_highthresh_ADHD_sex.png"), p_highthresh_ADHD_sex, width = 3, height = 3, units = "in", dpi = 300)


```


### Model no covariates

```{r}
lms$shock_h_index <- lm(highIntensitySelf ~ CAARS_T_index_centred, 
                      data = df_demographs)
summary(lms$shock_h_index)

check_model(lms$shock_h_index)
simulationOutput = DHARMa::simulateResiduals(lms$shock_h_index)
plot(simulationOutput)

#QQ plot is very skewed. Try log-tansforming DV
df_demographs$highIntensitySelf_log <- log(df_demographs$highIntensitySelf)
lms$shock_h_index_log <- lm(highIntensitySelf_log ~ CAARS_T_index_centred,
                      data = df_demographs)

summary(lms$shock_h_index_log)
check_model(lms$shock_h_index_log)
simulationOutput = DHARMa::simulateResiduals(lms$shock_h_index_log)
plot(simulationOutput)
check_outliers(lms$shock_h_index_log)
check_heteroskedasticity(lms$shock_h_index_log)
check_normality(lms$shock_h_index_log)


#Report model results
report(lms$shock_h_index_log)

#calculate cohen's d
b <- coef(lms$shock_h_index_log)["CAARS_T_index_centred"] 
s <- sigma(lms$shock_h_index_log)
cohens_d <- b / s # Calculate Cohen's d
cohens_d

#Save model table with scientific notation
funcs$export_regression_table_to_word(lms$shock_h_index_log, 
                                file = paste0(figures_folder, "/", "shock_h_index_log.docx"),
                                sci_format = FALSE)



```

### Model + covariates

```{r}
lms$shock_h_index_covar_log <- lm(log(highIntensitySelf) ~ CAARS_T_index_centred + age + sex + BMI, 
                      data = df_demographs)
summary(lms$shock_h_index_covar_log)

check_model(lms$shock_h_index_covar_log)
simulationOutput = DHARMa::simulateResiduals(lms$shock_h_index_covar_log)
plot(simulationOutput)
check_outliers(lms$shock_h_index_covar_log)
check_heteroskedasticity(lms$shock_h_index_covar_log)
check_collinearity(lms$shock_h_index_covar_log)

#Residuals are much better but still non-normal. Use robust SEs
ct <- coeftest(lms$shock_h_index_covar_log, vcov = sandwich::vcovHC(lms$shock_h_index_covar_log, type = "HC3"))

# Convert to data frame and save
ct_df <- as.data.frame(ct)
ct_df <- as.tibble(ct_df[1:5,])
ct_df$term <- rownames(ct)
ct_df <- ct_df[, c("term", setdiff(names(ct_df), "term"))]  # Move 'term' to first column
write_xlsx((ct_df), paste0(figures_folder, '/', 'shock_h_index_covar_log.xlsx'))

```



## SRQ 1b Low shock threshold

### Figs

```{r}

#ADHD index vs low shock threshold
p_lowthresh_ADHD <- ggplot(df_demographs, aes(x = CAARS_T_index, y = log(lowIntensitySelf))) +
  geom_point(color = custom_palette[1]) +
  geom_smooth(method = "lm", color = "black", fill = custom_palette[1], se = TRUE) +
  labs(
    x = "CAARS-S:S ADHD Index",
    y = "Shock Threshold (log(mA))",
    title = "Scatter Plot of CAARS T Index vs Low Intensity Shock Threshold"
  ) +
  theme_classic()

#show fig
p_lowthresh_ADHD

#save
ggsave(paste0(figures_folder,"/", "p_lowthresh_ADHD.png"), p_lowthresh_ADHD, width = 3, height = 3, units = "in", dpi = 300)

#ADHD index vs low shock threshold, split by sex
p_lowthresh_ADHD_sex <- ggplot(df_demographs, aes(x = CAARS_T_index, y = lowIntensitySelf, color = sex)) +
  geom_point() +
  scale_color_manual(values = custom_palette) +
  labs(
    x = "CAARS T Index",
    y = "Shock Threshold (mA)",
    title = "Scatter Plot of CAARS T Index vs Low Intensity Shock Threshold"
  ) +
  theme_classic()

#show fig
p_lowthresh_ADHD_sex

#save figure
ggsave(paste0(figures_folder,"/", "p_lowthresh_ADHD_sex.png"), p_lowthresh_ADHD_sex, width = 3, height = 3, units = "in", dpi = 300)

```

### Model no covariates

```{r}
lms$shock_l_index <- lm(lowIntensitySelf ~ CAARS_T_index_centred, 
                        data = df_demographs)
summary(lms$shock_l_index)

check_model(lms$shock_l_index)
simulationOutput = DHARMa::simulateResiduals(lms$shock_l_index)
plot(simulationOutput)

#QQ plot is very skewed. Try log-tansforming DV
df_demographs$lowIntensitySelf_log <- log(df_demographs$lowIntensitySelf)
lms$shock_l_index_log <- lm(lowIntensitySelf_log ~ CAARS_T_index_centred, 
                            data = df_demographs)
summary(lms$shock_l_index_log)
check_model(lms$shock_l_index_log)
simulationOutput = DHARMa::simulateResiduals(lms$shock_l_index_log)
plot(simulationOutput)
check_outliers(lms$shock_l_index_log)
check_heteroskedasticity(lms$shock_l_index_log)

#> All assumpations fine

#Report model results
report(lms$shock_l_index_log)

#calculate cohen's d
b <- coef(lms$shock_l_index_log)["CAARS_T_index_centred"] 
s <- sigma(lms$shock_l_index_log)
cohens_d <- b / s # Calculate Cohen's d
cohens_d

#Save model table with scientific notation
funcs$export_regression_table_to_word(lms$shock_l_index_log, 
                                      file = paste0(figures_folder, "/", "shock_l_index_log.docx"),
                                      sci_format = FALSE)

```

### Model + covariates

```{r}
lms$shock_l_index_covar_log <- lm(log(lowIntensitySelf) ~ CAARS_T_index_centred + age + sex + BMI, 
                                  data = df_demographs)
summary(lms$shock_l_index_covar_log)

check_model(lms$shock_l_index_covar_log)
simulationOutput = DHARMa::simulateResiduals(lms$shock_l_index_covar_log)
plot(simulationOutput)
check_outliers(lms$shock_l_index_covar_log)
check_heteroskedasticity(lms$shock_l_index_covar_log)
check_collinearity(lms$shock_l_index_covar_log)

#>Residuals are non-normal. Use robust SEs.
ct <- coeftest(lms$shock_l_index_covar_log, vcov = sandwich::vcovHC(lms$shock_l_index_covar_log, type = "HC3") )

ct_df <- as.data.frame(ct)
ct_df <- as.tibble(ct_df[1:5,])
ct_df$term <- rownames(ct)
ct_df <- ct_df[, c("term", setdiff(names(ct_df), "term"))]  # Move 'term' to first column
write_xlsx((ct_df), paste0(figures_folder, '/', 'shock_l_index_covar_log.xlsx'))

```





#----

#SRQ 2 - discrete emotions analyses

## Prepare data

```{r}

# Identify columns between height and handedness
preserved_cols <- colnames(df_demographs)[which(colnames(df_demographs) == "height"):which(colnames(df_demographs) == "handedness")]

# Convert to long format while preserving specified columns
long_df <- df_demographs %>%
  pivot_longer(
    cols = starts_with("ant_") | starts_with("rec_"),
    names_to = "variable",
    values_to = "rating"
  ) %>%
  separate(
    variable,
    into = c("phase", "recipient", "emotion", "shock_intensity"),
    sep = "_",
    remove = TRUE
  )

# Spread emotions into separate rating columns
wide_ratings <- long_df %>%
  pivot_wider(
    names_from = emotion,
    values_from = rating,
    names_prefix = "rating_"
  )

# Clean and reorder columns
df_discrete <- wide_ratings %>%
  select(
    subjectID,
    all_of(preserved_cols),  # Preserve specified columns
    phase,
    recipient,
    shock_intensity,
    starts_with("rating_")
  ) %>%
  arrange(subjectID, phase, recipient)


########################

# Mean centre CAARS
mean_CAARS_index <- mean(unlist(df_demographs$CAARS_T_index), na.rm = TRUE)



#----Prepare data for anticipation and response phases
#(keep high + low shock)
df_discrete_antic_high_low <- subset(df_discrete, phase == 'ant' 
                              & (shock_intensity == "high" | shock_intensity == "low") )

df_discrete_response_high_low <- subset(df_discrete, phase == 'rec' 
                                   & (recipient != "ment") #exclude mentalising
                                   & (shock_intensity == "high" | shock_intensity == "low") )

#convert shockIntensity to numeric coding (1,0) to stop R fitting random effects separately for low and high
df_discrete_antic_high_low$shock_intensity <- as.numeric(df_discrete_antic_high_low$shock_intensity == "high")
df_discrete_response_high_low$shock_intensity <- as.numeric(df_discrete_response_high_low$shock_intensity == "high")

#convert recipient to numeric coding (1,0) to stop R fitting random effects separately for self and other
df_discrete_antic_high_low$recipient <- as.numeric(df_discrete_antic_high_low$recipient == "self")
df_discrete_response_high_low$recipient <- as.numeric(df_discrete_response_high_low$recipient == "self")

#Mean centre CAARS
mean_CAARS_index <- mean(unlist(df_demographs$CAARS_T_index), na.rm = TRUE)
df_discrete_antic_high_low$CAARS_T_index_centred <- df_discrete_antic_high_low$CAARS_T_index - mean_CAARS_index

df_discrete_response_high_low$CAARS_T_index_centred <- df_discrete_response_high_low$CAARS_T_index - mean_CAARS_index

#Make CAARS a factor not a continuous variable for these analyses
df_discrete_antic_high_low <- df_discrete_antic_high_low %>%
    mutate(CAARS_T_quantile = cut(CAARS_T_index_centred, breaks = 2))  # 2 quantile-based groups

df_discrete_response_high_low <- df_discrete_response_high_low %>%
    mutate(CAARS_T_quantile = cut(CAARS_T_index_centred, breaks = 2))  # 2 quantile-based groups

#####################


```


## Anticipation phase

### Negative emotion

Preregistered model to aim for:

DVs x5 ~ CAARSADHD index*ShockIntensity*ShockRecipient

Where DVs x5 consists of the ratings for each of the 5 emotion categories (RatingCategory 1 + RatingCategory 2 + RatingCategory 3 + RatingCategory 4 + RatingCategory 5)



##### MANOVA

```{r}

#Fit manova for high vs low shock
manovas$ant_neg_ADHD_recipient <- multRM(cbind(rating_anxfear, rating_distress, rating_sadness, rating_concern, rating_frustann) ~
                                           CAARS_T_quantile*shock_intensity*recipient, 
             data = df_discrete_antic_high_low, 
             subject = "subjectID", within = c("shock_intensity", "recipient"), 
             resampling = "WildBS", #use Wild bootstrapping to account for likely heteroskedasticity due to many zero values
             iter = 1000, alpha = 0.05, seed = 987)
#> Model is singular, but that's not an issue if you interpret the MATS (multivariate anova type statistic)
summary(manovas$ant_neg_ADHD_recipient)

# Save manova table
funcs$save_manova_MATS_table(manovas$ant_neg_ADHD_recipient, 
                       paste0(figures_folder,"/", "df_manova_ant_neg_ADHD_recipient.xlsx") )


```


##### Explore ME ADHD traits

Use linear models rather than beta models because they are a more directly comparable to MANOVAs as both assume a normal distribution

```{r}

#Show individual contrasts for each DV
ant_anxfear_adhd <- funcs$fit_univariate_lmm("rating_anxfear", data = df_discrete_antic_high_low)
ant_distress_adhd <- funcs$fit_univariate_lmm("rating_distress", data = df_discrete_antic_high_low)
ant_sadness_adhd <- funcs$fit_univariate_lmm("rating_sadness", data = df_discrete_antic_high_low)
ant_concern_adhd <- funcs$fit_univariate_lmm("rating_concern", data = df_discrete_antic_high_low)
ant_frustann_adhd <-  funcs$fit_univariate_lmm("rating_frustann", data = df_discrete_antic_high_low)

#calculate emtrends
contrast_emm_trends_ant_anxfear_adhd <-  emtrends(ant_anxfear_adhd, ~1, var = "CAARS_T_index_centred", lmer.df = "Satterthwaite")
contrast_emm_trends_ant_distress_adhd <- emtrends(ant_distress_adhd, ~1, var = "CAARS_T_index_centred", lmer.df = "Satterthwaite")
contrast_emm_trends_ant_sadness_adhd <- emtrends(ant_sadness_adhd, ~1, var = "CAARS_T_index_centred", lmer.df = "Satterthwaite")
contrast_emm_trends_ant_concern_adhd <- emtrends(ant_concern_adhd, ~1, var = "CAARS_T_index_centred", lmer.df = "Satterthwaite")
contrast_emm_trends_ant_frustann_adhd <- emtrends(ant_frustann_adhd, ~1, var = "CAARS_T_index_centred", lmer.df = "Satterthwaite")


#combine emtrends contrasts into single table
emcontrasts_ant_negative_combined <- rbind(  as.data.frame(contrast_emm_trends_ant_anxfear_adhd),
                                                  as.data.frame(contrast_emm_trends_ant_distress_adhd),
                                                  as.data.frame(contrast_emm_trends_ant_sadness_adhd),
                                                  as.data.frame(contrast_emm_trends_ant_concern_adhd),
                                                  as.data.frame(contrast_emm_trends_ant_frustann_adhd))

#add rownames
emcontrasts_ant_negative_combined$emotion <- c("anxiety/fear", "distress", "sadness", "concern", "frustration/annoyance")

#calculate t test
emcontrasts_ant_negative_combined$t <- emcontrasts_ant_negative_combined$CAARS_T_index_centred.trend / emcontrasts_ant_negative_combined$SE
emcontrasts_ant_negative_combined$p_vals <- 2 * pt(-abs(emcontrasts_ant_negative_combined$t), emcontrasts_ant_negative_combined$df)

#calculate holm-bonferroni adjusted p values
emcontrasts_ant_negative_combined$p_adj = p.adjust(emcontrasts_ant_negative_combined$p_vals, 
                                                        method = "holm")

#Save
write_xlsx(as.data.frame(emcontrasts_ant_negative_combined), 
           paste0(figures_folder,"/", "emcontrasts_ant_negative_combined.xlsx"))

```


### Positive emotion

Preregistered model to aim for:

DVs x5 ~ CAARSADHD index*ShockIntensity*ShockRecipient

Where DVs x5 consists of the ratings for each of the 5 emotion categories (RatingCategory 1 + RatingCategory 2 + RatingCategory 3 + RatingCategory 4 + RatingCategory 5)

#### MANOVA

```{r}

#Fit manova for high vs low shock
manovas$ant_pos_ADHD_recipient <- multRM(cbind(rating_relief, rating_calmness, rating_happiness, rating_amusement, rating_excitement) ~
                                           CAARS_T_quantile*shock_intensity*recipient, 
             data = df_discrete_antic_high_low, 
             subject = "subjectID", within = c("shock_intensity", "recipient"), 
             resampling = "WildBS", #use Wild bootstrapping to account for likely heteroskedasticity due to many zero values
             iter = 1000, alpha = 0.05, seed = 987)
#> Model is singular, but that's not an issue if you interpret the MATS (multivariate anova type statistic)
summary(manovas$ant_pos_ADHD_recipient)


# Save manova table
funcs$save_manova_MATS_table(manovas$ant_pos_ADHD_recipient, 
                       paste0(figures_folder,"/", "df_manova_ant_pos_ADHD_recipient.xlsx") )

```


### Neutral

#### LMM

Pre-registered model:
RatingNeutral ~ CAARSADHD index*ShockIntensity*ShockRecipient + (1 | Subject)

```{r}
#Fit model
lmms$ant_neutral_ADHD_intens_recip <- lmer(rating_neutral ~ CAARS_T_index_centred*shock_intensity*recipient 
                                          + (1 | subjectID), 
                                          data = df_discrete_antic_high_low,
                                 control = lmerControl(optimizer = "bobyqa"))
#> Model converges :D :D
check_predictions(lmms$ant_neutral_ADHD_intens_recip)
check_outliers(lmms$ant_neutral_ADHD_intens_recip)
check_heteroscedasticity(lmms$ant_neutral_ADHD_intens_recip)
check_model(lmms$ant_neutral_ADHD_intens_recip)
simulationOutput = simulateResiduals(lmms$ant_neutral_ADHD_intens_recip)
plot(lmms$ant_neutral_ADHD_intens_recip)
testDispersion(simulationOutput)
#> Heteroskedasticity but Shielzeth et al. paper says this is unlikely to affect
#fixed effects, and ADHD effect is not close to being significant

#> Define winning model
lmms$ant_neutral_ADHD_intens_recip_WINNER <- lmms$ant_neutral_ADHD_intens_recip

#summary with adj. p values
summary(lmms$ant_neutral_ADHD_intens_recip_WINNER)

#Report results
anova_srq2_ant_neutral <- Anova(lmms$ant_neutral_ADHD_intens_recip_WINNER, type = "3")
df_anova_srq2_ant_neutral <- as.data.frame(anova_srq2_ant_neutral) #convert to df
df_anova_srq2_ant_neutral <- cbind(rownames(df_anova_srq2_ant_neutral), df_anova_srq2_ant_neutral) #add rownames
write_xlsx(df_anova_srq2_ant_neutral, 
           paste0(figures_folder,"/", "anova_srq2_ant_neutral.xlsx")) #save

```


### Figs

```{r}

# Calculate means for all variables
subject_means_ant <- df_discrete_antic_high_low %>%
  group_by(subjectID, CAARS_T_index_centred, shock_intensity, recipient) %>%
  summarise(across(c(starts_with("rating_")), 
                  ~ mean(.x, na.rm = TRUE))) %>%
  ungroup() %>%
  mutate(recipient = factor(recipient, 
                           levels = c(0, 1), 
                           labels = c("Other", "Self")))

# ----- Anticipation negative emotions plot

# Define variables and pretty labels
rating_vars_neg <- c("rating_anxfear", "rating_distress", "rating_sadness", 
                 "rating_concern", "rating_frustann")

rating_vars_neg_labels <- c("Anxiety/fear", "Distress", "Sadness", "Concern", "Frustration/annoyance")

#Create panel plot
funcs$plot_panel_discrete(subject_means_ant, 
                          rating_vars = rating_vars_neg,
                          rating_var_labels = rating_vars_neg_labels,
                          save_destination = figures_folder,
                          phase = "anticipation",
                          emotion_categories = "negative")



# ----- Anticipation positive emotions plot

# Define variables and pretty labels
rating_vars_pos <- c("rating_excitement", "rating_amusement", "rating_happiness", 
                 "rating_relief", "rating_calmness", "rating_neutral")

rating_vars_pos_labels <- c("Excitement", "Amusement", "Happiness", "Relief", "Calmness", "Neutral")

#Create panel plot
funcs$plot_panel_discrete(subject_means_ant, 
                          rating_vars = rating_vars_pos,
                          rating_var_labels = rating_vars_pos_labels,
                          save_destination = figures_folder,
                          phase = "anticipation",
                          emotion_categories = "positive")

```



## Response phase

### Negative emotion

Preregistered model to aim for:

DVs x5 ~ CAARSADHD index*ShockIntensity*ShockRecipient

Where DVs x5 consists of the ratings for each of the 5 emotion categories (RatingCategory 1 + RatingCategory 2 + RatingCategory 3 + RatingCategory 4 + RatingCategory 5)

#### MANOVA

```{r}

#Fit manova for high vs low shock
manovas$response_neg_ADHD_recipient <- multRM(cbind(rating_anxfear, rating_distress, rating_sadness, rating_concern, rating_frustann) ~
                                           CAARS_T_quantile*shock_intensity*recipient, 
             data = df_discrete_response_high_low, 
             subject = "subjectID", within = c("shock_intensity", "recipient"), 
             resampling = "WildBS", #use Wild bootstrapping to account for likely heteroskedasticity due to many zero values
             iter = 1000, alpha = 0.05, seed = 987)
#> Model is singular, but that's not an issue if you interpret the MATS (multivariate anova type statistic)
summary(manovas$response_neg_ADHD_recipient)


# Save manova table
funcs$save_manova_MATS_table(manovas$response_neg_ADHD_recipient, 
                       paste0(figures_folder,"/", "df_manova_response_neg_ADHD_recipient.xlsx") )

```

#### Explore ME ADHD traits

Use linear models rather than beta models because they are a more directly comparable to MANOVAs as both assume a normal distribution

```{r}

#Show individual contrasts for each DV
response_anxfear_adhd <- funcs$fit_univariate_lmm("rating_anxfear", data = df_discrete_response_high_low)
response_distress_adhd <- funcs$fit_univariate_lmm("rating_distress", data = df_discrete_response_high_low)
response_sadness_adhd <- funcs$fit_univariate_lmm("rating_sadness", data = df_discrete_response_high_low)
response_concern_adhd <- funcs$fit_univariate_lmm("rating_concern", data = df_discrete_response_high_low)
response_frustann_adhd <-  funcs$fit_univariate_lmm("rating_frustann", data = df_discrete_response_high_low)

#calculate emtrends
contrast_emm_trends_response_anxfear_adhd <-  emtrends(response_anxfear_adhd, ~1, var = "CAARS_T_index_centred", lmer.df = "Satterthwaite")
contrast_emm_trends_response_distress_adhd <- emtrends(response_distress_adhd, ~1, var = "CAARS_T_index_centred", lmer.df = "Satterthwaite")
contrast_emm_trends_response_sadness_adhd <- emtrends(response_sadness_adhd, ~1, var = "CAARS_T_index_centred", lmer.df = "Satterthwaite")
contrast_emm_trends_response_concern_adhd <- emtrends(response_concern_adhd, ~1, var = "CAARS_T_index_centred", lmer.df = "Satterthwaite")
contrast_emm_trends_response_frustann_adhd <- emtrends(response_frustann_adhd, ~1, var = "CAARS_T_index_centred", lmer.df = "Satterthwaite")


#combine emtrends contrasts into single table
emcontrasts_response_negative_combined <- rbind(  as.data.frame(contrast_emm_trends_response_anxfear_adhd),
                                                  as.data.frame(contrast_emm_trends_response_distress_adhd),
                                                  as.data.frame(contrast_emm_trends_response_sadness_adhd),
                                                  as.data.frame(contrast_emm_trends_response_concern_adhd),
                                                  as.data.frame(contrast_emm_trends_response_frustann_adhd))

#add rownames
emcontrasts_response_negative_combined$emotion <- c("anxiety/fear", "distress", "sadness", "concern", "frustration/annoyance")

#calculate t test
emcontrasts_response_negative_combined$t <- emcontrasts_response_negative_combined$CAARS_T_index_centred.trend / emcontrasts_response_negative_combined$SE
emcontrasts_response_negative_combined$p_vals <- 2 * pt(-abs(emcontrasts_response_negative_combined$t), emcontrasts_response_negative_combined$df)

#calculate holm-bonferroni adjusted p values
emcontrasts_response_negative_combined$p_adj = p.adjust(emcontrasts_response_negative_combined$p_vals, 
                                                        method = "holm")

#Save
write_xlsx(as.data.frame(emcontrasts_response_negative_combined), 
           paste0(figures_folder,"/", "emcontrasts_response_negative_combined.xlsx"))

```

### Positive emotion

Preregistered model to aim for:

DVs x5 ~ CAARSADHD index*ShockIntensity*ShockRecipient

Where DVs x5 consists of the ratings for each of the 5 emotion categories (RatingCategory 1 + RatingCategory 2 + RatingCategory 3 + RatingCategory 4 + RatingCategory 5)

#### MANOVA

```{r}

#Fit manova for high vs low shock

manovas$response_pos_ADHD_recipient <- multRM(cbind(rating_relief, rating_calmness, rating_happiness, rating_amusement, rating_excitement) ~
                                           CAARS_T_quantile*shock_intensity*recipient, 
             data = df_discrete_response_high_low, 
             subject = "subjectID", within = c("shock_intensity", "recipient"), 
             resampling = "WildBS", #use Wild bootstrapping to account for likely heteroskedasticity due to many zero values
             iter = 1000, alpha = 0.05, seed = 987)
#> Model is singular, but that's not an issue if you interpret the MATS (multivariate anova type statistic)
summary(manovas$response_pos_ADHD_recipient)


# Save manova table
funcs$save_manova_MATS_table(manovas$response_pos_ADHD_recipient, 
                       paste0(figures_folder,"/", "df_manova_response_pos_ADHD_recipient.xlsx") )

```


#### Explore CAARS * reipient


```{r}

#Show individual contrasts for each DV
response_relief_adhd <- funcs$fit_univariate_lmm("rating_relief", data = df_discrete_response_high_low)
response_calmness_adhd <- funcs$fit_univariate_lmm("rating_calmness", data = df_discrete_response_high_low)
response_happiness_adhd <- funcs$fit_univariate_lmm("rating_happiness", data = df_discrete_response_high_low)
response_amusement_adhd <- funcs$fit_univariate_lmm("rating_amusement", data = df_discrete_response_high_low)
response_excitement_adhd <- funcs$fit_univariate_lmm("rating_excitement", data = df_discrete_response_high_low)



#----Relief - Simple effects of CAARS index within each shockRecipient condition

funcs$univariate_emtrends_adhd_recipient <- function(data, 
                                                     phase,
                                                     emotion){
  
  # Get the estimated marginal trends (slopes) of CAARS_T_index_centred at each level of shock
  #recipient
  emm_trends <- emtrends(
    data,
    var = "CAARS_T_index_centred", 
    specs = ~ recipient,
    adjust = "holm",
    lmer.df = "satterthwaite"
  )
  
  #Save (type = response to keep on response scale)
  write_xlsx(as.data.frame(summary(emm_trends, type = "response")), 
             paste0(figures_folder,"/", "emm_trends_", phase,"_", emotion, "_adhd_recipient.xlsx"))
  
  #show pairwise comparisons
  return(pairs(emm_trends))
  print(pairs(emm_trends))
  
  #Save
  write_xlsx(as.data.frame(pairs(emm_trends)), 
             paste0(figures_folder,"/", "contrast_emm_trends_", phase,"_", emotion, "_adhd_recipient.xlsx"))
  
}

#Calculate emtrends contrasts
emcontrast_response_relief_adhd_recipient <- funcs$univariate_emtrends_adhd_recipient(response_relief_adhd, phase = "response", emotion = "relief")
emcontrast_response_calmness_adhd_recipient <- funcs$univariate_emtrends_adhd_recipient(response_calmness_adhd, phase = "response", emotion = "calmness")
emcontrast_response_happiness_adhd_recipient <- funcs$univariate_emtrends_adhd_recipient(response_happiness_adhd, phase = "response", emotion = "happiness")
emcontrast_response_amusement_adhd_recipient <- funcs$univariate_emtrends_adhd_recipient(response_amusement_adhd, phase = "response", emotion = "amusement")
emcontrast_response_excitement_adhd_recipient <- funcs$univariate_emtrends_adhd_recipient(response_excitement_adhd, phase = "response", emotion = "excitement")


#combine emtrends contrasts into single table
emcontrasts_response_positive_combined <- rbind(  as.data.frame(emcontrast_response_excitement_adhd_recipient),
                                                  as.data.frame(emcontrast_response_amusement_adhd_recipient),
                                                  as.data.frame(emcontrast_response_happiness_adhd_recipient),
                                                  as.data.frame(emcontrast_response_relief_adhd_recipient),
                                                  as.data.frame(emcontrast_response_calmness_adhd_recipient)
)

#add rownames
emcontrasts_response_positive_combined$emotion <- c("excitement", "amusement", "happiness", "relief", "calmness")

#calculate holm-bonferroni adjusted p values
emcontrasts_response_positive_combined$p_adj = p.adjust(emcontrasts_response_positive_combined$p.value, 
                                                        method = "holm")

#Save
write_xlsx(as.data.frame(emcontrasts_response_positive_combined), 
           paste0(figures_folder,"/", "emcontrasts_response_positive_combined.xlsx"))

```


### Neutral

#### LMM

Pre-registered model:
RatingNeutral ~ CAARSADHD index*ShockIntensity*ShockRecipient + (1 | Subject)

```{r}

#Fit LMM
lmms$response_neutral_ADHD_intens_recip <- lmer(rating_neutral ~ CAARS_T_index_centred*shock_intensity*recipient 
                                          + (1 | subjectID), 
                                          data = df_discrete_response_high_low,
                                 control = lmerControl(optimizer = "bobyqa"))
#> Model converges :D :D
check_predictions(lmms$response_neutral_ADHD_intens_recip)
check_outliers(lmms$response_neutral_ADHD_intens_recip)
check_heteroscedasticity(lmms$response_neutral_ADHD_intens_recip)
check_model(lmms$response_neutral_ADHD_intens_recip)
simulationOutput = simulateResiduals(lmms$response_neutral_ADHD_intens_recip)
plot(lmms$response_neutral_ADHD_intens_recip)
testDispersion(lmms$response_neutral_ADHD_intens_recip)
#> Heteroskedasticity but Shielzeth et al. paper says this is unlikely to affect
#fixed effects, and ADHD effect is not close to being significant

#> Define winning model
lmms$response_neutral_ADHD_intens_WINNER <- lmms$response_neutral_ADHD_intens_recip

#summary with adj. p values
summary(lmms$response_neutral_ADHD_intens_WINNER)

#Report results
anova_srq2_response_neutral <- Anova(lmms$response_neutral_ADHD_intens_WINNER, type = "3")
df_anova_srq2_response_neutral <- as.data.frame(anova_srq2_response_neutral) #convert to df
df_anova_srq2_response_neutral <- cbind(rownames(df_anova_srq2_response_neutral), df_anova_srq2_response_neutral) #add rownames
write_xlsx(df_anova_srq2_response_neutral, 
           paste0(figures_folder,"/", "anova_srq2_response_neutral.xlsx")) #save

```

### Figs

```{r}
# ----- Response phase negative emotions plot
subject_means_response <- df_discrete_response_high_low %>%
  group_by(subjectID, CAARS_T_index_centred, shock_intensity, recipient) %>%
  summarise(across(c(starts_with("rating_")), 
                  ~ mean(.x, na.rm = TRUE))) %>%
  ungroup() %>%
  mutate(recipient = factor(recipient, 
                           levels = c(0, 1), 
                           labels = c("Other", "Self")))

#Create panel plot
funcs$plot_panel_discrete(subject_means_response, 
                          rating_vars = rating_vars_neg,
                          rating_var_labels = rating_vars_neg_labels,
                          save_destination = figures_folder,
                          phase = "response",
                          emotion_categories = "negative")



# ----- Response phase positive emotions plot

#Create panel plot
funcs$plot_panel_discrete(subject_means_response, 
                          rating_vars = rating_vars_pos,
                          rating_var_labels = rating_vars_pos_labels,
                          save_destination = figures_folder,
                          phase = "response",
                          emotion_categories = "positive")


#--- Response phase positive emotions ADND x recipient

#Create list of plots with y-label only on first plot
plot_list_response_pos <- list(
  funcs$plot_single_panel_discrete_ADHD_X_recipient(subject_means_response, "rating_excitement", "Excitement", show_y_label = TRUE),
  funcs$plot_single_panel_discrete_ADHD_X_recipient(subject_means_response, "rating_amusement", "Amusement"),
  funcs$plot_single_panel_discrete_ADHD_X_recipient(subject_means_response, "rating_happiness", "Happiness"),
  funcs$plot_single_panel_discrete_ADHD_X_recipient(subject_means_response, "rating_relief", "Relief"),
  funcs$plot_single_panel_discrete_ADHD_X_recipient(subject_means_response, "rating_calmness", "Calmness"),
  funcs$plot_single_panel_discrete_ADHD_X_recipient(subject_means_response, "rating_neutral", "Neutral") #include neutral
)

# Combine plots horizontally

combined_plot_response_pos_adhd_recip <- wrap_plots(plot_list_response_pos, nrow = 1) + 
  plot_annotation(title = 'Positive emotions During Response Phase by CAARS ADHD Index and Recipient',
                  theme = theme(plot.title = element_text(hjust = 0.5, size = 14)))

# Display final plot
combined_plot_response_pos_adhd_recip

#save plot
ggsave(paste0(figures_folder,"/", "discrete_response_pos_panel_ADHD_recipient.png"), combined_plot_response_pos_adhd_recip, width = 11.66, height = 2.6, units = "in", dpi = 300)

```

# ------

# SRQ3 - Resting state analyses

## Check for unrealistic values

Plausible range for resting HR is 40 to 140 bom

Plausible range for RMSSD is 19 to 107 ms.


```{r}
hr_range <- range(df_demographs$rs_HR_Mean, na.rm = TRUE)
rmssd_range <- range(df_demographs$rs_HRV_RMSSD, na.rm = TRUE)

print(sprintf("Mean HR range: %.2f – %.2f bpm", hr_range[1], hr_range[2]))
print(sprintf("RMSSD range: %.2f – %.2f ms", rmssd_range[1], rmssd_range[2]))

```
>>> HR and RMSSD values are all physiologically plausible

## Correlations between ADHD index and rs variables

```{r}

#Function for creating resting state results table - Pearson correlations between
#one pred_var and a list of resting state measures

create_rs_results_table <- function(rs_outcome_vars, rs_outcome_vars_names, pred_var, data){
  # Create an empty data frame to store results
  rs_results_table <- data.frame(
    Outcome_Variable = rs_outcome_vars,
    r_value = numeric(length(rs_outcome_vars)),
    P_Value = numeric(length(rs_outcome_vars)),
    Adjusted_P_Value = numeric(length(rs_outcome_vars)),
    Significance = character(length(rs_outcome_vars)),
    stringsAsFactors = FALSE
  )
  
  # Loop through each outcome variable
  for (i in seq_along(rs_outcome_vars)) {
    # Extract the outcome variable name
    outcome_var <- rs_outcome_vars[i]
    
    # Calculate Pearson correlation and p-value
    cor_test <- cor.test(data[[pred_var]], data[[outcome_var]], method = "pearson")
    
    # Store results
    rs_results_table$r_value[i] <- cor_test$estimate
    rs_results_table$P_Value[i] <- cor_test$p.value
  }
  
  # Adjust p-values using Benjamini-Hochberg procedure
  rs_results_table$Adjusted_P_Value <- p.adjust(rs_results_table$P_Value, method = "holm")
  
  # Add significance levels based on adjusted p-values
  rs_results_table$Significance <- ifelse(rs_results_table$Adjusted_P_Value < 0.001, "***",
                                          ifelse(rs_results_table$Adjusted_P_Value < 0.01, "**",
                                                 ifelse(rs_results_table$Adjusted_P_Value < 0.05, "*", "")))
  
  # Round r_value to 2 decimal places and append significance asterisks
  rs_results_table$r_value <- paste0(formatC(round(rs_results_table$r_value, 2), format = "f", digits = 4), 
                                     rs_results_table$Significance)
  
  # Remove the Significance column as it's already appended to r_value
  rs_results_table <- subset(rs_results_table, select = -Significance)
  
  # Round p-values to exactly 3 decimal places with consistent formatting
  rs_results_table$P_Value <- formatC(rs_results_table$P_Value, format = "f", digits = 3)
  rs_results_table$Adjusted_P_Value <- formatC(rs_results_table$Adjusted_P_Value, format = "f", digits = 3)
  
  # Remove leading zeros from numeric columns (except Outcome_Variable)
  numeric_columns <- setdiff(names(rs_results_table), "Outcome_Variable")
  for (col in numeric_columns) {
    rs_results_table[[col]] <- sub("^0\\.", ".", as.character(rs_results_table[[col]])) # Remove leading zeros from positive values
    rs_results_table[[col]] <- sub("^-0\\.", "-.", as.character(rs_results_table[[col]])) # Remove leading zeros from negative values
  }
  
  # Rename outcome variables for clean table display
  rs_results_table$Outcome_Variable <- rs_outcome_vars_names
  
  # View the final table
  print(rs_results_table)
  
  return(rs_results_table)
  
  #save as xlsx
  write_xlsx(rs_results_table, paste0(figures_folder, '/', 'rs_', pred_var,'_corr.xlsx'))
  
}



```

## Shortlisted rs variables

```{r}
rs_outcome_vars_list_short <- c("rs_HR_Mean", "rs_HRV_HF", "rs_SCL_Mean", "arm_sys", "arm_dia")

# Define outcome variable names for clean table
rs_outcome_vars_names_list_short <- c("Mean Heart rate (bpm)", "HF (ms^2)", "Mean SCL (µS)", 
                           "Arm systolic blood pressure (mmHg)", "Arm diastolic blood pressure (mmHg)")


#Perform correlations of CAARS index with resting state measures - shortlisted 
rs_index_table_short <- create_rs_results_table(rs_outcome_vars_list_short, rs_outcome_vars_names_list_short, 
                                          pred_var = "CAARS_T_index", df_demographs)
```

## Regressions controlling for demographics variables

### CAARS Index params only

```{r}

# Define outcome variables, predictor variable, and control variables
control_vars <- c("age_centred", "sex", "BMI_centred", "ethnicity")

# Create an empty data frame to store results
rs_results_table_covars <- data.frame(
  Outcome_Variable = rs_outcome_vars_list_short,
  Beta = numeric(length(rs_outcome_vars_list_short)),
  P_Value = numeric(length(rs_outcome_vars_list_short)),
  Adjusted_P_Value = numeric(length(rs_outcome_vars_list_short)),
  Significance = character(length(rs_outcome_vars_list_short)),
  Beta_covar = numeric(length(rs_outcome_vars_list_short)),
  P_Value_covar = numeric(length(rs_outcome_vars_list_short)),
  Adjusted_P_Value_covar = numeric(length(rs_outcome_vars_list_short)),
  Significance_covar = character(length(rs_outcome_vars_list_short)),
  stringsAsFactors = FALSE
)

# Loop through each outcome variable to run regressions
for (i in seq_along(rs_outcome_vars_list_short)) {
  outcome_var <- rs_outcome_vars_list_short[i]
  
  # Run regression without covariates
  reg_results <- funcs$run_regression(outcome_var, pred_var = "CAARS_T_index_centred")
  
  # Store results in the table
  rs_results_table_covars$Beta[i] <- reg_results$std_beta
  rs_results_table_covars$P_Value[i] <- reg_results$p_value
  
  # Run regression with covariates
  reg_results_covar <- funcs$run_regression(outcome_var, pred_var = "CAARS_T_index_centred", control_vars)
  
  # Store results in the table
  rs_results_table_covars$Beta_covar[i] <- reg_results_covar$std_beta
  rs_results_table_covars$P_Value_covar[i] <- reg_results_covar$p_value
}

# Adjust p-values using Benjamini-Hochberg procedure
rs_results_table_covars$Adjusted_P_Value <- p.adjust(rs_results_table_covars$P_Value, method = "holm")
rs_results_table_covars$Adjusted_P_Value_covar <- p.adjust(rs_results_table_covars$P_Value_covar, method = "holm")

# Add significance levels based on adjusted p-values
rs_results_table_covars$Significance <- ifelse(rs_results_table_covars$Adjusted_P_Value < 0.001, "***",
                                        ifelse(rs_results_table_covars$Adjusted_P_Value < 0.01, "**",
                                               ifelse(rs_results_table_covars$Adjusted_P_Value < 0.05, "*", "")))

rs_results_table_covars$Significance_covar <- ifelse(rs_results_table_covars$Adjusted_P_Value_covar < 0.001, "***",
                                              ifelse(rs_results_table_covars$Adjusted_P_Value_covar < 0.01, "**",
                                                     ifelse(rs_results_table_covars$Adjusted_P_Value_covar < 0.05, "*", "")))

# Round beta coefficients and append significance stars
rs_results_table_covars$Beta <- paste0(formatC(round(rs_results_table_covars$Beta, 2), format = "f", digits = 2), 
                                rs_results_table_covars$Significance)
rs_results_table_covars$Beta_covar <- paste0(formatC(round(rs_results_table_covars$Beta_covar, 2), format = "f", digits = 2), 
                                      rs_results_table_covars$Significance_covar)

# Round p-values to 3 decimal places
# Round p-values to exactly 3 decimal places with consistent formatting
rs_results_table_covars$P_Value <- formatC(rs_results_table_covars$P_Value, format = "f", digits = 3)
rs_results_table_covars$Adjusted_P_Value <- formatC(rs_results_table_covars$Adjusted_P_Value, format = "f", digits = 3)
rs_results_table_covars$P_Value_covar <- formatC(rs_results_table_covars$P_Value_covar, format = "f", digits = 3)
rs_results_table_covars$Adjusted_P_Value_covar <- formatC(rs_results_table_covars$Adjusted_P_Value_covar, format = "f", digits = 3)

# Remove the Significance columns as they're already appended to r_value
rs_results_table_covars <- subset(rs_results_table_covars, select = -Significance)
rs_results_table_covars <- subset(rs_results_table_covars, select = -Significance_covar)

# Remove leading zeros from numeric columns (except Outcome_Variable)
numeric_columns <- setdiff(names(rs_results_table_covars), "Outcome_Variable")
for (col in numeric_columns) {
  rs_results_table_covars[[col]] <- sub("^0\\.", ".", as.character(rs_results_table_covars[[col]])) #remove leading zeros from +ive values
  rs_results_table_covars[[col]] <- sub("^-0\\.", "-.", as.character(rs_results_table_covars[[col]])) #remove leading zeros from -ive values
}

# Rename outcome variables for clean table display
rs_results_table_covars$Outcome_Variable <- rs_outcome_vars_names_list_short

# View the final table
print(rs_results_table_covars)

#save as xlsx
write_xlsx(rs_results_table_covars, paste0(figures_folder, '/', 'rs_ADHDindex_lm_covars.xlsx'))

```

# -------------------------------------------

# Exploratory

# -------------------------------------------

## Questionnaire Heatmaps


### ADHD traits x social questionnaires

```{r}

vars_ADHD_social <- c("CAARS_T_index", 
                             "CAARS_T_inatt",
                             "CAARS_T_imp",
                             "CAARS_T_hyp",
                             "RAADS_mentalising",
                             "RAADS_sensoryreact",
                             "RAADS_socialanx",
                             "ICU_callousness",
                             "ICU_uncaring",
                             "CASES_cog",
                             "CASES_aff",
                             "CASES_som", 
                             "CASES_pos",
                             "CASES_neg",
                             "ECR_RS_anx",
                             "ECR_RS_avoid",
                             "UCLA_loneliness_total",
                             "IPSM_IWD_total")

trait_labels_ADHD_social <- c("CAARS-S:S ADHD index",
                  "CAARS-S:S inattention/memory",
                  "CAARS-S:S impulsivity/EL",
                  "CAARS-S:S hyperactivity",
                  "RAADS mentalising",
                  "RAADS sensory reactivity",
                  "RAADS social anxiety",
                  "ICU callousness",
                  "ICU uncaring",
                  "CASES cognitive",
                  "CASES affective",
                  "CASES somativc",
                  "CASES positive",
                  "CASES negative",
                  "ECR-RS anxious",
                  "ECR-RS avoidant",
                  "UCLA loneliness",
                  "IPSM IWD")
                  
## Create heatmap of correlations between self-report measures
corrs$caars_social_Qs <- funcs$createCorrHeatmap(dataTable = df_demographs,
                                        vars_for_corrs = vars_ADHD_social,
                                        var_labels = trait_labels_ADHD_social,
                                    rows_to_keep = c(1:length(vars_ADHD_social)),
                                    corr_type = "pearson",
                                    p_adj_type = "BH",
                                    fig_width = 12,
                                    fig_height = 6,
                                    fig_font_size = 10,
                                    figures_folder = figures_folder,
                                    save_name = "CAARS_social_Qs")

```

### Figs ADHD vs empathy traits

Empathy (CASES) and Callous Unemotional Traits (ICU)

```{r}

#------- CASES cognitive
p_CASES_COG_index <- funcs$plot_scatter(dData = df_demographs, 
                               y_var = "CASES_cog", 
                               x_var = "CAARS_T_index", 
                               y_lab = "CASES cognitive empathy", 
                               x_lab = "CAARS-S:S ADHD Index", 
                               saveFile = paste0(figures_folder, "/", "CASES_COG_index.png"))
#View
print(p_CASES_COG_index)

#------- CASES affective
p_CASES_AFF_index <- funcs$plot_scatter(dData = df_demographs, 
                               y_var = "CASES_aff", 
                               x_var = "CAARS_T_index", 
                               y_lab = "CASES affective empathy", 
                               x_lab = "CAARS-S:S ADHD Index", 
                               saveFile = paste0(figures_folder, "/", "CASES_AFF_index.png"))
#View
print(p_CASES_AFF_index)

#------- CASES somatic
p_CASES_SOM_index <- funcs$plot_scatter(dData = df_demographs, 
                               y_var = "CASES_som", 
                               x_var = "CAARS_T_index", 
                               y_lab = "CASES somatic empathy", 
                               x_lab = "CAARS-S:S ADHD Index", 
                               saveFile = paste0(figures_folder, "/", "CASES_SOM_index.png"))
#View
print(p_CASES_SOM_index)

#------- ICU
p_ICU_total_index <- funcs$plot_scatter(dData = df_demographs, 
                               y_var = "ICU_total_log", 
                               x_var = "CAARS_T_index", 
                               y_lab = "ICU total (log transformed)", 
                               x_lab = "CAARS-S:S ADHD Index", 
                               saveFile = paste0(figures_folder, "/", "ICU_total_index.png"))
#View
print(p_ICU_total_index)

```









